org.apache.kafka.streams.AutoOffsetResetTest:
- customDurationShouldMatchExpectedValue
- shouldThrowExceptionIfDurationIsNegative
- shouldThrowExceptionOnDurationForEarliestReset
- shouldThrowExceptionOnDurationForLatestReset
- shouldThrowExceptionOnDurationForNoneReset
- twoInstancesCreatedAtTheSameTimeWithSameOptionsShouldBeEqual
org.apache.kafka.streams.KafkaStreamsTest:
- inMemoryStatefulTopologyShouldNotCreateStateDirectory
- shouldAddThreadWhenRunning
- shouldAllowCleanupBeforeStartAndAfterClose
- shouldCleanupOldStateDirs
- shouldCleanupResourcesOnCloseWithoutPreviousStart
- shouldCloseStartupTasksAfterFirstRebalance
- shouldCountDownTimeoutAcrossClient
- shouldGetClientSupplierFromConfigForConstructor
- shouldGetClientSupplierFromConfigForConstructorWithTime
- shouldGetQueryMetadataWithSerializerWhenRunningOrRebalancing
- shouldInitializeTasksForLocalStateOnStart
- shouldLogWarningIfNonDefaultClientSupplierUsedWithStreamsProtocol
- shouldNotAddThreadWhenClosed
- shouldNotAddThreadWhenCreated
- shouldNotAddThreadWhenError
- shouldNotBlockInCloseForZeroDuration
- shouldNotBlockInCloseWithCloseOptionLeaveGroupFalseForZeroDuration
- shouldNotBlockInCloseWithCloseOptionLeaveGroupTrueForZeroDuration
- shouldNotCrashButThrowLaterIfAdminTelemetryDisabled
- shouldNotCreateStreamThreadsForGlobalOnlyTopology
- shouldNotGetAllTasksWhenNotRunning
- shouldNotGetAllTasksWithStoreWhenNotRunning
- shouldNotGetQueryMetadataWithPartitionerWhenNotRunningOrRebalancing
- shouldNotGetQueryMetadataWithSerializerWhenNotRunningOrRebalancing
- shouldNotGetStoreWhenWhenNotRunningOrRebalancing
- shouldNotRemoveThreadWhenNotRunning
- shouldNotReturnDeadThreads
- shouldNotSetGlobalRestoreListenerAfterStarting
- shouldNotTriggerRecordingOfRocksDBMetricsIfRecordingLevelIsInfo
- shouldRemoveThread
- shouldReturnAdminInstanceID
- shouldReturnEmptyLocalStorePartitionLags
- shouldReturnFalseOnCloseWhenThreadsHaventTerminated
- shouldReturnFalseOnCloseWithCloseOptionWithLeaveGroupFalseWhenThreadsHaventTerminated
- shouldReturnFalseOnCloseWithCloseOptionWithLeaveGroupTrueWhenThreadsHaventTerminated
- shouldReturnProducerAndConsumerInstanceIds
- shouldThrowExceptionSettingStateListenerNotInCreateState
- shouldThrowExceptionSettingStreamsUncaughtExceptionHandlerNotInCreateState
- shouldThrowExceptionSettingUncaughtExceptionHandlerNotInCreateState
- shouldThrowIfPatternSubscriptionUsedWithStreamsProtocol
- shouldThrowNullPointerExceptionSettingStreamsUncaughtExceptionHandlerIfNull
- shouldThrowOnCleanupWhilePaused
- shouldThrowOnCleanupWhileRunning
- shouldThrowOnCleanupWhileShuttingDown
- shouldThrowOnCleanupWhileShuttingDownStreamClosedWithCloseOptionLeaveGroupFalse
- shouldThrowOnCleanupWhileShuttingDownStreamClosedWithCloseOptionLeaveGroupTrue
- shouldThrowOnClientInstanceIdsWhenClosed
- shouldThrowOnClientInstanceIdsWhenNotStarted
- shouldThrowOnClientInstanceIdsWithNegativeTimeout
- shouldThrowOnNegativeTimeoutForClose
- shouldThrowOnNegativeTimeoutForCloseWithCloseOptionLeaveGroupFalse
- shouldThrowOnNegativeTimeoutForCloseWithCloseOptionLeaveGroupTrue
- shouldThrowStreamsExceptionWhenAdminNotInitialized
- shouldThrowTimeExceptionWhenAdminTimesOut
- shouldThrowTimeoutExceptionWhenAnyClientFutureDoesNotComplete
- shouldThrowTimeoutExceptionWhenGlobalConsumerFutureDoesNotComplete
- shouldThrowTopologyExceptionOnEmptyTopology
- shouldThrowUnknownStateStoreExceptionWhenStoreNotExist
- shouldTransitToRunningWithGlobalOnlyTopology
- shouldTriggerRecordingOfRocksDBMetricsIfRecordingLevelIsDebug
- shouldUseProvidedClientSupplier
- stateShouldTransitToRunningIfNonDeadThreadsBackToRunning
- statefulTopologyShouldCreateStateDirectory
- statelessTopologyShouldNotCreateStateDirectory
- testCannotStartOnceClosed
- testCloseIsIdempotent
- testInitializesAndDestroysMetricsReporters
- testPauseResume
- testShouldTransitToNotRunningIfCloseRightAfterCreated
- testShowPauseResumeAreIdempotent
- testStartingPaused
- testStateGlobalThreadClose
- testStateThreadClose
org.apache.kafka.streams.KeyValueTest:
- shouldHaveSameEqualsAndHashCode
org.apache.kafka.streams.StreamsBuilderTest:
- shouldAddGlobalStore
- shouldAllowJoinMaterializedFilteredKTable
- shouldAllowJoinMaterializedJoinedKTable
- shouldAllowJoinMaterializedMapValuedKTable
- shouldAllowJoinMaterializedSourceKTable
- shouldAllowJoinUnmaterializedFilteredKTable
- shouldAllowJoinUnmaterializedJoinedKTable
- shouldAllowJoinUnmaterializedMapValuedKTable
- shouldAllowReadingFromSameCollectionOfTopics
- shouldAllowStreamsFromSameTopic
- shouldAllowSubscribingToSamePattern
- shouldMergeStreams
- shouldNotAddThirdStateStoreIfStreamStreamJoinFixIsDisabledViaOldApi
- shouldNotAllowReadingFromOverlappingAndUnequalCollectionOfTopics
- shouldNotAllowTablesFromSameTopic
- shouldNotMaterializeStoresIfNotRequired
- shouldNotReuseRepartitionTopicAsChangelogs
- shouldNotReuseSourceTopicAsChangelogsByDefault
- shouldNotThrowNullPointerIfOptimizationsNotSpecified
- shouldNotThrowWhenCoGroupWithMaterializedName
- shouldNotThrowWhenCoGroupWithRepartitionNameAndMaterializedName
- shouldNotThrowWhenGroupByAggregationWithMaterializedName
- shouldNotThrowWhenGroupByAggregationWithRepartitionNameAndMaterialized
- shouldNotThrowWhenGroupByKeyAggregationWithMaterializedName
- shouldNotThrowWhenGroupByKeyAggregationWithRepartitionNameAndMaterializedName
- shouldNotThrowWhenKStreamGlobalKTableJoinWithMaterializedName
- shouldNotThrowWhenKStreamKStreamJoinWithRepartitionNameAndMaterializedName
- shouldNotThrowWhenKStreamKTableJoinWithRepartitionNameAndMaterializedName
- shouldNotThrowWhenKStreamVersionedKTableJoinWithRepartitionName
- shouldNotThrowWhenRepartitionWithRepartitionName
- shouldNotThrowWhenSuppressWithSuppressName
- shouldNowAllowStreamAndTableFromSameTopic
- shouldProcessViaRepartitionTopic
- shouldProcessingFromSinkTopic
- shouldReuseSourceTopicAsChangelogsWithOptimization20
- shouldThrowExceptionWhenNoTopicPresent
- shouldThrowExceptionWhenTopicNamesAreNull
- shouldThrowOnVersionedStoreSupplierForGlobalTable
- shouldThrowWhenCoGroupWithRepartitionNameAndLoggingDisabled
- shouldThrowWhenCoGroupWithRepartitionNameAndLoggingEnabled
- shouldThrowWhenCoGroupWithoutRepartitionNameAndMaterializedName
- shouldThrowWhenGroupByAggregationWithRepartitionNameAndLoggingDisabled
- shouldThrowWhenGroupByAggregationWithRepartitionNameAndLoggingEnabled
- shouldThrowWhenGroupByAggregationWithoutRepartitionNameAndMaterializedName
- shouldThrowWhenGroupByKeyAggregationWithRepartitionNameAndLoggingDisabled
- shouldThrowWhenGroupByKeyAggregationWithRepartitionNameAndLoggingEnabled
- shouldThrowWhenGroupByKeyAggregationWithoutRepartitionNameAndMaterializedName
- shouldThrowWhenKStreamGlobalKTableJoinWithoutStoreName
- shouldThrowWhenKStreamKStreamJoinWithMaterializedName
- shouldThrowWhenKStreamKStreamJoinWithRepartitionNameAndLoggingDisabled
- shouldThrowWhenKStreamKStreamJoinWithRepartitionNameAndLoggingEnabled
- shouldThrowWhenKStreamKStreamJoinWithoutRepartitionNameAndMaterializedName
- shouldThrowWhenKStreamKTableJoinWithMaterializedName
- shouldThrowWhenKStreamKTableJoinWithRepartitionNameAndLoggingDisabled
- shouldThrowWhenKStreamKTableJoinWithRepartitionNameAndLoggingEnabled
- shouldThrowWhenKStreamKTableJoinWithoutRepartitionNameAndMaterializedName
- shouldThrowWhenKStreamVersionedKTableJoinWithoutRepartitionName
- shouldThrowWhenRepartitionWithoutRepartition
- shouldThrowWhenSubscribedToAPatternWithDifferentResetPolicies
- shouldThrowWhenSubscribedToAPatternWithSetAndUnsetResetPolicies
- shouldThrowWhenSubscribedToATopicWithDifferentResetPolicies
- shouldThrowWhenSubscribedToATopicWithSetAndUnsetResetPolicies
- shouldThrowWhenSubscribedToATopicWithUnsetAndSetResetPolicies
- shouldThrowWhenSuppressWithoutSuppressName
- shouldThrowWhenSuppressWithoutSuppressNameAndLoggingDisabled
- shouldUseConfiguredInStreamsConfigIfNoTopologyOverrideDslStoreSuppliersForAllOuterJoinOperationBetweenKStreamAndKStream
- shouldUseConfiguredTopologyOverrideDslStoreSuppliersForAllOuterJoinOperationBetweenKStreamAndKStream
- shouldUseDefaultNameForGlobalStoreProcessor
- shouldUseDslStoreSupplierDefinedConfiguredInStreamsConfig
- shouldUseDslStoreSupplierDefinedConfiguredInStreamsConfigForSessionWindowedOperation
- shouldUseDslStoreSupplierDefinedConfiguredInStreamsConfigForWindowedOperation
- shouldUseDslStoreSupplierDefinedConfiguredInTopologyConfigOverStreamsConfig
- shouldUseDslStoreSupplierDefinedConfiguredInTopologyConfigOverStreamsConfigForSessionWindowedOperation
- shouldUseDslStoreSupplierDefinedConfiguredInTopologyConfigOverStreamsConfigForWindowedOperation
- shouldUseDslStoreSupplierDefinedInMaterialized
- shouldUseDslStoreSupplierDefinedInMaterializedForSessionWindowedOperation
- shouldUseDslStoreSupplierDefinedInMaterializedForWindowedOperation
- shouldUseDslStoreSupplierDefinedInMaterializedOverTopologyOverrides
- shouldUseDslStoreSupplierOverStoreType
- shouldUseGeneratedNameForJoinOperationBetweenKStreamAndKStream
- shouldUseGeneratedStoreNamesForLeftJoinOperationBetweenKStreamAndKStream
- shouldUseGeneratedStoreNamesForOuterJoinOperationBetweenKStreamAndKStream
- shouldUseSerdesDefinedInMaterializedToConsumeGlobalTable
- shouldUseSerdesDefinedInMaterializedToConsumeTable
- shouldUseSpecifiedDslStoreSuppliersForAllOuterJoinOperationBetweenKStreamAndKStream
- shouldUseSpecifiedNameForAggregateOperationGivenTable
- shouldUseSpecifiedNameForFilterOperation
- shouldUseSpecifiedNameForForEachOperation
- shouldUseSpecifiedNameForGlobalStoreProcessor
- shouldUseSpecifiedNameForGlobalTableSourceProcessor
- shouldUseSpecifiedNameForJoinOperationBetweenKStreamAndKStream
- shouldUseSpecifiedNameForJoinOperationBetweenKStreamAndKTable
- shouldUseSpecifiedNameForLeftJoinOperationBetweenKStreamAndKStream
- shouldUseSpecifiedNameForLeftJoinOperationBetweenKStreamAndKTable
- shouldUseSpecifiedNameForMapOperation
- shouldUseSpecifiedNameForMapValuesOperation
- shouldUseSpecifiedNameForMapValuesWithKeyOperation
- shouldUseSpecifiedNameForMergeOperation
- shouldUseSpecifiedNameForOuterJoinOperationBetweenKStreamAndKStream
- shouldUseSpecifiedNameForPrintOperation
- shouldUseSpecifiedNameForProcessOperation
- shouldUseSpecifiedNameForProcessValuesOperation
- shouldUseSpecifiedNameForSinkProcessor
- shouldUseSpecifiedNameForSplitOperation
- shouldUseSpecifiedNameForStreamSourceProcessor
- shouldUseSpecifiedNameForTableSourceProcessor
- shouldUseSpecifiedNameForToStream
- shouldUseSpecifiedNameForToStreamWithMapper
- shouldUseSpecifiedStoreSupplierForEachOuterJoinOperationBetweenKStreamAndKStreamAndUseSameTypeAsThisSupplierForOuter
- shouldUseSpecifiedStoreSuppliersOuterJoinStoreEvenIfThisSupplierIsSupplied
- shouldUseThisStoreSupplierEvenIfDslStoreSuppliersConfiguredInTopologyConfig
- shouldUseTopologyOverrideStoreTypeOverConfiguredDslStoreSupplier
- shouldWrapProcessorAndStoreForFilterTable
- shouldWrapProcessorsForCoGroupedStreamAggregate
- shouldWrapProcessorsForForeignKeyInnerJoin
- shouldWrapProcessorsForForeignKeyLeftJoin
- shouldWrapProcessorsForMapValuesWithMaterializedStore
- shouldWrapProcessorsForMaterializedSourceTable
- shouldWrapProcessorsForProcess
- shouldWrapProcessorsForSessionWindowStreamAggregate
- shouldWrapProcessorsForSlidingWindowStreamAggregate
- shouldWrapProcessorsForStatelessOperators
- shouldWrapProcessorsForStreamAggregate
- shouldWrapProcessorsForStreamReduce
- shouldWrapProcessorsForStreamStreamInnerJoin
- shouldWrapProcessorsForStreamStreamLeftJoin
- shouldWrapProcessorsForStreamStreamOuterJoin
- shouldWrapProcessorsForStreamStreamOuterJoinWithoutSpuriousResultsFix
- shouldWrapProcessorsForStreamStreamSelfJoin
- shouldWrapProcessorsForStreamStreamSelfJoinWithSharedStoreOptimization
- shouldWrapProcessorsForStreamTableJoin
- shouldWrapProcessorsForStreamTableJoinWithGracePeriod
- shouldWrapProcessorsForSuppress
- shouldWrapProcessorsForTableAggregate
- shouldWrapProcessorsForTableReduce
- shouldWrapProcessorsForTableTableInnerJoin
- shouldWrapProcessorsForTableTableLeftJoin
- shouldWrapProcessorsForTableTableOuterJoin
- shouldWrapProcessorsForTimeWindowStreamAggregate
- shouldWrapProcessorsForUnmaterializedSourceTable
- shouldWrapProcessorsWhenMultipleTableOperators
org.apache.kafka.streams.StreamsConfigTest:
- consumerConfigMustContainStreamPartitionAssignorConfig
- defaultSerdeShouldBeConfigured
- shouldAcceptAtLeastOnce
- shouldAcceptBuiltInMetricsLatestVersion
- shouldAllowConfiguringProcessorWrapperWithClass
- shouldAllowConfiguringProcessorWrapperWithClassName
- shouldAllowMultipleOptimizations
- shouldAllowSettingConsumerIsolationLevelIfEosDisabled
- shouldAllowSettingProducerEnableIdempotenceIfEosDisabled
- shouldAllowToSpecifyMaxInFlightRequestsPerConnectionAsStringIfEosV2Enabled
- shouldBeSupportNonPrefixedConsumerConfigs
- shouldBeSupportNonPrefixedGlobalConsumerConfigs
- shouldBeSupportNonPrefixedRestoreConsumerConfigs
- shouldDefaultToEmptyListIfRackAwareAssignmentTagsIsNotSet
- shouldDisableMetricCollectionForAllInternalClients
- shouldEnableAllOptimizationsWithOptimizeConfig
- shouldEnableMetricCollectionForAllInternalClientsByDefault
- shouldEnableMetricsForMainConsumerWhenConsumerPrefixDisabledMetricsPushEnabled
- shouldEnableMetricsForMainConsumerWhenStreamMetricsPushDisabledButMainConsumerEnabled
- shouldEnableSelfJoin
- shouldEnsureExplicitInternalResourceNaming
- shouldForwardCustomConfigsWithNoPrefixToAllClients
- shouldGetClientTagsMapWhenSet
- shouldGetDefaultEnsureExplicitInternalResourceNaming
- shouldGetDefaultValueProcessingExceptionHandler
- shouldGetEmptyMapIfClientTagsAreNotSet
- shouldLogWarningWhenStandbyReplicasSetWithStreamsProtocol
- shouldLogWarningWhenStreamsProtocolIsUsed
- shouldLogWarningWhenWarmupReplicasSetWithStreamsProtocol
- shouldNotEnableAnyOptimizationsWithNoOptimizationConfig
- shouldNotLeakInternalDocMembers
- shouldNotOverrideUserConfigCommitIntervalMsIfExactlyOnceV2Enabled
- shouldNotOverrideUserConfigRetriesIfExactlyV2OnceEnabled
- shouldNotSetEnableMetricCollectionByDefault
- shouldNotSetInternalAutoDowngradeTxnCommitToTrueInProducerForEosV2
- shouldNotSetInternalThrowOnFetchStableOffsetUnsupportedConfigToFalseInConsumerForEosDisabled
- shouldNotSetInternalThrowOnFetchStableOffsetUnsupportedConfigToFalseInConsumerForEosV2
- shouldNotThrowIfTransactionTimeoutSmallerThanCommitIntervalForAtLeastOnce
- shouldOverrideAdminDefaultAdminClientEnableTelemetry
- shouldOverrideDefaultProcessingExceptionHandler
- shouldOverrideNonPrefixedCustomConfigsWithPrefixedConfigs
- shouldOverrideStreamsDefaultConsumerConfigs
- shouldOverrideStreamsDefaultConsumerConfigsOnRestoreConsumer
- shouldOverrideStreamsDefaultProducerConfigs
- shouldOverrideUserConfigTransactionalIdIfEosV2Enabled
- shouldResetToDefaultIfConsumerAutoCommitIsOverridden
- shouldResetToDefaultIfConsumerGroupProtocolIsOverridden
- shouldResetToDefaultIfConsumerIsolationLevelIsOverriddenIfEosV2Enabled
- shouldResetToDefaultIfGlobalConsumerAutoCommitIsOverridden
- shouldResetToDefaultIfGlobalConsumerGroupProtocolIsOverridden
- shouldResetToDefaultIfProducerEnableIdempotenceIsOverriddenIfEosV2Enabled
- shouldResetToDefaultIfRestoreConsumerAutoCommitIsOverridden
- shouldResetToDefaultIfRestoreConsumerGroupProtocolIsOverridden
- shouldReturnDefaultClientSupplier
- shouldReturnDefaultProcessorWrapperClass
- shouldReturnDefaultRackAwareAssignmentConfig
- shouldReturnDefaultRackAwareAssignmentNonOverlapCost
- shouldReturnDefaultRackAwareAssignmentTrafficCost
- shouldReturnRackAwareAssignmentNonOverlapCost
- shouldReturnRackAwareAssignmentTrafficCost
- shouldReturnTaskAssignorClass
- shouldSetAndGetDeserializationExceptionHandlerWhenOnlyNewConfigIsSet
- shouldSetAndGetProductionExceptionHandlerWhenOnlyNewConfigIsSet
- shouldSetBalanceSubtopologyRackAwareAssignmentConfig
- shouldSetDefaultAcceptableRecoveryLag
- shouldSetDefaultBuiltInMetricsVersionIfNoneIsSpecified
- shouldSetDefaultMaxWarmupReplicas
- shouldSetDefaultNumStandbyReplicas
- shouldSetDefaultProbingRebalanceInterval
- shouldSetDifferentDefaultsIfEosV2Enabled
- shouldSetGroupProtocolToClassic
- shouldSetGroupProtocolToClassicByDefault
- shouldSetGroupProtocolToStreams
- shouldSetInternalLeaveGroupOnCloseConfigToFalseInConsumer
- shouldSetMinTrafficRackAwareAssignmentConfig
- shouldSetRackAwareAssignmentTags
- shouldSpecifyCorrectKeySerdeClassOnError
- shouldSpecifyCorrectValueSerdeClassOnError
- shouldSpecifyInMemoryDslSupplierWhenExplicitlyAddedToConfigs
- shouldSpecifyInMemoryWhenExplicitlyAddedToConfigs
- shouldSpecifyNoOptimizationWhenNotExplicitlyAddedToConfigs
- shouldSpecifyOptimizationWhenExplicitlyAddedToConfigs
- shouldSpecifyRocksdbDslSupplierWhenNotExplicitlyAddedToConfigs
- shouldSpecifyRocksdbWhenNotExplicitlyAddedToConfigs
- shouldStateDirStartsWithJavaIOTmpDir
- shouldSupportAllUpgradeFromValues
- shouldSupportMultipleBootstrapServers
- shouldSupportNonPrefixedAdminConfigs
- shouldSupportNonPrefixedProducerConfigs
- shouldSupportPrefixedConsumerConfigs
- shouldSupportPrefixedGlobalConsumerConfigs
- shouldSupportPrefixedProducerConfigs
- shouldSupportPrefixedPropertiesThatAreNotPartOfConsumerConfig
- shouldSupportPrefixedPropertiesThatAreNotPartOfGlobalConsumerConfig
- shouldSupportPrefixedPropertiesThatAreNotPartOfProducerConfig
- shouldSupportPrefixedPropertiesThatAreNotPartOfRestoreConsumerConfig
- shouldSupportPrefixedRestoreConsumerConfigs
- shouldThrowConfigExceptionConsumerMetricsDisabledStreamsMetricsPushEnabled
- shouldThrowConfigExceptionConsumerMetricsEnabledButAdminClientMetricsDisabled
- shouldThrowConfigExceptionConsumerMetricsEnabledButMainConsumerAndAdminMetricsDisabled
- shouldThrowConfigExceptionConsumerMetricsEnabledButMainConsumerMetricsDisabled
- shouldThrowConfigExceptionIfAcceptableRecoveryLagIsOutsideBounds
- shouldThrowConfigExceptionIfMaxInFlightRequestsPerConnectionIsInvalidStringIfEosV2Enabled
- shouldThrowConfigExceptionIfMaxWarmupReplicasIsOutsideBounds
- shouldThrowConfigExceptionIfNumStandbyReplicasIsOutsideBounds
- shouldThrowConfigExceptionIfProbingRebalanceIntervalIsOutsideBounds
- shouldThrowConfigExceptionWhenAdminClientAndMainConsumerMetricsDisabledStreamsMetricsPushEnabled
- shouldThrowConfigExceptionWhenAdminClientMetricsDisabledStreamsMetricsPushEnabled
- shouldThrowConfigExceptionWhenMainConsumerMetricsDisabledStreamsMetricsPushEnabled
- shouldThrowConfigExceptionWhenOptimizationConfigNotValueInRange
- shouldThrowConfigExceptionWhenStoreTypeConfigNotValueInRange
- shouldThrowConfigExceptionWhenStreamsProtocolUsedWithStaticMembership
- shouldThrowExceptionIfApplicationIdIsNotSet
- shouldThrowExceptionIfBootstrapServersIsNotSet
- shouldThrowExceptionIfCommitIntervalMsIsNegative
- shouldThrowExceptionIfMaxInFlightRequestsGreaterThanFiveIfEosV2Enabled
- shouldThrowExceptionIfNotAtLeastOnceOrExactlyOnce
- shouldThrowExceptionWhenClientTagKeyExceedMaxLimit
- shouldThrowExceptionWhenClientTagRackAwarenessIsConfiguredWithUnknownTags
- shouldThrowExceptionWhenClientTagValueExceedMaxLimit
- shouldThrowExceptionWhenClientTagsExceedTheLimit
- shouldThrowExceptionWhenOptimizationDoesNotExistInList
- shouldThrowExceptionWhenRackAwareAssignmentTagsExceedsMaxListSize
- shouldThrowExceptionWhenTopologyOptimizationDoesNotExist
- shouldThrowExceptionWhenTopologyOptimizationOffAndSet
- shouldThrowExceptionWhenTopologyOptimizationOnAndOff
- shouldThrowIfBuiltInMetricsVersionInvalid
- shouldThrowIfNotSetCorrectRackAwareAssignmentConfig
- shouldThrowOnInvalidClientSupplier
- shouldThrowStreamsExceptionIfKeySerdeConfigFails
- shouldThrowStreamsExceptionIfValueSerdeConfigFails
- shouldUseCacheMaxBytesBufferingConfigWhenOnlyDeprecatedConfigIsSet
- shouldUseCorrectDefaultsWhenNoneSpecified
- shouldUseDefaultStateStoreCacheMaxBytesConfigWhenNoConfigIsSet
- shouldUseNewConfigsWhenPresent
- shouldUseNewDeserializationExceptionHandlerWhenBothConfigsAreSet
- shouldUseNewProductionExceptionHandlerWhenBothConfigsAreSet
- shouldUseOldDeserializationExceptionHandlerWhenOnlyOldConfigIsSet
- shouldUseOldProductionExceptionHandlerWhenOnlyOldConfigIsSet
- shouldUseStateStoreCacheMaxBytesWhenBothOldAndNewConfigsAreSet
- shouldUseStateStoreCacheMaxBytesWhenNewConfigIsSet
- testCaseInsensitiveSecurityProtocol
- testGetConsumerConfigs
- testGetGlobalConsumerConfigs
- testGetGlobalConsumerConfigsWithGlobalConsumerOverriddenPrefix
- testGetGroupInstanceIdConfigs
- testGetMainConsumerConfigsWithMainConsumerOverriddenPrefix
- testGetProducerConfigs
- testGetRestoreConsumerConfigs
- testGetRestoreConsumerConfigsWithRestoreConsumerOverriddenPrefix
- testIllegalMetricsRecordingLevel
- testInvalidProcessingExceptionHandler
- testInvalidSecurityProtocol
- testInvalidSocketReceiveBufferSize
- testInvalidSocketSendBufferSize
- testOsDefaultSocketBufferSizes
org.apache.kafka.streams.TopologyTest:
- kGroupedStreamAnonymousMaterializedCountShouldPreserveTopologyStructure
- kGroupedStreamAnonymousStoreTypedMaterializedCountShouldPreserveTopologyStructure
- kGroupedStreamNamedMaterializedCountShouldPreserveTopologyStructure
- kGroupedStreamZeroArgCountShouldPreserveTopologyStructure
- kGroupedStreamZeroArgCountWithTopologyConfigShouldPreserveTopologyStructure
- kTableAnonymousMaterializedFilterShouldPreserveTopologyStructure
- kTableAnonymousMaterializedMapValuesShouldPreserveTopologyStructure
- kTableNamedMaterializedFilterShouldPreserveTopologyStructure
- kTableNamedMaterializedMapValuesShouldPreserveTopologyStructure
- kTableNonMaterializedFilterShouldPreserveTopologyStructure
- kTableNonMaterializedMapValuesShouldPreserveTopologyStructure
- multipleSourcesShouldHaveDistinctSubtopologies
- multipleSourcesWithProcessorsShouldHaveDistinctSubtopologies
- multipleSourcesWithSinksShouldHaveDistinctSubtopologies
- processorWithMultipleSourcesShouldHaveSingleSubtopology
- processorsWithSameSinkShouldHaveSameSubtopology
- processorsWithSharedStateShouldHaveSameSubtopology
- readOnlyStateStoresShouldHaveTheirOwnSubTopology
- readOnlyStateStoresShouldNotLog
- sessionWindowAnonymousMaterializedCountShouldPreserveTopologyStructure
- sessionWindowAnonymousStoreTypedMaterializedCountShouldPreserveTopologyStructure
- sessionWindowNamedMaterializedCountShouldPreserveTopologyStructure
- sessionWindowZeroArgCountShouldPreserveTopologyStructure
- sessionWindowZeroArgCountWithTopologyConfigShouldPreserveTopologyStructure
- sessionWindowedCogroupedNamedMaterializedCountShouldPreserveTopologyStructure
- sessionWindowedCogroupedZeroArgCountShouldPreserveTopologyStructure
- sessionWindowedCogroupedZeroArgCountWithTopologyConfigShouldPreserveTopologyStructure
- shouldAllowToShareStoreUsingSameStoreBuilder
- shouldDescribeEmptyTopology
- shouldDescribeGlobalStoreTopology
- shouldDescribeMultipleGlobalStoreTopology
- shouldFailIfNodeIsItsOwnParent
- shouldFailIfSinkIsItsOwnParent
- shouldFailIfSinkIsParent
- shouldFailOnUnknownSource
- shouldFailWithUnknownParent
- shouldNotAddNullStateStoreSupplier
- shouldNotAllowNullNameWhenAddingProcessor
- shouldNotAllowNullNameWhenAddingSink
- shouldNotAllowNullNameWhenAddingSourceWithPattern
- shouldNotAllowNullNameWhenAddingSourceWithTopic
- shouldNotAllowNullProcessorNameWhenConnectingProcessorAndStateStores
- shouldNotAllowNullProcessorSupplierWhenAddingProcessor
- shouldNotAllowNullStoreNameWhenConnectingProcessorAndStateStores
- shouldNotAllowNullTopicChooserWhenAddingSink
- shouldNotAllowNullTopicWhenAddingSink
- shouldNotAllowNullTopicsWhenAddingSourceWithPattern
- shouldNotAllowNullTopicsWhenAddingSourceWithTopic
- shouldNotAllowToAddGlobalStoreWithSourceNameEqualsProcessorName
- shouldNotAllowToAddProcessorWithEmptyParents
- shouldNotAllowToAddProcessorWithNullParents
- shouldNotAllowToAddProcessorWithSameName
- shouldNotAllowToAddSinkWithEmptyParents
- shouldNotAllowToAddSinkWithNullParents
- shouldNotAllowToAddSinkWithSameName
- shouldNotAllowToAddSourcesWithSameName
- shouldNotAllowToAddStateStoreToNonExistingProcessor
- shouldNotAllowToAddStateStoreToSink
- shouldNotAllowToAddStateStoreToSource
- shouldNotAllowToAddStoreWithSameNameAndDifferentInstance
- shouldNotAllowToAddTopicTwice
- shouldNotAllowZeroStoreNameWhenConnectingProcessorAndStateStores
- shouldNotAllowZeroTopicsWhenAddingSource
- shouldThrowOnUnassignedStateStoreAccess
- shouldWrapProcessors
- singleSourcePatternShouldHaveSingleSubtopology
- singleSourceShouldHaveSingleSubtopology
- singleSourceWithListOfTopicsShouldHaveSingleSubtopology
- sinkShouldReturnNullTopicWithDynamicRouting
- sinkShouldReturnTopicNameExtractorWithDynamicRouting
- slidingWindowNamedMaterializedCountShouldPreserveTopologyStructure
- slidingWindowZeroArgCountShouldPreserveTopologyStructure
- slidingWindowZeroArgCountWithTopologyConfigShouldPreserveTopologyStructure
- slidingWindowedCogroupedNamedMaterializedCountShouldPreserveTopologyStructure
- slidingWindowedCogroupedZeroArgCountShouldPreserveTopologyStructure
- slidingWindowedCogroupedZeroArgCountWithTopologyConfigShouldPreserveTopologyStructure
- sourceAndProcessorShouldHaveSingleSubtopology
- sourceAndProcessorWithMultipleStatesShouldHaveSingleSubtopology
- sourceAndProcessorWithStateShouldHaveSingleSubtopology
- sourceWithMultipleProcessorsShouldHaveSingleSubtopology
- streamStreamJoinTopologyWithCustomStoresNames
- streamStreamJoinTopologyWithCustomStoresSuppliers
- streamStreamJoinTopologyWithDefaultStoresNames
- streamStreamLeftJoinTopologyWithCustomStoresNames
- streamStreamLeftJoinTopologyWithCustomStoresSuppliers
- streamStreamLeftJoinTopologyWithDefaultStoresNames
- streamStreamOuterJoinTopologyWithCustomStoresNames
- streamStreamOuterJoinTopologyWithCustomStoresSuppliers
- streamStreamOuterJoinTopologyWithDefaultStoresNames
- tableAnonymousMaterializedCountShouldPreserveTopologyStructure
- tableAnonymousStoreTypedMaterializedCountShouldPreserveTopologyStructure
- tableNamedMaterializedCountShouldPreserveTopologyStructure
- tableNamedMaterializedCountWithTopologyConfigShouldPreserveTopologyStructure
- tableZeroArgCountShouldPreserveTopologyStructure
- testNamedTopicMatchesAlreadyProvidedPattern
- testPatternMatchesAlreadyProvidedTopicSource
- timeWindowAnonymousMaterializedCountShouldPreserveTopologyStructure
- timeWindowAnonymousStoreTypeMaterializedCountShouldPreserveTopologyStructure
- timeWindowNamedMaterializedCountShouldPreserveTopologyStructure
- timeWindowZeroArgCountShouldPreserveTopologyStructure
- timeWindowZeroArgCountWithTopologyConfigShouldPreserveTopologyStructure
- timeWindowedCogroupedNamedMaterializedCountShouldPreserveTopologyStructure
- timeWindowedCogroupedZeroArgCountShouldPreserveTopologyStructure
- timeWindowedCogroupedZeroArgCountWithTopologyConfigShouldPreserveTopologyStructure
- topologyWithDynamicRoutingShouldDescribeExtractorClass
- topologyWithStaticTopicNameExtractorShouldRespectEqualHashcodeContract
org.apache.kafka.streams.errors.ExceptionHandlerUtilsTest:
- checkDeadLetterQueueRecords
- doNotBuildDeadLetterQueueRecordsIfNotConfigured
org.apache.kafka.streams.internals.ApiUtilsTest:
- shouldContainsNameAndValueInFailMsgPrefix
- shouldReturnMillisecondsOnValidDuration
- shouldReturnMillisecondsOnValidInstant
- shouldThrowArithmeticExceptionForMaxDuration
- shouldThrowArithmeticExceptionForMaxInstant
- shouldThrowNullPointerExceptionForNullDuration
- shouldThrowNullPointerExceptionForNullInstant
org.apache.kafka.streams.internals.metrics.ClientMetricsTest:
- shouldAddAliveStreamThreadsMetric
- shouldAddApplicationIdMetric
- shouldAddClientStateTelemetryMetric
- shouldAddCommitIdMetric
- shouldAddRecordingLevelMetric
- shouldAddStateMetric
- shouldAddTopologyDescriptionMetric
- shouldAddVersionMetric
- shouldGetFailedStreamThreadsSensor
org.apache.kafka.streams.internals.metrics.StreamsClientMetricsDelegatingReporterTest:
- metricRemoval
- shouldInitMetrics
- shouldRegisterCorrectMetrics
org.apache.kafka.streams.internals.metrics.StreamsThreadMetricsDelegatingReporterTest:
- shouldInitMetrics
- shouldNotRegisterMetricsWithoutThreadIdTag
- shouldRegisterMetrics
- shouldRemoveMetrics
org.apache.kafka.streams.kstream.JoinWindowsTest:
- afterShouldNotModifyGrace
- beforeShouldNotModifyGrace
- endTimeShouldNotBeBeforeStart
- equalsAndHashcodeShouldBeValidForNegativeCases
- equalsAndHashcodeShouldBeValidForPositiveCases
- gracePeriodShouldEnforceBoundaries
- graceShouldNotCalledAfterGraceSet
- noGraceAPIShouldNotSetGracePeriod
- oldAPIShouldSetDefaultGracePeriod
- startTimeShouldNotBeAfterEnd
- timeDifferenceMustNotBeNegative
- untilShouldSetGraceDuration
- validWindows
- withGraceAPIShouldSetGracePeriod
org.apache.kafka.streams.kstream.MaterializedTest:
- shouldAllowValidTopicNamesAsStoreName
- shouldNotAllowInvalidTopicNames
- shouldThrowIllegalArgumentExceptionIfRetentionIsNegative
- shouldThrowIllegalArgumentExceptionIfStoreSupplierAndStoreTypeBothSet
- shouldThrowNullPointerIfKeyValueBytesStoreSupplierIsNull
- shouldThrowNullPointerIfSessionBytesStoreSupplierIsNull
- shouldThrowNullPointerIfStoreTypeIsNull
- shouldThrowNullPointerIfWindowBytesStoreSupplierIsNull
- shouldThrowTopologyExceptionIfStoreNameExceedsMaxAllowedLength
org.apache.kafka.streams.kstream.NamedTest:
- shouldThrowExceptionGivenNullName
- shouldThrowExceptionOnInvalidTopicNames
org.apache.kafka.streams.kstream.PrintedTest:
- shouldCreateProcessorThatPrintsToFile
- shouldCreateProcessorThatPrintsToStdOut
- shouldPrintWithKeyValueMapper
- shouldPrintWithLabel
- shouldThrowNullPointerExceptionIfFilePathIsNull
- shouldThrowNullPointerExceptionIfLabelIsNull
- shouldThrowNullPointerExceptionIfMapperIsNull
- shouldThrowTopologyExceptionIfFilePathDoesntExist
- shouldThrowTopologyExceptionIfFilePathIsEmpty
org.apache.kafka.streams.kstream.RepartitionTopicNamingTest:
- shouldFailWithSameRepartitionTopicName
- shouldFailWithSameRepartitionTopicNameInJoin
- shouldKeepRepartitionNameForGroupByKTable
- shouldKeepRepartitionTopicNameForGroupByKeyNoWindows
- shouldKeepRepartitionTopicNameForGroupByKeySessionWindows
- shouldKeepRepartitionTopicNameForGroupByKeyTimeWindows
- shouldKeepRepartitionTopicNameForGroupByNoWindows
- shouldKeepRepartitionTopicNameForGroupBySessionWindows
- shouldKeepRepartitionTopicNameForGroupByTimeWindows
- shouldKeepRepartitionTopicNameForJoins
- shouldNotFailWithSameRepartitionTopicNameUsingSameKGroupedStream
- shouldNotFailWithSameRepartitionTopicNameUsingSameKGroupedStreamOptimizationsOn
- shouldNotFailWithSameRepartitionTopicNameUsingSameKGroupedTable
- shouldNotFailWithSameRepartitionTopicNameUsingSameSessionWindowStream
- shouldNotFailWithSameRepartitionTopicNameUsingSameTimeWindowStream
- shouldNotReuseRepartitionNodeWithUnnamedRepartitionTopics
- shouldNotReuseRepartitionNodeWithUnnamedRepartitionTopicsKGroupedTable
- shouldPassWithSameRepartitionTopicNameUsingSameKGroupedStreamOptimized
- shouldReuseFirstRepartitionTopicNameWhenOptimizing
org.apache.kafka.streams.kstream.SessionWindowedDeserializerTest:
- shouldIgnoreWindowedInnerClassSerdeConfigIfWindowedInnerDeserializerClassConfigIsSet
- shouldSetSerializerThroughWindowedInnerClassSerdeConfig
- shouldSetSerializerThroughWindowedInnerDeserializerClassConfig
- shouldThrowConfigExceptionWhenInvalidWindowedInnerClassSerdeSupplied
- shouldThrowConfigExceptionWhenInvalidWindowedInnerDeserializerClassSupplied
- shouldThrowErrorIfDeserializersConflictInConstructorAndWindowedInnerClassSerdeConfig
- shouldThrowErrorIfDeserializersConflictInConstructorAndWindowedInnerDeserializerClassConfig
- shouldThrowErrorIfWindowedInnerClassSerdeAndSessionWindowedDeserializerClassAreNotSet
- testSessionWindowedDeserializerConstructor
org.apache.kafka.streams.kstream.SessionWindowedSerializerTest:
- shouldIgnoreWindowedInnerClassSerdeConfigIfWindowedInnerSerializerClassConfigIsSet
- shouldSetSerializerThroughWindowedInnerClassSerdeConfig
- shouldSetSerializerThroughWindowedInnerSerializerClassConfig
- shouldThrowConfigExceptionWhenInvalidWindowedInnerClassSerdeSupplied
- shouldThrowConfigExceptionWhenInvalidWindowedInnerSerializerClassSupplied
- shouldThrowErrorIfSerializersConflictInConstructorAndWindowedInnerClassSerdeConfig
- shouldThrowErrorIfSerializersConflictInConstructorAndWindowedInnerSerializerClassConfig
- shouldThrowErrorIfWindowedInnerClassSerdeAndWindowedInnerSerializerClassAreNotSet
- testSessionWindowedSerializerConstructor
org.apache.kafka.streams.kstream.SessionWindowsTest:
- equalsAndHashcodeShouldBeValidForNegativeCases
- equalsAndHashcodeShouldBeValidForPositiveCases
- gracePeriodShouldEnforceBoundaries
- noGraceAPIShouldNotSetGracePeriod
- sessionGapCanBeZero
- sessionGapCannotBeNegative
- shouldSetWindowGap
- withGraceAPIShouldSetGracePeriod
org.apache.kafka.streams.kstream.SlidingWindowsTest:
- equalsAndHashcodeShouldBeValidForPositiveCases
- equalsAndHashcodeShouldNotBeEqualForDifferentGracePeriod
- equalsAndHashcodeShouldNotBeEqualForDifferentTimeDifference
- gracePeriodMustNotBeNegative
- shouldSetGracePeriod
- shouldSetTimeDifference
- timeDifferenceMustNotBeNegative
org.apache.kafka.streams.kstream.SuppressedTest:
- bufferBuilderShouldBeConsistent
- finalEventsShouldAcceptStrictBuffersAndSetBounds
- intermediateEventsShouldAcceptAnyBufferAndSetBounds
- supportLongChainOfMethods
org.apache.kafka.streams.kstream.TimeWindowedDeserializerTest:
- shouldHaveSameConfigNameForWindowSizeMs
- shouldIgnoreWindowedInnerClassSerdeConfigIfWindowedInnerDeserializerClassConfigIsSet
- shouldSetWindowSizeAndDeserializerThroughWindowSizeMsAndWindowedInnerClassSerdeConfigs
- shouldSetWindowSizeAndDeserializerThroughWindowSizeMsAndWindowedInnerDeserializerClassConfigs
- shouldThrowConfigExceptionWhenInvalidWindowedInnerClassSerdeSupplied
- shouldThrowConfigExceptionWhenInvalidWindowedInnerDeserializerClassSupplied
- shouldThrowErrorIfDeserializerConflictInConstructorAndWindowedInnerClassSerdeConfig
- shouldThrowErrorIfDeserializerConflictInConstructorAndWindowedInnerDeserializerClassConfig
- shouldThrowErrorIfWindowSizeIsNotSetAndWindowedInnerClassSerdeIsSet
- shouldThrowErrorIfWindowSizeIsNotSetAndWindowedInnerDeserializerClassIsSet
- shouldThrowErrorIfWindowSizeSetInConstructorConfigAndConstructor
- shouldThrowErrorIfWindowSizeSetInStreamsConfigAndConstructor
- shouldThrowErrorIfWindowedInnerClassSerdeIsNotSetAndWindowSizeMsInConstructorConfigIsSet
- shouldThrowErrorIfWindowedInnerClassSerdeIsNotSetAndWindowSizeMsInStreamsConfigIsSet
- testTimeWindowedDeserializerConstructor
org.apache.kafka.streams.kstream.TimeWindowedSerializerTest:
- shouldIgnoreWindowedInnerClassSerdeConfigIfWindowedInnerSerializerClassConfigIsSet
- shouldSetSerializerThroughWindowedInnerClassSerdeConfig
- shouldSetSerializerThroughWindowedInnerSerializerClassConfig
- shouldThrowConfigExceptionWhenInvalidWindowedInnerClassSerdeSupplied
- shouldThrowConfigExceptionWhenInvalidWindowedInnerSerializerClassSupplied
- shouldThrowErrorIfSerializerConflictInConstructorAndWindowedInnerClassSerdeConfig
- shouldThrowErrorIfSerializerConflictInConstructorAndWindowedInnerSerializerClassConfig
- shouldThrowErrorIfWindowedInnerClassSerdeAndWindowedInnerSerializerClassAreNotSet
- testTimeWindowedSerializerConstructor
org.apache.kafka.streams.kstream.TimeWindowsTest:
- advanceIntervalMustNotBeLargerThanWindowSize
- advanceIntervalMustNotBeNegative
- advanceIntervalMustNotBeZero
- equalsAndHashcodeShouldBeValidForNegativeCases
- equalsAndHashcodeShouldBeValidForPositiveCases
- gracePeriodShouldEnforceBoundaries
- shouldComputeWindowsForBarelyOverlappingHoppingWindows
- shouldComputeWindowsForHoppingWindows
- shouldComputeWindowsForTumblingWindows
- shouldSetWindowAdvance
- shouldSetWindowSize
- windowSizeMustNotBeNegative
- windowSizeMustNotBeZero
org.apache.kafka.streams.kstream.UnlimitedWindowsTest:
- equalsAndHashcodeShouldBeValidForNegativeCases
- equalsAndHashcodeShouldBeValidForPositiveCases
- shouldExcludeRecordsThatHappenedBeforeWindowStart
- shouldIncludeRecordsThatHappenedAfterWindowStart
- shouldIncludeRecordsThatHappenedOnWindowStart
- shouldSetWindowStartTime
- startTimeMustNotBeNegative
org.apache.kafka.streams.kstream.WindowTest:
- shouldBeEqualIfStartAndEndSame
- shouldNotBeEqualIfDifferentWindowType
- shouldNotBeEqualIfNull
- shouldNotBeEqualIfStartOrEndIsDifferent
- shouldThrowIfEndIsSmallerThanStart
- shouldThrowIfStartIsNegative
org.apache.kafka.streams.kstream.WindowedSerdesTest:
- sessionWindowedDeserializerShouldNotThrowOnCloseIfNotInitializedProperly
- sessionWindowedDeserializerShouldThrowNpeIfNotInitializedProperly
- sessionWindowedSerializerShouldNotThrowOnCloseIfNotInitializedProperly
- sessionWindowedSerializerShouldThrowNpeIfNotInitializedProperly
- sessionWindowedSerializerShouldThrowNpeOnSerializingBaseKeyIfNotInitializedProperly
- shouldWrapForSessionWindowedSerde
- shouldWrapForTimeWindowedSerde
- testSessionWindowedSerdeFrom
- testTimeWindowSerdeFrom
- timeWindowedDeserializerShouldNotThrowOnCloseIfNotInitializedProperly
- timeWindowedDeserializerShouldThrowNpeIfNotInitializedProperly
- timeWindowedSerializerShouldNotThrowOnCloseIfNotInitializedProperly
- timeWindowedSerializerShouldThrowNpeIfNotInitializedProperly
- timeWindowedSerializerShouldThrowNpeOnSerializingBaseKeyIfNotInitializedProperly
org.apache.kafka.streams.kstream.internals.AbstractStreamTest:
- testShouldBeExtensible
- testToInternalValueTransformerWithKeySupplierSuppliesNewTransformers
org.apache.kafka.streams.kstream.internals.ChangedSerdeTest:
- serializerShouldThrowIfGivenAChangeWithBothNewAndOldValuesAsNull
- serializerShouldThrowIfGivenAChangeWithBothNonNullNewAndOldValuesAndIsUpgrade
- shouldDeserializeReservedVersions3Through5
- shouldSerializeAndDeserializeChangeWithNonNullNewAndOldValues
- shouldSerializeAndDeserializeChangeWithNonNullNewValueAndNullOldValue
- shouldSerializeAndDeserializeChangeWithNullNewValueAndNonNullOldValue
- shouldThrowErrorIfEncountersAnUnknownByteValueForOldNewFlag
org.apache.kafka.streams.kstream.internals.CogroupedKStreamImplTest:
- shouldAllowDifferentOutputTypeInCoGroup
- shouldCoGroupStreamsWithDifferentInputTypes
- shouldCogroupAndAggregateSingleKStreams
- shouldCogroupAndAggregateTwoKStreamsWithDistinctKeys
- shouldCogroupAndAggregateTwoKStreamsWithSharedKeys
- shouldInsertRepartitionsTopicForCogroupsUsedTwice
- shouldInsertRepartitionsTopicForUpstreamKeyModification
- shouldInsertRepartitionsTopicForUpstreamKeyModificationWithGroupedRemadeWithOptimization
- shouldInsertRepartitionsTopicForUpstreamKeyModificationWithGroupedReused
- shouldInsertRepartitionsTopicForUpstreamKeyModificationWithGroupedReusedInDifferentCogroups
- shouldInsertRepartitionsTopicForUpstreamKeyModificationWithGroupedReusedInDifferentCogroupsWithOptimization
- shouldInsertRepartitionsTopicForUpstreamKeyModificationWithGroupedReusedInSameCogroups
- shouldInsertRepartitionsTopicForUpstreamKeyModificationWithGroupedReusedInSameCogroupsWithOptimization
- shouldInsertRepartitionsTopicForUpstreamKeyModificationWithGroupedReusedWithOptimization
- shouldNameProcessorsAndStoreBasedOnNamedParameter
- shouldNameRepartitionTopic
- shouldNotHaveNullAggregatorOnCogroup
- shouldNotHaveNullInitializerOnAggregate
- shouldNotHaveNullInitializerOnAggregateWitMaterialized
- shouldNotHaveNullInitializerOnAggregateWitNamed
- shouldNotHaveNullInitializerOnAggregateWitNamedAndMaterialized
- shouldNotHaveNullMaterializedOnAggregate
- shouldNotHaveNullMaterializedOnAggregateWithNames
- shouldNotHaveNullNamedOnAggregate
- shouldNotHaveNullNamedOnAggregateWithMateriazlied
- shouldNotHaveNullWindowOnWindowedBySession
- shouldNotHaveNullWindowOnWindowedBySliding
- shouldNotHaveNullWindowOnWindowedByTime
- shouldThrowNPEInCogroupIfKGroupedStreamIsNull
- testCogroupHandleNullValues
- testCogroupKeyMixedAggregators
- testCogroupWithKTableKTableInnerJoin
- testCogroupWithThreeGroupedStreams
org.apache.kafka.streams.kstream.internals.FullChangeSerdeTest:
- shouldRoundTripChange
- shouldRoundTripNewNull
- shouldRoundTripNull
- shouldRoundTripNullChange
- shouldRoundTripOldNull
org.apache.kafka.streams.kstream.internals.GlobalKTableJoinsTest:
- shouldInnerJoinWithStream
- shouldLeftJoinWithStream
org.apache.kafka.streams.kstream.internals.InternalStreamsBuilderTest:
- ktableShouldHaveNullTimestampExtractorWhenNoneSupplied
- ktableShouldUseProvidedTimestampExtractor
- shouldAddGlobalTablesToEachGroup
- shouldAddRegexTopicToDurationAutoOffsetResetList
- shouldAddRegexTopicToEarliestAutoOffsetResetList
- shouldAddRegexTopicToLatestAutoOffsetResetList
- shouldAddTableToDurationAutoOffsetResetList
- shouldAddTableToEarliestAutoOffsetResetList
- shouldAddTableToLatestAutoOffsetResetList
- shouldAddTableToNoneAutoOffsetResetList
- shouldAddTopicToDurationAutoOffsetResetList
- shouldAddTopicToEarliestAutoOffsetResetList
- shouldAddTopicToLatestAutoOffsetResetList
- shouldAddTopicToNoneAutoOffsetResetList
- shouldBuildGlobalTableWithNonQueryableStoreName
- shouldBuildGlobalTableWithQueryaIbleStoreName
- shouldBuildGlobalTopologyWithAllGlobalTables
- shouldBuildSimpleGlobalTableTopology
- shouldHaveCorrectSourceTopicsForTableFromMergedStream
- shouldHaveNullTimestampExtractorWhenNoneSupplied
- shouldMapStateStoresToCorrectSourceTopics
- shouldMarkAllStreamStreamJoinsAsSelfJoin
- shouldMarkFirstStreamStreamJoinAsSelfJoin3WayJoin
- shouldMarkFirstStreamStreamJoinAsSelfJoinNway
- shouldMarkFirstStreamStreamJoinAsSelfJoinNwaySameSource
- shouldMarkStreamStreamJoinAsSelfJoinMergeTwoStreams
- shouldMarkStreamStreamJoinAsSelfJoinSingleStream
- shouldMarkStreamStreamJoinAsSelfJoinTwoJoinsSameSource
- shouldMarkStreamStreamJoinAsSelfJoinTwoStreams
- shouldMarkStreamStreamJoinAsSelfJoinTwoStreamsWithNoOpFilter
- shouldNotAddRegexTopicsToOffsetResetLists
- shouldNotAddTableToOffsetResetLists
- shouldNotMarkStreamStreamJoinAsSelfJoinMultipleSources
- shouldNotMarkStreamStreamJoinAsSelfJoinOneStreamWithMap
- shouldNotMarkStreamStreamJoinAsSelfJoinTwoStreamsWithFilter
- shouldNotMaterializeSourceKTableIfNotRequired
- shouldNotOptimizeJoinWhenNotInConfig
- shouldNotSetUseVersionedSemanticsWithIntermediateAggregation
- shouldNotSetUseVersionedSemanticsWithIntermediateForeignKeyJoin
- shouldNotSetUseVersionedSemanticsWithIntermediateJoin
- shouldNotSetUseVersionedSemanticsWithMaterializedIntermediateNode
- shouldNotSetUseVersionedSemanticsWithToStreamAndBack
- shouldOptimizeJoinWhenInConfig
- shouldSetUseVersionedSemanticsOnTableFilter
- shouldSetUseVersionedSemanticsOnTableForeignJoin
- shouldSetUseVersionedSemanticsOnTableForeignJoinLeftOnly
- shouldSetUseVersionedSemanticsOnTableForeignJoinRightOnly
- shouldSetUseVersionedSemanticsOnTableForeignSelfJoin
- shouldSetUseVersionedSemanticsOnTableJoin
- shouldSetUseVersionedSemanticsOnTableJoinLeftOnly
- shouldSetUseVersionedSemanticsOnTableJoinRightOnly
- shouldSetUseVersionedSemanticsOnTableRepartitionMap
- shouldSetUseVersionedSemanticsOnTableRepartitionMapWithIntermediateNodes
- shouldSetUseVersionedSemanticsOnTableSelfJoin
- shouldSetUseVersionedSemanticsWithIntermediateAggregationMaterializedAsVersioned
- shouldSetUseVersionedSemanticsWithIntermediateForeignKeyJoinMaterializedAsVersioned
- shouldSetUseVersionedSemanticsWithIntermediateJoinMaterializedAsVersioned
- shouldSetUseVersionedSemanticsWithIntermediateNode
- shouldSetUseVersionedSemanticsWithIntermediateNodeMaterializedAsVersioned
- shouldSetUseVersionedSemanticsWithToStreamAndBackIfMaterializedAsVersioned
- shouldThrowOnVersionedStoreSupplierForGlobalTable
- shouldUseProvidedTimestampExtractor
- testNewName
- testNewStoreName
org.apache.kafka.streams.kstream.internals.KGroupedStreamImplTest:
- sessionGapOfZeroShouldOnlyPutRecordsWithSameTsIntoSameSession
- shouldAcceptNullStoreNameWhenAggregatingSessionWindows
- shouldAggregateAndMaterializeResults
- shouldAggregateSessionWindows
- shouldAggregateSessionWindowsWithInternalStoreName
- shouldAggregateWithDefaultSerdes
- shouldCountAndMaterializeResults
- shouldCountSessionWindows
- shouldCountSessionWindowsWithInternalStoreName
- shouldCountSlidingWindows
- shouldCountSlidingWindowsWithInternalStoreName
- shouldCountWindowed
- shouldCountWindowedWithInternalStoreName
- shouldLogAndMeasureSkipsInAggregate
- shouldLogAndMeasureSkipsInReduce
- shouldNotAcceptInvalidStoreNameWhenAggregatingSessionWindows
- shouldNotAcceptInvalidStoreNameWhenReducingSessionWindows
- shouldNotAcceptNullAggregatorWhenAggregatingSessionWindows
- shouldNotAcceptNullInitializerWhenAggregatingSessionWindows
- shouldNotAcceptNullReducerWhenReducingSessionWindows
- shouldNotAcceptNullSessionMergerWhenAggregatingSessionWindows
- shouldNotAcceptNullSessionWindowsReducingSessionWindows
- shouldNotAcceptNullSessionWindowsWhenAggregatingSessionWindows
- shouldNotAcceptNullStateStoreSupplierWhenReducingSessionWindows
- shouldNotHaveInvalidStoreNameOnAggregate
- shouldNotHaveInvalidStoreNameOnReduce
- shouldNotHaveInvalidStoreNameOnSlidingWindowedAggregate
- shouldNotHaveInvalidStoreNameOnWindowedAggregate
- shouldNotHaveInvalidStoreNameWithSlidingWindowedReduce
- shouldNotHaveInvalidStoreNameWithWindowedReduce
- shouldNotHaveNullAdderOnAggregate
- shouldNotHaveNullAdderOnSlidingWindowedAggregate
- shouldNotHaveNullAdderOnWindowedAggregate
- shouldNotHaveNullAggregatorOnCogroup
- shouldNotHaveNullInitializerOnAggregate
- shouldNotHaveNullInitializerOnSlidingWindowedAggregate
- shouldNotHaveNullInitializerOnWindowedAggregate
- shouldNotHaveNullReducerOnReduce
- shouldNotHaveNullReducerWithSlidingWindowedReduce
- shouldNotHaveNullReducerWithWindowedReduce
- shouldNotHaveNullWindowsOnWindowedAggregate
- shouldNotHaveNullWindowsWithSlidingWindowedReduce
- shouldNotHaveNullWindowsWithWindowedReduce
- shouldReduceAndMaterializeResults
- shouldReduceSessionWindows
- shouldReduceSessionWindowsWithInternalStoreName
- shouldThrowNullPointerOnAggregateWhenMaterializedIsNull
- shouldThrowNullPointerOnCountWhenMaterializedIsNull
- shouldThrowNullPointerOnReduceWhenMaterializedIsNull
org.apache.kafka.streams.kstream.internals.KGroupedTableImplTest:
- shouldAggregateAndMaterializeResults
- shouldCountAndMaterializeResults
- shouldNotAllowInvalidStoreNameOnAggregate
- shouldNotAllowInvalidStoreNameOnReduce
- shouldNotAllowNullAdderOnAggregate
- shouldNotAllowNullAdderOnReduce
- shouldNotAllowNullInitializerOnAggregate
- shouldNotAllowNullSubtractorOnAggregate
- shouldNotAllowNullSubtractorOnReduce
- shouldReduce
- shouldReduceAndMaterializeResults
- shouldReduceWithInternalStoreName
- shouldThrowNullPointOnCountWhenMaterializedIsNull
- shouldThrowNullPointerOnAggregateWhenAdderIsNull
- shouldThrowNullPointerOnAggregateWhenInitializerIsNull
- shouldThrowNullPointerOnAggregateWhenMaterializedIsNull
- shouldThrowNullPointerOnAggregateWhenSubtractorIsNull
- shouldThrowNullPointerOnReduceWhenAdderIsNull
- shouldThrowNullPointerOnReduceWhenMaterializedIsNull
- shouldThrowNullPointerOnReduceWhenSubtractorIsNull
org.apache.kafka.streams.kstream.internals.KStreamFilterTest:
- testFilter
- testFilterNot
- testTypeVariance
org.apache.kafka.streams.kstream.internals.KStreamFlatMapTest:
- testFlatMap
- testKeyValueMapperResultNotNull
org.apache.kafka.streams.kstream.internals.KStreamFlatMapValuesTest:
- testFlatMapValues
- testFlatMapValuesWithKeys
org.apache.kafka.streams.kstream.internals.KStreamForeachTest:
- testForeach
- testTypeVariance
org.apache.kafka.streams.kstream.internals.KStreamGlobalKTableJoinTest:
- shouldClearGlobalTableEntryOnNullValueUpdates
- shouldJoinOnNullKey
- shouldJoinOnlyIfMatchFoundOnStreamUpdates
- shouldNotJoinOnGlobalTableUpdates
- shouldNotJoinOnNullKeyMapperValues
- shouldNotJoinOnNullKeyMapperValuesWithNullKeys
- shouldNotJoinWithEmptyGlobalTableOnStreamUpdates
- shouldNotRequireCopartitioning
org.apache.kafka.streams.kstream.internals.KStreamGlobalKTableLeftJoinTest:
- shouldClearGlobalTableEntryOnNullValueUpdates
- shouldJoinOnNullKey
- shouldJoinOnNullKeyMapperValues
- shouldJoinOnNullKeyMapperValuesWithNullKeys
- shouldJoinRegardlessIfMatchFoundOnStreamUpdates
- shouldNotJoinOnGlobalTableUpdates
- shouldNotJoinWithEmptyGlobalTableOnStreamUpdates
- shouldNotRequireCopartitioning
org.apache.kafka.streams.kstream.internals.KStreamImplTest:
- shouldBindStateWithProcessorSupplier
- shouldMaterializeKTableFromKStream
- shouldMergeMultipleStreams
- shouldMergeTwoStreams
- shouldNotAllowBadProcessSupplierOnProcess
- shouldNotAllowBadProcessSupplierOnProcessValues
- shouldNotAllowBadProcessSupplierOnProcessValuesWithNamed
- shouldNotAllowBadProcessSupplierOnProcessValuesWithNamedAndStores
- shouldNotAllowBadProcessSupplierOnProcessValuesWithStores
- shouldNotAllowBadProcessSupplierOnProcessWithNamed
- shouldNotAllowBadProcessSupplierOnProcessWithNamedAndStores
- shouldNotAllowBadProcessSupplierOnProcessWithStores
- shouldNotAllowNullActionOnForEach
- shouldNotAllowNullActionOnForEachWithName
- shouldNotAllowNullActionOnPeek
- shouldNotAllowNullActionOnPeekWithName
- shouldNotAllowNullGroupedOnGroupBy
- shouldNotAllowNullGroupedOnGroupByKey
- shouldNotAllowNullJoinWindowsOnJoin
- shouldNotAllowNullJoinWindowsOnJoinWithStreamJoined
- shouldNotAllowNullJoinWindowsOnLeftJoin
- shouldNotAllowNullJoinWindowsOnLeftJoinWithStreamJoined
- shouldNotAllowNullJoinWindowsOnOuterJoin
- shouldNotAllowNullJoinWindowsOnOuterJoinWithStreamJoined
- shouldNotAllowNullJoinedOnTableJoin
- shouldNotAllowNullJoinedOnTableLeftJoin
- shouldNotAllowNullKStreamOnMerge
- shouldNotAllowNullKStreamOnMergeWithNamed
- shouldNotAllowNullMapperOnFlatMap
- shouldNotAllowNullMapperOnFlatMapValues
- shouldNotAllowNullMapperOnFlatMapValuesWithKey
- shouldNotAllowNullMapperOnFlatMapValuesWithKeyWithNamed
- shouldNotAllowNullMapperOnFlatMapValuesWithNamed
- shouldNotAllowNullMapperOnFlatMapWithNamed
- shouldNotAllowNullMapperOnJoinWithGlobalTable
- shouldNotAllowNullMapperOnJoinWithGlobalTableWithNamed
- shouldNotAllowNullMapperOnLeftJoinWithGlobalTable
- shouldNotAllowNullMapperOnLeftJoinWithGlobalTableWithNamed
- shouldNotAllowNullMapperOnMap
- shouldNotAllowNullMapperOnMapValues
- shouldNotAllowNullMapperOnMapValuesWithKey
- shouldNotAllowNullMapperOnMapValuesWithKeyWithNamed
- shouldNotAllowNullMapperOnMapValuesWithNamed
- shouldNotAllowNullMapperOnMapWithNamed
- shouldNotAllowNullMapperOnSelectKey
- shouldNotAllowNullMapperOnSelectKeyWithNamed
- shouldNotAllowNullMaterializedOnToTable
- shouldNotAllowNullMaterializedOnToTableWithNamed
- shouldNotAllowNullNameOnFlatMapValues
- shouldNotAllowNullNameOnFlatMapValuesWithKey
- shouldNotAllowNullNamedOnFilter
- shouldNotAllowNullNamedOnFilterNot
- shouldNotAllowNullNamedOnFlatMap
- shouldNotAllowNullNamedOnForEach
- shouldNotAllowNullNamedOnMap
- shouldNotAllowNullNamedOnMapValues
- shouldNotAllowNullNamedOnMapValuesWithKey
- shouldNotAllowNullNamedOnMerge
- shouldNotAllowNullNamedOnPeek
- shouldNotAllowNullNamedOnProcess
- shouldNotAllowNullNamedOnProcessValues
- shouldNotAllowNullNamedOnProcessValuesWithStores
- shouldNotAllowNullNamedOnProcessWithStores
- shouldNotAllowNullNamedOnSelectKey
- shouldNotAllowNullNamedOnToTable
- shouldNotAllowNullNamedOnToTableWithMaterialized
- shouldNotAllowNullOtherStreamOnJoin
- shouldNotAllowNullOtherStreamOnJoinWithStreamJoined
- shouldNotAllowNullOtherStreamOnLeftJoin
- shouldNotAllowNullOtherStreamOnLeftJoinWithStreamJoined
- shouldNotAllowNullOtherStreamOnOuterJoin
- shouldNotAllowNullOtherStreamOnOuterJoinWithStreamJoined
- shouldNotAllowNullPredicateOnFilter
- shouldNotAllowNullPredicateOnFilterNot
- shouldNotAllowNullPredicateOnFilterNotWithName
- shouldNotAllowNullPredicateOnFilterWithNamed
- shouldNotAllowNullPrintedOnPrint
- shouldNotAllowNullProcessSupplierOnProcess
- shouldNotAllowNullProcessSupplierOnProcessValuesWithNamed
- shouldNotAllowNullProcessSupplierOnProcessValuesWithNamedAndStores
- shouldNotAllowNullProcessSupplierOnProcessValuesWithStores
- shouldNotAllowNullProcessSupplierOnProcessWithNamed
- shouldNotAllowNullProcessSupplierOnProcessWithNamedAndStores
- shouldNotAllowNullProcessSupplierOnProcessWithStores
- shouldNotAllowNullProcessValuesSupplierOnProcess
- shouldNotAllowNullProducedOnToWithTopicChooser
- shouldNotAllowNullProducedOnToWithTopicName
- shouldNotAllowNullRepartitionedOnRepartition
- shouldNotAllowNullSelectorOnGroupBy
- shouldNotAllowNullSelectorOnGroupByWithGrouped
- shouldNotAllowNullStoreNameOnProcess
- shouldNotAllowNullStoreNameOnProcessValues
- shouldNotAllowNullStoreNameOnProcessValuesWithNamed
- shouldNotAllowNullStoreNameOnProcessWithNamed
- shouldNotAllowNullStoreNamesOnProcess
- shouldNotAllowNullStoreNamesOnProcessValues
- shouldNotAllowNullStoreNamesOnProcessValuesWithNamed
- shouldNotAllowNullStoreNamesOnProcessWithNamed
- shouldNotAllowNullStreamJoinedOnJoin
- shouldNotAllowNullStreamJoinedOnLeftJoin
- shouldNotAllowNullStreamJoinedOnOuterJoin
- shouldNotAllowNullTableOnJoinWithGlobalTable
- shouldNotAllowNullTableOnJoinWithGlobalTableWithNamed
- shouldNotAllowNullTableOnLeftJoinWithGlobalTable
- shouldNotAllowNullTableOnLeftJoinWithGlobalTableWithNamed
- shouldNotAllowNullTableOnTableJoin
- shouldNotAllowNullTableOnTableJoinWithJoiner
- shouldNotAllowNullTableOnTableLeftJoin
- shouldNotAllowNullTableOnTableLeftJoinWithJoined
- shouldNotAllowNullTopicChooserOnTo
- shouldNotAllowNullTopicChooserOnToWithProduced
- shouldNotAllowNullTopicOnTo
- shouldNotAllowNullTopicOnToWithProduced
- shouldNotAllowNullValueJoinerOnJoin
- shouldNotAllowNullValueJoinerOnJoinWithGlobalTable
- shouldNotAllowNullValueJoinerOnJoinWithGlobalTableWithNamed
- shouldNotAllowNullValueJoinerOnJoinWithStreamJoined
- shouldNotAllowNullValueJoinerOnLeftJoin
- shouldNotAllowNullValueJoinerOnLeftJoinWithGlobalTable
- shouldNotAllowNullValueJoinerOnLeftJoinWithGlobalTableWithNamed
- shouldNotAllowNullValueJoinerOnLeftJoinWithStreamJoined
- shouldNotAllowNullValueJoinerOnOuterJoin
- shouldNotAllowNullValueJoinerOnOuterJoinWithStreamJoined
- shouldNotAllowNullValueJoinerOnTableJoin
- shouldNotAllowNullValueJoinerOnTableJoinWithJoiner
- shouldNotAllowNullValueJoinerOnTableLeftJoin
- shouldNotAllowNullValueJoinerOnTableLeftJoinWithJoined
- shouldNotAllowNullValueJoinerWithKeyOnJoin
- shouldNotAllowNullValueJoinerWithKeyOnJoinWithGlobalTable
- shouldNotAllowNullValueJoinerWithKeyOnJoinWithGlobalTableWithNamed
- shouldNotAllowNullValueJoinerWithKeyOnJoinWithStreamJoined
- shouldNotAllowNullValueJoinerWithKeyOnLeftJoin
- shouldNotAllowNullValueJoinerWithKeyOnLeftJoinWithGlobalTable
- shouldNotAllowNullValueJoinerWithKeyOnLeftJoinWithGlobalTableWithNamed
- shouldNotAllowNullValueJoinerWithKeyOnLeftJoinWithStreamJoined
- shouldNotAllowNullValueJoinerWithKeyOnOuterJoin
- shouldNotAllowNullValueJoinerWithKeyOnOuterJoinWithStreamJoined
- shouldNotAllowNullValueJoinerWithKeyOnTableJoin
- shouldNotAllowNullValueJoinerWithKeyOnTableJoinWithJoiner
- shouldNotAllowNullValueJoinerWithKeyOnTableLeftJoin
- shouldNotAllowNullValueJoinerWithKeyOnTableLeftJoinWithJoined
- shouldNotMaterializedKTableFromKStream
- shouldPreserveSerdesForOperators
- shouldProcessFromSourceThatMatchPattern
- shouldProcessFromSourcesThatMatchMultiplePattern
- shouldProcessValues
- shouldProcessWithProcessorAndState
- shouldPropagateRepartitionFlagAfterGlobalKTableJoin
- shouldSendDataThroughRepartitionTopicUsingRepartitioned
- shouldSendDataToDynamicTopics
- shouldSendDataToTopicUsingProduced
- shouldSupportForeignKeyTableTableJoinWithKTableFromKStream
- shouldSupportGroupByCountWithKStreamToKTable
- shouldSupportKeyChangeKTableFromKStream
- shouldSupportStreamTableJoinWithKStreamToKTable
- shouldSupportTableTableJoinWithKStreamToKTable
- shouldSupportTriggerMaterializedWithKTableFromKStream
- shouldUseRecordMetadataTimestampExtractorWhenInternalRepartitioningTopicCreated
- shouldUseRecordMetadataTimestampExtractorWhenInternalRepartitioningTopicCreatedWithRetention
- shouldUseRecordMetadataTimestampExtractorWithRepartition
org.apache.kafka.streams.kstream.internals.KStreamImplValueJoinerWithKeyTest:
- shouldIncludeKeyInStreamGlobalTableJoinResults
- shouldIncludeKeyInStreamGlobalTableLeftJoinResults
- shouldIncludeKeyInStreamLeftJoinResults
- shouldIncludeKeyInStreamOuterJoinResults
- shouldIncludeKeyInStreamSteamJoinResults
- shouldIncludeKeyInStreamTableJoinResults
- shouldIncludeKeyInStreamTableLeftJoinResults
org.apache.kafka.streams.kstream.internals.KStreamKStreamJoinTest:
- shouldBuildJoinWithCustomStoresAndCorrectWindowSettings
- shouldCreateRepartitionTopicsWithUserProvidedName
- shouldDisableLoggingOnStreamJoined
- shouldEnableLoggingWithCustomConfigOnStreamJoined
- shouldExceptionWhenJoinStoresDoNotHaveUniqueNames
- shouldJoinWithCustomStoreSuppliers
- shouldJoinWithDslStoreSuppliersFromStreamsConfig
- shouldJoinWithDslStoreSuppliersIfNoStoreSupplied
- shouldJoinWithNonTimestampedStore
- shouldLogAndMeterOnSkippedRecordsWithNullValueWithBuiltInMetricsVersionLatest
- shouldReuseRepartitionTopicWithGeneratedName
- shouldThrottleEmitNonJoinedOuterRecordsEvenWhenClockDrift
- shouldThrowExceptionOtherStoreSupplierRetentionDoNotMatchWindowsSizeAndGrace
- shouldThrowExceptionOtherStoreSupplierWindowSizeDoesNotMatchJoinWindowsWindowSize
- shouldThrowExceptionThisStoreSupplierRetentionDoNotMatchWindowsSizeAndGrace
- shouldThrowExceptionThisStoreSupplierWindowSizeDoesNotMatchJoinWindowsWindowSize
- shouldThrowExceptionWhenOtherJoinStoreSetsRetainDuplicatesFalse
- shouldThrowExceptionWhenThisJoinStoreSetsRetainDuplicatesFalse
- testAsymmetricWindowingAfter
- testAsymmetricWindowingBefore
- testJoin
- testOuterJoin
- testWindowing
org.apache.kafka.streams.kstream.internals.KStreamKStreamLeftJoinTest:
- shouldNotEmitLeftJoinResultForAsymmetricWindow
- testGracePeriod
- testLeftExpiredNonJoinedRecordsAreEmittedByTheLeftProcessor
- testLeftExpiredNonJoinedRecordsAreEmittedByTheRightProcessor
- testLeftJoinDuplicates
- testLeftJoinDuplicatesWithSpuriousResultFixDisabledOldApi
- testLeftJoinWithDefaultSuppliers
- testLeftJoinWithInMemoryCustomSuppliers
- testLeftJoinWithSpuriousResultFixDisabledOldApi
- testLeftJoinedRecordsWithZeroAfterAreEmitted
- testOrdering
- testRightNonJoinedRecordsAreNeverEmittedByTheLeftProcessor
- testRightNonJoinedRecordsAreNeverEmittedByTheRightProcessor
- testWindowing
org.apache.kafka.streams.kstream.internals.KStreamKStreamOuterJoinTest:
- testEmitAllNonJoinedResultsForAsymmetricWindow
- testGracePeriod
- testLeftExpiredNonJoinedRecordsAreEmittedByTheLeftProcessor
- testLeftExpiredNonJoinedRecordsAreEmittedByTheRightProcessor
- testOrdering
- testOuterJoinDuplicates
- testOuterJoinDuplicatesWithFixDisabledOldApi
- testOuterJoinWithDefaultSuppliers
- testOuterJoinWithInMemoryCustomSuppliers
- testRightExpiredNonJoinedRecordsAreEmittedByTheLeftProcessor
- testRightExpiredNonJoinedRecordsAreEmittedByTheRightProcessor
- testShouldForwardCurrentHeaders
- testShouldJoinWithNonTimestampedStore
- testShouldNotEmitLeftJoinResultForAsymmetricAfterWindow
- testShouldNotEmitLeftJoinResultForAsymmetricBeforeWindow
- testWindowing
org.apache.kafka.streams.kstream.internals.KStreamKStreamSelfJoinTest:
- shouldMatchInnerJoinWithSelfJoinDifferentBeforeAfterWindows
- shouldMatchInnerJoinWithSelfJoinOutOfOrderMessages
- shouldMatchInnerJoinWithSelfJoinWithSingleStream
- shouldMatchInnerJoinWithSelfJoinWithTwoStreams
org.apache.kafka.streams.kstream.internals.KStreamKTableJoinTest:
- shouldClearTableEntryOnNullValueUpdates
- shouldCreateRepartitionTopicsWithUserProvidedName
- shouldDelayJoinByGracePeriod
- shouldFailIfGracePeriodIsLongerThanHistoryRetention
- shouldFailIfGracePeriodIsLongerThanHistoryRetentionAndInheritedStore
- shouldFailIfTableIsNotVersioned
- shouldFailIfTableIsNotVersionedButMaterializationIsInherited
- shouldHandleLateJoinsWithGracePeriod
- shouldJoinOnlyIfMatchFoundOnStreamUpdates
- shouldLogAndMeterWhenSkippingNullLeftKey
- shouldLogAndMeterWhenSkippingNullLeftValue
- shouldNotFailIfTableIsVersionedButMaterializationIsInherited
- shouldNotJoinOnTableUpdates
- shouldNotJoinWithEmptyTableOnStreamUpdates
- shouldRequireCopartitionedStreams
- shouldReuseRepartitionTopicWithGeneratedName
org.apache.kafka.streams.kstream.internals.KStreamKTableLeftJoinTest:
- shouldClearTableEntryOnNullValueUpdates
- shouldJoinRegardlessIfMatchFoundOnStreamUpdates
- shouldJoinWithEmptyTableOnStreamUpdates
- shouldLogAndMeterWhenSkippingNullLeftValue
- shouldNotDropLeftNullKey
- shouldNotJoinOnTableUpdates
- shouldRequireCopartitionedStreams
org.apache.kafka.streams.kstream.internals.KStreamMapTest:
- testKeyValueMapperResultNotNull
- testMap
- testTypeVariance
org.apache.kafka.streams.kstream.internals.KStreamMapValuesTest:
- testFlatMapValues
- testMapValuesWithKeys
org.apache.kafka.streams.kstream.internals.KStreamPeekTest:
- shouldNotAllowNullAction
- shouldObserveStreamElements
org.apache.kafka.streams.kstream.internals.KStreamPrintTest:
- testPrintStreamWithProvidedKeyValueMapper
org.apache.kafka.streams.kstream.internals.KStreamProcessorApiTest:
- shouldGetStateStoreWithConnectedStoreProvider
- shouldGetStateStoreWithStreamBuilder
org.apache.kafka.streams.kstream.internals.KStreamRepartitionTest:
- shouldInvokePartitionerWhenSet
- shouldThrowAnExceptionWhenNumberOfPartitionsOfRepartitionOperationsDoNotMatchWhenJoining
org.apache.kafka.streams.kstream.internals.KStreamSelectKeyTest:
- testSelectKey
- testTypeVariance
org.apache.kafka.streams.kstream.internals.KStreamSessionWindowAggregateProcessorTest:
- shouldCreateSingleSessionWhenWithinGap
- shouldGetAggregatedValuesFromValueGetter
- shouldHandleMultipleSessionsAndMerging
- shouldHaveMultipleSessionsForSameIdWhenTimestampApartBySessionGap
- shouldImmediatelyForwardNewSessionWhenNonCachedStore
- shouldImmediatelyForwardRemovedSessionsWhenMerging
- shouldLogAndMeterWhenSkippingLateRecordWithNonzeroGrace
- shouldLogAndMeterWhenSkippingLateRecordWithZeroGrace
- shouldLogAndMeterWhenSkippingNullKeyWithBuiltInMetrics
- shouldMergeSessions
- shouldRemoveMergedSessionsFromStateStore
- shouldUpdateSessionIfTheSameTime
org.apache.kafka.streams.kstream.internals.KStreamSlidingWindowAggregateTest:
- shouldLogAndMeterWhenSkippingExpiredWindowByGrace
- shouldLogAndMeterWhenSkippingNullKey
- testAggregateLargeInput
- testAggregateRandomInput
- testAggregateSmallInput
- testEarlyNoGracePeriodLargeInput
- testEarlyNoGracePeriodSmallInput
- testEarlyRecordsLargeInput
- testEarlyRecordsRepeatedInput
- testEarlyRecordsSmallInput
- testJoin
- testNoGracePeriodLargeInput
- testNoGracePeriodSmallInput
- testReduceSmallInput
org.apache.kafka.streams.kstream.internals.KStreamSplitTest:
- testBranchingWithNoTerminalOperation
- testKStreamSplit
- testResultingMap
- testTypeVariance
org.apache.kafka.streams.kstream.internals.KStreamWindowAggregateTest:
- shouldEmitFromLastEmitTime
- shouldEmitWithInterval0
- shouldEmitWithLargeInterval
- shouldLogAndMeterWhenSkippingExpiredWindow
- shouldLogAndMeterWhenSkippingExpiredWindowByGrace
- shouldLogAndMeterWhenSkippingNullKey
- shouldNotEmitFinalIfNotProgressEnough
- showThrowIfEmitFinalUsedWithUnlimitedWindow
- testAggBasic
- testJoin
org.apache.kafka.streams.kstream.internals.KTableAggregateTest:
- testAggBasic
- testAggOfVersionedStore
- testAggRepartition
- testCount
- testCountOfVersionedStore
- testCountWithInternalStore
- testNoEqualsAndNotSameObject
- testNoEqualsAndSameObject
- testRemoveOldBeforeAddNew
- testShouldNotSendTransientStateIfNotUpgrading
- testShouldSendTransientStateWhenUpgrading
org.apache.kafka.streams.kstream.internals.KTableFilterTest:
- shouldEnableSendOldValuesWhenMaterializedAlreadyAndForcedToMaterialize
- shouldEnableSendOldValuesWhenNotMaterializedAlreadyButForcedToMaterialize
- shouldGetValuesOnMaterialization
- shouldNotEnableSendingOldValuesIfNotAlreadyMaterializedAndNotForcedToMaterialize
- shouldNotSendOldValuesOnMaterialization
- shouldNotSendOldValuesWithoutMaterialization
- shouldNotSkipNullIfVersionedUpstream
- shouldPassThroughOnMaterialization
- shouldPassThroughWithoutMaterialization
- shouldSendOldValuesWhenEnabledOnUpStreamMaterialization
- shouldSkipNullIfVersionedDownstream
- shouldSkipNullToRepartitionOnMaterialization
- shouldSkipNullToRepartitionWithoutMaterialization
- testTypeVariance
org.apache.kafka.streams.kstream.internals.KTableImplTest:
- shouldAllowNullStoreInJoin
- shouldCreateSourceAndSinkNodesForRepartitioningTopic
- shouldEnableSendingOldValuesIfNotMaterializedAlreadyButForcedToMaterialize
- shouldNotAllowNullJoinerJoin
- shouldNotAllowNullJoinerOnLeftJoin
- shouldNotAllowNullJoinerOnOuterJoin
- shouldNotAllowNullMapperOnMapValueWithKey
- shouldNotAllowNullMapperOnMapValues
- shouldNotAllowNullOtherTableOnJoin
- shouldNotAllowNullOtherTableOnLeftJoin
- shouldNotAllowNullOtherTableOnOuterJoin
- shouldNotAllowNullPredicateOnFilter
- shouldNotAllowNullPredicateOnFilterNot
- shouldNotAllowNullSelectorOnGroupBy
- shouldNotAllowNullSelectorOnToStream
- shouldNotEnableSendingOldValuesIfNotMaterializedAlreadyAndNotForcedToMaterialize
- shouldPreserveSerdesForOperators
- shouldThrowNullPointerOnFilterNotWhenMaterializedIsNull
- shouldThrowNullPointerOnFilterWhenMaterializedIsNull
- shouldThrowNullPointerOnJoinWhenMaterializedIsNull
- shouldThrowNullPointerOnLeftJoinWhenMaterializedIsNull
- shouldThrowNullPointerOnOuterJoinWhenMaterializedIsNull
- shouldThrowNullPointerOnTransformValuesWithKeyWhenMaterializedIsNull
- shouldThrowNullPointerOnTransformValuesWithKeyWhenStoreNamesNull
- shouldThrowNullPointerOnTransformValuesWithKeyWhenTransformerSupplierIsNull
- testKTable
- testMaterializedKTable
- testStateStore
- testStateStoreLazyEval
org.apache.kafka.streams.kstream.internals.KTableKTableForeignKeyJoinScenarioTest:
- shouldUseExpectedTopicsWithSerde
- shouldWorkWithCompositeKeyAndBiFunctionExtractor
- shouldWorkWithCompositeKeyAndProducerIdInValue
- shouldWorkWithDefaultAndConsumedSerdes
- shouldWorkWithDefaultAndEquiJoinResultSerdes
- shouldWorkWithDefaultAndJoinResultSerdes
- shouldWorkWithDefaultAndProducedSerdes
- shouldWorkWithDefaultSerdes
org.apache.kafka.streams.kstream.internals.KTableKTableInnerJoinTest:
- shouldLogAndMeterSkippedRecordsDueToNullLeftKey
- testJoin
- testNotSendingOldValues
- testQueryableJoin
- testQueryableNotSendingOldValues
- testSendingOldValues
org.apache.kafka.streams.kstream.internals.KTableKTableLeftJoinTest:
- shouldLogAndMeterSkippedRecordsDueToNullLeftKey
- shouldNotThrowIllegalStateExceptionWhenMultiCacheEvictions
- testJoin
- testNotSendingOldValue
- testSendingOldValue
org.apache.kafka.streams.kstream.internals.KTableKTableOuterJoinTest:
- shouldLogAndMeterSkippedRecordsDueToNullLeftKey
- testJoin
- testNotSendingOldValue
- testSendingOldValue
org.apache.kafka.streams.kstream.internals.KTableKTableRightJoinTest:
- shouldLogAndMeterSkippedRecordsDueToNullLeftKeyWithBuiltInMetricsVersionLatest
org.apache.kafka.streams.kstream.internals.KTableMapKeysTest:
- testMapKeysConvertingToStream
org.apache.kafka.streams.kstream.internals.KTableMapValuesTest:
- shouldEnableSendingOldValuesOnParentIfMapValuesNotMaterialized
- shouldNotEnableSendingOldValuesOnParentIfMapValuesMaterialized
- testKTable
- testNotSendingOldValue
- testQueryableKTable
- testQueryableValueGetter
org.apache.kafka.streams.kstream.internals.KTableReduceTest:
- shouldAddAndSubtract
org.apache.kafka.streams.kstream.internals.KTableSourceTest:
- kTableShouldLogAndMeterOnSkippedRecords
- kTableShouldLogOnOutOfOrder
- testKTable
- testNotSendingOldValue
- testSendingOldValue
- testValueGetter
org.apache.kafka.streams.kstream.internals.KTableTransformValuesTest:
- shouldCalculateCorrectOldValuesIfMaterializedEvenIfStateful
- shouldCalculateCorrectOldValuesIfNotStatefulEvenIfNotMaterialized
- shouldCalculateCorrectOldValuesIfNotStatefulEvenNotMaterializedNoQueryableName
- shouldCloseParentGetterClose
- shouldCloseTransformerOnGetterClose
- shouldCloseTransformerOnProcessorClose
- shouldGetFromStateStoreIfMaterialized
- shouldGetQueryableStoreNameIfMaterialized
- shouldGetStoreNamesFromParentIfNotMaterialized
- shouldInitializeTransformerWithForwardDisabledProcessorContext
- shouldNotSendOldValuesByDefault
- shouldNotSetSendOldValuesOnParentIfMaterialized
- shouldSendOldValuesIfConfigured
- shouldSetSendOldValuesOnParentIfNotMaterialized
- shouldThrowOnGetIfSupplierReturnsNull
- shouldThrowOnViewGetIfSupplierReturnsNull
- shouldTransformOnGetIfNotMaterialized
- shouldTransformValuesWithKey
- shouldTransformValuesWithKeyAndMaterialize
org.apache.kafka.streams.kstream.internals.MaterializedInternalTest:
- shouldGenerateStoreNameWithPrefixIfProvidedNameIsNull
- shouldPreferStoreSupplierWhenProvidedWithStoreTypeViaTopologyConfig
- shouldReturnEmptyWhenOriginalsAndOverridesDontHaveSuppliersSpecified
- shouldUseProvidedStoreNameWhenSet
- shouldUseStoreNameOfSupplierWhenProvided
- shouldUseStoreTypeWhenProvidedViaTopologyConfig
org.apache.kafka.streams.kstream.internals.NamedInternalTest:
- shouldGenerateWithPrefixGivenEmptyName
- shouldNotGenerateWithPrefixGivenValidName
- shouldSuffixNameOrReturnProviderValue
org.apache.kafka.streams.kstream.internals.SessionCacheFlushListenerTest:
- shouldForwardKeyNewValueOldValueAndTimestamp
org.apache.kafka.streams.kstream.internals.SessionWindowTest:
- cannotCompareSessionWindowWithDifferentWindowType
- shouldNotOverlapIfOtherWindowIsBeforeThisWindow
- shouldNotOverlapIsOtherWindowIsAfterThisWindow
- shouldOverlapIfOtherWindowContainsThisWindow
- shouldOverlapIfOtherWindowEndIsWithinThisWindow
- shouldOverlapIfOtherWindowIsWithinThisWindow
- shouldOverlapIfOtherWindowStartIsWithinThisWindow
org.apache.kafka.streams.kstream.internals.SessionWindowedCogroupedKStreamImplTest:
- namedParamShouldSetName
- sessionWindowAggregate2Test
- sessionWindowAggregateTest
- sessionWindowAggregateTest2StreamsTest
- sessionWindowMixAggregatorsManyWindowsTest
- sessionWindowMixAggregatorsTest
- shouldNotHaveNullInitializer2OnAggregate
- shouldNotHaveNullInitializer3OnAggregate
- shouldNotHaveNullInitializerOnAggregate
- shouldNotHaveNullMaterialized2OnAggregate
- shouldNotHaveNullMaterializedOnAggregate
- shouldNotHaveNullNamed2OnAggregate
- shouldNotHaveNullNamedOnAggregate
- shouldNotHaveNullSessionMerger2OnAggregate
- shouldNotHaveNullSessionMerger3OnAggregate
- shouldNotHaveNullSessionMergerOnAggregate
org.apache.kafka.streams.kstream.internals.SessionWindowedKStreamImplTest:
- shouldAggregateSessionWindowed
- shouldCountSessionWindowedWithCachingDisabled
- shouldCountSessionWindowedWithCachingEnabled
- shouldMaterializeAggregated
- shouldMaterializeCount
- shouldMaterializeReduced
- shouldNotEnableCachingWithEmitFinal
- shouldReduceWindowed
- shouldThrowNullPointerOnAggregateIfAggregatorIsNull
- shouldThrowNullPointerOnAggregateIfInitializerIsNull
- shouldThrowNullPointerOnAggregateIfMergerIsNull
- shouldThrowNullPointerOnCountIfMaterializedIsNull
- shouldThrowNullPointerOnMaterializedAggregateIfAggregatorIsNull
- shouldThrowNullPointerOnMaterializedAggregateIfInitializerIsNull
- shouldThrowNullPointerOnMaterializedAggregateIfMaterializedIsNull
- shouldThrowNullPointerOnMaterializedAggregateIfMergerIsNull
- shouldThrowNullPointerOnMaterializedReduceIfMaterializedIsNull
- shouldThrowNullPointerOnMaterializedReduceIfNamedIsNull
- shouldThrowNullPointerOnMaterializedReduceIfReducerIsNull
- shouldThrowNullPointerOnReduceIfReducerIsNull
org.apache.kafka.streams.kstream.internals.SlidingWindowedCogroupedKStreamImplTest:
- namedParamShouldSetName
- shouldNotHaveNullInitializerOnAggregate
- shouldNotHaveNullInitializerThreeOptionOnAggregate
- shouldNotHaveNullInitializerTwoOptionMaterializedOnAggregate
- shouldNotHaveNullInitializerTwoOptionNamedOnAggregate
- shouldNotHaveNullMaterializedOnAggregate
- shouldNotHaveNullMaterializedOnTwoOptionAggregate
- shouldNotHaveNullNamedOnAggregate
- shouldNotHaveNullNamedTwoOptionOnAggregate
- slidingWindowAggregateOverlappingWindowsTest
- slidingWindowAggregateStreamsTest
org.apache.kafka.streams.kstream.internals.SlidingWindowedKStreamImplTest:
- shouldAggregateSlidingWindows
- shouldCountSlidingWindows
- shouldDropWindowsOutsideOfRetention
- shouldMaterializeAggregated
- shouldMaterializeCount
- shouldMaterializeReduced
- shouldReduceSlidingWindows
- shouldThrowIllegalArgumentWhenRetentionIsTooSmall
- shouldThrowNullPointerOnAggregateIfAggregatorIsNull
- shouldThrowNullPointerOnAggregateIfInitializerIsNull
- shouldThrowNullPointerOnCountIfMaterializedIsNull
- shouldThrowNullPointerOnMaterializedAggregateIfAggregatorIsNull
- shouldThrowNullPointerOnMaterializedAggregateIfInitializerIsNull
- shouldThrowNullPointerOnMaterializedAggregateIfMaterializedIsNull
- shouldThrowNullPointerOnMaterializedReduceIfMaterializedIsNull
- shouldThrowNullPointerOnMaterializedReduceIfNamedIsNull
- shouldThrowNullPointerOnMaterializedReduceIfReducerIsNull
- shouldThrowNullPointerOnReduceIfReducerIsNull
org.apache.kafka.streams.kstream.internals.SuppressScenarioTest:
- shouldImmediatelyEmitEventsWithZeroEmitAfter
- shouldSupportFinalResultsForSessionWindows
- shouldSupportFinalResultsForSlidingWindows
- shouldSupportFinalResultsForTimeWindows
- shouldSupportFinalResultsForTimeWindowsWithLargeJump
- shouldSuppressIntermediateEventsWithBytesLimit
- shouldSuppressIntermediateEventsWithRecordLimit
- shouldSuppressIntermediateEventsWithTimeLimit
- shouldWorkBeforeGroupBy
- shouldWorkBeforeJoinLeft
- shouldWorkBeforeJoinRight
- shouldWorkWithCogroupedSessionWindows
- shouldWorkWithCogroupedSlidingWindows
- shouldWorkWithCogroupedTimeWindows
org.apache.kafka.streams.kstream.internals.SuppressTopologyTest:
- shouldApplyNameToFinalSuppressionNode
- shouldApplyNameToSuppressionNode
- shouldThrowOnSuppressForMaterializedVersionedTable
- shouldThrowOnSuppressForNonMaterializedVersionedTable
- shouldUseNumberingForAnonymousFinalSuppressionNode
- shouldUseNumberingForAnonymousSuppressionNode
org.apache.kafka.streams.kstream.internals.TimeWindowTest:
- cannotCompareTimeWindowWithDifferentWindowType
- endMustBeLargerThanStart
- shouldNotOverlapIfOtherWindowIsBeforeThisWindow
- shouldNotOverlapIsOtherWindowIsAfterThisWindow
- shouldOverlapIfOtherWindowContainsThisWindow
- shouldOverlapIfOtherWindowEndIsWithinThisWindow
- shouldOverlapIfOtherWindowIsWithinThisWindow
- shouldOverlapIfOtherWindowStartIsWithinThisWindow
- shouldReturnMatchedWindowsOrderedByTimestamp
org.apache.kafka.streams.kstream.internals.TimeWindowedCogroupedKStreamImplTest:
- namedParamShouldSetName
- shouldNotHaveNullInitializerOnAggregate
- shouldNotHaveNullInitializerThreeOptionOnAggregate
- shouldNotHaveNullInitializerTwoOptionMaterializedOnAggregate
- shouldNotHaveNullInitializerTwoOptionNamedOnAggregate
- shouldNotHaveNullMaterializedOnAggregate
- shouldNotHaveNullMaterializedOnTwoOptionAggregate
- shouldNotHaveNullNamedOnAggregate
- shouldNotHaveNullNamedTwoOptionOnAggregate
- timeWindowAggregateManyWindowsTest
- timeWindowAggregateOverlappingWindowsTest
- timeWindowAggregateTestStreamsTest
- timeWindowMixAggregatorsManyWindowsTest
- timeWindowMixAggregatorsTest
org.apache.kafka.streams.kstream.internals.TimeWindowedKStreamImplTest:
- shouldAggregateWindowed
- shouldCountWindowed
- shouldMaterializeAggregated
- shouldMaterializeCount
- shouldMaterializeReduced
- shouldReduceWindowed
- shouldThrowNullPointerOnAggregateIfAggregatorIsNull
- shouldThrowNullPointerOnAggregateIfInitializerIsNull
- shouldThrowNullPointerOnCountIfMaterializedIsNull
- shouldThrowNullPointerOnMaterializedAggregateIfAggregatorIsNull
- shouldThrowNullPointerOnMaterializedAggregateIfInitializerIsNull
- shouldThrowNullPointerOnMaterializedAggregateIfMaterializedIsNull
- shouldThrowNullPointerOnMaterializedReduceIfMaterializedIsNull
- shouldThrowNullPointerOnMaterializedReduceIfNamedIsNull
- shouldThrowNullPointerOnMaterializedReduceIfReducerIsNull
- shouldThrowNullPointerOnReduceIfReducerIsNull
org.apache.kafka.streams.kstream.internals.TimestampedCacheFlushListenerTest:
- shouldForwardParameterTimestampIfNewValueIsNull
- shouldForwardValueTimestampIfNewValueExists
org.apache.kafka.streams.kstream.internals.TimestampedTupleForwarderTest:
- shouldForwardRecordsIfWrappedStateStoreDoesNotCache
- shouldNotForwardRecordsIfWrappedStateStoreDoesCache
- shouldSetFlushListenerOnWrappedStateStore
org.apache.kafka.streams.kstream.internals.UnlimitedWindowTest:
- cannotCompareUnlimitedWindowWithDifferentWindowType
- shouldAlwaysOverlap
org.apache.kafka.streams.kstream.internals.WindowedStreamPartitionerTest:
- testCopartitioning
org.apache.kafka.streams.kstream.internals.foreignkeyjoin.CombinedKeySchemaTest:
- nonNullPrimaryKeySerdeTest
- nullForeignKeySerdeTest
- nullPrefixKeySerdeTest
- nullPrimaryKeySerdeTest
- prefixKeySerdeTest
org.apache.kafka.streams.kstream.internals.foreignkeyjoin.ForeignTableJoinProcessorSupplierTests:
- shouldIgnoreRecordWithNullKey
- shouldNotMatchForeignKeysHavingThisFKAsPrefix
- shouldPropagateNothingIfNoMatchingPrimaryKey
- shouldPropagateRightRecordForEachMatchingPrimaryKey
- shouldPropagateTombstoneRightRecordForEachMatchingPrimaryKey
org.apache.kafka.streams.kstream.internals.foreignkeyjoin.ResponseJoinProcessorSupplierTest:
- shouldEmitResultForLeftJoinWhenRightIsNull
- shouldEmitTombstoneForInnerJoinWhenRightIsNull
- shouldEmitTombstoneForLeftJoinWhenRightIsNullAndLeftIsNull
- shouldForwardWhenHashMatches
- shouldIgnoreUpdateWhenLeftHasBecomeNull
- shouldNotForwardWhenHashDoesNotMatch
org.apache.kafka.streams.kstream.internals.foreignkeyjoin.SubscriptionJoinProcessorSupplierTest:
- shouldDeleteKeyAndPropagateFKV0
- shouldDeleteKeyAndPropagateFKV1
- shouldDeleteKeyNoPropagateV0
- shouldDeleteKeyNoPropagateV1
- shouldDetectVersionChange
- shouldPropagateNullIfNoFKAvailableV0
- shouldPropagateNullIfNoFKAvailableV1
- shouldPropagateOnlyIfFKAvailableV0
- shouldPropagateOnlyIfFKAvailableV1
org.apache.kafka.streams.kstream.internals.foreignkeyjoin.SubscriptionReceiveProcessorSupplierTest:
- shouldDeleteKeyAndPropagateV0
- shouldDeleteKeyAndPropagateV1
- shouldDeleteKeyNoPropagateV0
- shouldDeleteKeyNoPropagateV1
- shouldDetectVersionChange
- shouldPropagateNullIfNoFKValAvailableV0
- shouldPropagateNullIfNoFKValAvailableV1
- shouldPropagateOnlyIfFKValAvailableV0
- shouldPropagateOnlyIfFKValAvailableV1
org.apache.kafka.streams.kstream.internals.foreignkeyjoin.SubscriptionResponseWrapperSerdeTest:
- ShouldSerdeWithNonNullsTest
- shouldSerdeWithNullForeignValueTest
- shouldSerdeWithNullHashTest
- shouldSerdeWithNullsTest
- shouldThrowExceptionOnSerializeWhenDataVersionUnknown
- shouldThrowExceptionWithBadVersionTest
org.apache.kafka.streams.kstream.internals.foreignkeyjoin.SubscriptionSendProcessorSupplierTest:
- biFunctionInnerJoinShouldDeleteOldAndPropagateNewFK
- biFunctionInnerJoinShouldNotPropagateNewPrimaryKeyWithNullFK
- biFunctionInnerJoinShouldPropagateDeletionOfPrimaryKey
- biFunctionInnerJoinShouldPropagateNewPrimaryKey
- biFunctionInnerJoinShouldPropagateNothingWhenOldAndNewFKIsNull
- biFunctionInnerJoinShouldPropagateNothingWhenOldAndNewLeftValueIsNull
- biFunctionLeftJoinShouldPropagateChangeFromNullFKToNonNullFKValue
- biFunctionLeftJoinShouldPropagateChangeFromNullFKToNullFKValue
- biFunctionLeftJoinShouldPropagateChangeOfFKFromNonNullToNonNullValue
- biFunctionLeftJoinShouldPropagateChangeOfFKFromNonNullToNullValue
- biFunctionLeftJoinShouldPropagateDeletionOfAPrimaryKey
- biFunctionLeftJoinShouldPropagateDeletionOfAPrimaryKeyThatHadNullFK
- biFunctionLeftJoinShouldPropagateNewPrimaryKeyWithNonNullFK
- biFunctionLeftJoinShouldPropagateNewPrimaryKeyWithNullFK
- biFunctionLeftJoinShouldPropagateNewRecordOfUnchangedFK
- biFunctionLeftJoinShouldPropagateNothingWhenOldAndNewLeftValueIsNull
- innerJoinShouldDeleteAndPropagateChangeFromNonNullFKToNullFK
- innerJoinShouldDeleteOldAndPropagateNewFK
- innerJoinShouldNotPropagateDeletionOfPrimaryKeyWhenPreviousFKIsNull
- innerJoinShouldNotPropagateNewPrimaryKeyWithNullFK
- innerJoinShouldPropagateChangeFromNullFKToNonNullFK
- innerJoinShouldPropagateDeletionOfPrimaryKey
- innerJoinShouldPropagateNewPrimaryKey
- innerJoinShouldPropagateNothingWhenOldAndNewFKIsNull
- innerJoinShouldPropagateNothingWhenOldAndNewLeftValueIsNull
- innerJoinShouldPropagateUnchangedFKOnlyIfFKExistsInRightTable
- leftJoinShouldPropagateChangeFromNullFKToNonNullFKValue
- leftJoinShouldPropagateChangeFromNullFKToNullFKValue
- leftJoinShouldPropagateChangeOfFKFromNonNullToNonNullValue
- leftJoinShouldPropagateChangeOfFKFromNonNullToNullValue
- leftJoinShouldPropagateDeletionOfAPrimaryKey
- leftJoinShouldPropagateDeletionOfAPrimaryKeyThatHadNullFK
- leftJoinShouldPropagateNewPrimaryKeyWithNonNullFK
- leftJoinShouldPropagateNewPrimaryKeyWithNullFK
- leftJoinShouldPropagateNewRecordOfUnchangedFK
- leftJoinShouldPropagateNothingWhenOldAndNewLeftValueIsNull
org.apache.kafka.streams.kstream.internals.foreignkeyjoin.SubscriptionWrapperSerdeTest:
- shouldSerdeNullHashV0Test
- shouldSerdeNullHashV1Test
- shouldSerdeNullPrimaryPartitionOnV0Test
- shouldSerdeV0Test
- shouldSerdeV1Test
- shouldSerdeWithV0IfUpgradeTest
- shouldThrowExceptionOnNullInstructionV0Test
- shouldThrowExceptionOnNullInstructionV1Test
- shouldThrowExceptionOnNullKeyV0Test
- shouldThrowExceptionOnNullKeyV1Test
- shouldThrowExceptionOnNullPrimaryPartitionV1Test
- shouldThrowExceptionOnUnsupportedVersionTest
org.apache.kafka.streams.kstream.internals.graph.GraphGraceSearchUtilTest:
- shouldExtractGraceFromKStreamSessionWindowAggregateNode
- shouldExtractGraceFromKStreamWindowAggregateNode
- shouldExtractGraceFromSessionAncestorThroughStatefulParent
- shouldExtractGraceFromSessionAncestorThroughStatelessParent
- shouldFailIfThereIsNoGraceAncestor
- shouldThrowOnNull
- shouldUseMaxIfMultiParentsDoNotAgreeOnGrace
org.apache.kafka.streams.kstream.internals.graph.GraphNodeTest:
- testAddChild
- testClearChildren
- testCopyParentsCollection
- testParentsWrittenToTopology
- testRemoveValidChild
- testToString
org.apache.kafka.streams.kstream.internals.graph.StreamsGraphTest:
- shouldBeAbleToBuildTopologyIncrementally
- shouldBeAbleToProcessNestedMultipleKeyChangingNodes
- shouldNotOptimizeWhenRepartitionOperationIsDone
- shouldNotOptimizeWithValueOrKeyChangingOperatorsAfterInitialKeyChange
- shouldNotThrowNPEWithMergeNodes
- shouldOptimizeSeveralMergeNodesWithCommonKeyChangingParent
org.apache.kafka.streams.kstream.internals.graph.TableSourceNodeTest:
- shouldConnectStateStoreToChangelogTopic
- shouldConnectStateStoreToInputTopicIfInputTopicIsUsedAsChangelog
org.apache.kafka.streams.kstream.internals.suppress.KTableSuppressProcessorMetricsTest:
- shouldRecordMetricsWithBuiltInMetricsVersionLatest
org.apache.kafka.streams.kstream.internals.suppress.KTableSuppressProcessorTest:
- finalResultsShouldDropTombstonesForSessionWindows
- finalResultsShouldDropTombstonesForTimeWindows
- finalResultsSuppressionShouldBufferAndEmitAtGraceExpiration
- finalResultsWithZeroGraceAtWindowEndShouldImmediatelyEmit
- finalResultsWithZeroGraceShouldStillBufferUntilTheWindowEnd
- intermediateSuppressionShouldBufferAndEmitLater
- suppressShouldEmitWhenOverByteCapacity
- suppressShouldEmitWhenOverRecordCapacity
- suppressShouldNotDropTombstonesForKTable
- suppressShouldNotDropTombstonesForSessionWindows
- suppressShouldNotDropTombstonesForTimeWindows
- suppressShouldShutDownWhenOverByteCapacity
- suppressShouldShutDownWhenOverRecordCapacity
- windowedZeroTimeLimitShouldImmediatelyEmit
- zeroTimeLimitShouldImmediatelyEmit
org.apache.kafka.streams.processor.FailOnInvalidTimestampTest:
- extractMetadataTimestamp
- failOnInvalidTimestamp
org.apache.kafka.streams.processor.LogAndSkipOnInvalidTimestampTest:
- extractMetadataTimestamp
- logAndSkipOnInvalidTimestamp
org.apache.kafka.streams.processor.ReadOnlyStoreTest:
- shouldConnectProcessorAndWriteDataToReadOnlyStore
org.apache.kafka.streams.processor.UsePartitionTimeOnInvalidTimestampTest:
- extractMetadataTimestamp
- shouldThrowStreamsException
- usePartitionTimeOnInvalidTimestamp
org.apache.kafka.streams.processor.WallclockTimestampExtractorTest:
- extractSystemTimestamp
org.apache.kafka.streams.processor.internals.AbstractProcessorContextTest:
- appConfigsShouldReturnParsedValues
- appConfigsShouldReturnUnrecognizedValues
- shouldNotThrowIllegalStateExceptionOnRegisterWhenContextIsNotInitialized
- shouldNotThrowNullPointerExceptionOnTopicIfRecordContextTopicIsNull
- shouldReturnDummyPartitionIfNoRecordContext
- shouldReturnDummyTimestampIfNoRecordContext
- shouldReturnEmptyHeadersIfHeadersAreNotSet
- shouldReturnHeadersFromRecordContext
- shouldReturnNullIfTopicEqualsNonExistTopic
- shouldReturnNullTopicIfNoRecordContext
- shouldReturnOffsetFromRecordContext
- shouldReturnPartitionFromRecordContext
- shouldReturnTimestampFromRecordContext
- shouldReturnTopicFromRecordContext
- shouldThrowErrorIfSerdeDefaultNotSet
- shouldThrowIllegalStateExceptionOnOffsetIfNoRecordContext
- shouldThrowIllegalStateExceptionOnRegisterWhenContextIsInitialized
- shouldThrowNullPointerOnRegisterIfStateStoreIsNull
org.apache.kafka.streams.processor.internals.ActiveTaskCreatorTest:
- shouldCloseIfEosDisabled
- shouldCloseIfEosV2Enabled
- shouldConstructClientIdWithEosDisabled
- shouldConstructClientIdWithEosV2Enabled
- shouldConstructProducerMetricsWithEosDisabled
- shouldConstructProducerMetricsWithEosV2Enabled
- shouldNotResetProducerAfterDisableRest
- shouldReturnBlockedTimeWhenStreamsProducer
- shouldReturnStreamsProducerIfAtLeastOnceIsEnabled
- shouldReturnStreamsProducerIfEosV2Enabled
- shouldThrowStreamsExceptionOnErrorCloseIfEosDisabled
- shouldThrowStreamsExceptionOnErrorCloseIfEosV2Enabled
org.apache.kafka.streams.processor.internals.ChangelogTopicsTest:
- shouldContainBothTypesOfPreExistingChangelogs
- shouldNotContainAnyPreExistingChangelogsIfChangelogIsNewlyCreated
- shouldNotContainChangelogsForStatelessTasks
- shouldOnlyContainPreExistingNonSourceBasedChangelogs
- shouldOnlyContainPreExistingSourceBasedChangelogs
org.apache.kafka.streams.processor.internals.ClientUtilsTest:
- fetchCommittedOffsetsShouldRethrowKafkaExceptionAsStreamsException
- fetchCommittedOffsetsShouldRethrowTimeoutException
- fetchCommittedOffsetsShouldReturnEmptyMapIfPartitionsAreEmpty
- fetchEndOffsetsShouldRethrowExecutionExceptionAsStreamsException
- fetchEndOffsetsShouldRethrowInterruptedExceptionAsStreamsException
- fetchEndOffsetsShouldRethrowRuntimeExceptionAsStreamsException
- fetchEndOffsetsShouldReturnEmptyMapIfPartitionsAreEmpty
- shouldComputeSizeInBytesForConsumerRecord
- shouldComputeSizeInBytesForConsumerRecordWithNullKey
- shouldComputeSizeInBytesForConsumerRecordWithNullValue
- shouldComputeSizeInBytesForProducerRecord
- shouldComputeSizeInBytesForProducerRecordWithNullKey
- shouldComputeSizeInBytesForProducerRecordWithNullValue
org.apache.kafka.streams.processor.internals.CopartitionedTopicsEnforcerTest:
- shouldDeductNumberOfPartitionsFromRepartitionTopicWithEnforcedNumberOfPartitions
- shouldEnforceCopartitioningOnRepartitionTopics
- shouldNotThrowAnExceptionWhenNumberOfPartitionsOfNonRepartitionTopicAndRepartitionTopicWithEnforcedNumOfPartitionsMatch
- shouldNotThrowAnExceptionWhenRepartitionTopicConfigsWithEnforcedNumOfPartitionsAreValid
- shouldSetNumPartitionsToMaximumPartitionsWhenAllTopicsAreRepartitionTopics
- shouldThrowAnExceptionIfRepartitionTopicConfigsWithEnforcedNumOfPartitionsHaveDifferentNumOfPartitions
- shouldThrowAnExceptionWhenNumberOfPartitionsOfNonRepartitionTopicAndRepartitionTopicWithEnforcedNumOfPartitionsDoNotMatch
- shouldThrowTopologyBuilderExceptionIfNoPartitionsFoundForCoPartitionedTopic
- shouldThrowTopologyBuilderExceptionIfPartitionCountsForCoPartitionedTopicsDontMatch
org.apache.kafka.streams.processor.internals.DefaultStateUpdaterTest:
- shouldAddFailedTasksToQueueWhenRestoreThrowsStreamsExceptionWithTask
- shouldAddFailedTasksToQueueWhenRestoreThrowsStreamsExceptionWithoutTask
- shouldAddFailedTasksToQueueWhenUncaughtExceptionIsThrown
- shouldAutoCheckpointTasksOnInterval
- shouldCompleteWithNullIfNoTasks
- shouldCompleteWithNullIfTaskNotFound
- shouldDrainFailedTasksAndExceptions
- shouldDrainRestoredActiveTasks
- shouldGetTasksFromExceptionsAndFailedTasks
- shouldGetTasksFromPausedTasks
- shouldGetTasksFromRestoredActiveTasks
- shouldHandleTaskCorruptedExceptionAndAddFailedTasksToQueue
- shouldIdleWhenAllTasksPaused
- shouldImmediatelyAddMultipleStatelessTasksToRestoredTasks
- shouldImmediatelyAddSingleStatelessTaskToRestoredTasks
- shouldNotAutoCheckpointTasksIfIntervalNotElapsed
- shouldNotPauseActiveStatefulTaskInFailedTasks
- shouldNotPauseActiveStatefulTaskInRestoredActiveTasks
- shouldNotPauseStandbyTaskInFailedTasks
- shouldNotPausingNonExistTasks
- shouldNotResumeActiveStatefulTaskInFailedTasks
- shouldNotResumeActiveStatefulTaskInRestoredActiveTasks
- shouldNotResumeNonExistingTasks
- shouldNotResumeStandbyTaskInFailedTasks
- shouldNotSwitchTwiceToUpdatingStandbyTaskIfStandbyTaskIsRemoved
- shouldNotTransitToStandbyAgainAfterStandbyTaskFailed
- shouldPauseActiveStatefulTask
- shouldPauseActiveTaskAndTransitToUpdateStandby
- shouldPauseStandbyTask
- shouldPauseStandbyTaskAndNotTransitToRestoreActive
- shouldRecordMetrics
- shouldRemoveActiveStatefulTaskFromFailedTasks
- shouldRemoveActiveStatefulTaskFromRestoredActiveTasks
- shouldRemovePausedTask
- shouldRemoveStandbyTaskFromFailedTasks
- shouldRemoveStatelessTaskFromRestoredActiveTasks
- shouldRemoveUpdatingActiveStatefulTask
- shouldRemoveUpdatingStandbyTask
- shouldRestoreActiveStatefulTaskThenUpdateStandbyTaskAndAgainRestoreActiveStatefulTask
- shouldRestoreActiveStatefulTasksAndUpdateStandbyTasks
- shouldRestoreMultipleActiveStatefulTasks
- shouldRestoreSingleActiveStatefulTask
- shouldResumeActiveStatefulTask
- shouldResumeStandbyTask
- shouldReturnFalseForRestoreActiveTasksIfTaskRemoved
- shouldReturnFalseForRestoreActiveTasksIfTaskRemovedFromStateUpdater
- shouldReturnTrueForRestoreActiveTasksIfStandbyTask
- shouldReturnTrueForRestoreActiveTasksIfTaskAdded
- shouldReturnTrueForRestoreActiveTasksIfTaskFailed
- shouldReturnTrueForRestoreActiveTasksIfTaskPaused
- shouldReturnTrueForRestoreActiveTasksIfTaskRestored
- shouldReturnTrueForRestoreActiveTasksIfTaskUpdating
- shouldShutdownStateUpdater
- shouldShutdownStateUpdaterAndRestart
- shouldShutdownStateUpdaterWithPausedTasks
- shouldTasks
- shouldTasksFromInputQueue
- shouldThrowIfAddingActiveAndStandbyTaskWithSameId
- shouldThrowIfAddingActiveTasksWithSameId
- shouldThrowIfAddingStandbyAndActiveTaskWithSameId
- shouldThrowIfAddingStandbyTasksWithSameId
- shouldThrowIfRemovingPausedTaskFails
- shouldThrowIfRemovingUpdatingActiveTaskFailsWithRuntimeException
- shouldThrowIfRemovingUpdatingActiveTaskFailsWithStreamsException
- shouldThrowIfRemovingUpdatingStandbyTaskFailsWithRuntimeException
- shouldThrowIfRemovingUpdatingStandbyTaskFailsWithStreamsException
- shouldThrowIfRestartedWithNonEmptyFailedTasks
- shouldThrowIfRestartedWithNonEmptyRestoredTasks
- shouldThrowIfStandbyTaskNotInStateRunning
- shouldThrowIfStatefulTaskNotInStateRestoring
- shouldThrowIfStatelessTaskNotInStateRestoring
- shouldUpdateMultipleStandbyTasks
- shouldUpdateSingleStandbyTask
- shouldUpdateStandbyTaskAfterAllActiveStatefulTasksFailed
- shouldUpdateStandbyTaskAfterAllActiveStatefulTasksRemoved
org.apache.kafka.streams.processor.internals.DefaultStreamsRebalanceListenerTest:
- testOnAllTasksLost
- testOnAllTasksLostWithException
- testOnTasksAssigned
- testOnTasksAssignedWithException
- testOnTasksRevoked
- testOnTasksRevokedWithException
org.apache.kafka.streams.processor.internals.ForwardingDisabledProcessorContextTest:
- shouldThrowOnForward
- shouldThrowOnForwardWithTo
org.apache.kafka.streams.processor.internals.GlobalProcessorContextImplTest:
- shouldFailToForwardUsingToParameter
- shouldForwardToSingleChild
- shouldNotAllowCloseForKeyValueStore
- shouldNotAllowCloseForSessionStore
- shouldNotAllowCloseForTimestampedKeyValueStore
- shouldNotAllowCloseForTimestampedWindowStore
- shouldNotAllowCloseForWindowStore
- shouldNotAllowInitForKeyValueStore
- shouldNotAllowInitForSessionStore
- shouldNotAllowInitForTimestampedKeyValueStore
- shouldNotAllowInitForTimestampedWindowStore
- shouldNotAllowInitForWindowStore
- shouldNotAllowToSchedulePunctuations
- shouldNotFailOnNoOpCommit
- shouldReturnGlobalOrNullStore
- shouldThrowOnCurrentStreamTime
org.apache.kafka.streams.processor.internals.GlobalStateManagerImplTest:
- shouldAttemptToCloseAllStoresEvenWhenSomeException
- shouldCheckpointOffsets
- shouldCheckpointRestoredOffsetsToFile
- shouldCloseStateStores
- shouldConvertValuesIfInnerStoreImplementsTimestampedBytesStore
- shouldConvertValuesIfStoreImplementsTimestampedBytesStore
- shouldFailOnDeserializationErrorsWhenReprocessing
- shouldFlushStateStores
- shouldInitializeStateStores
- shouldListenForRestoreEvents
- shouldListenForRestoreEventsWhenReprocessing
- shouldLogWarningMessageWhenIOExceptionInCheckPoint
- shouldNotCloseStoresIfCloseAlreadyCalled
- shouldNotConvertValuesIfInnerStoreDoesNotImplementTimestampedBytesStore
- shouldNotConvertValuesIfStoreDoesNotImplementTimestampedBytesStore
- shouldNotDeleteCheckpointFileAfterLoaded
- shouldNotFailOnSlowProgressWhenEndOffsetsThrowsTimeoutException
- shouldNotFailOnSlowProgressWhenPartitionForThrowsTimeoutException
- shouldNotFailOnSlowProgressWhenPositionThrowsTimeoutException
- shouldNotRemoveOffsetsOfUnUpdatedTablesDuringCheckpoint
- shouldNotRetryWhenEndOffsetsThrowsTimeoutExceptionAndTaskTimeoutIsZero
- shouldNotRetryWhenPartitionsForThrowsTimeoutExceptionAndTaskTimeoutIsZero
- shouldNotRetryWhenPositionThrowsTimeoutExceptionAndTaskTimeoutIsZero
- shouldReadCheckpointOffsets
- shouldRestoreRecordsFromCheckpointToHighWatermark
- shouldRestoreRecordsUpToHighwatermark
- shouldRetryAtLeastOnceWhenEndOffsetsThrowsTimeoutException
- shouldRetryAtLeastOnceWhenPartitionsForThrowsTimeoutException
- shouldRetryAtLeastOnceWhenPositionThrowsTimeoutException
- shouldRetryWhenEndOffsetsThrowsTimeoutExceptionUntilTaskTimeoutExpired
- shouldRetryWhenPartitionsForThrowsTimeoutExceptionUntilTaskTimeoutExpires
- shouldRetryWhenPositionThrowsTimeoutExceptionUntilTaskTimeoutExpired
- shouldReturnInitializedStoreNames
- shouldSkipGlobalInMemoryStoreOffsetsToFile
- shouldSkipNullKeysWhenRestoring
- shouldSkipOnDeserializationErrorsWhenReprocessing
- shouldThrowIllegalArgumentExceptionIfAttemptingToRegisterStoreTwice
- shouldThrowIllegalArgumentExceptionIfCallbackIsNull
- shouldThrowIllegalArgumentIfTryingToRegisterStoreThatIsNotGlobal
- shouldThrowProcessorStateStoreExceptionIfStoreCloseFailed
- shouldThrowProcessorStateStoreExceptionIfStoreFlushFailed
- shouldThrowStreamsExceptionForOldTopicPartitions
- shouldThrowStreamsExceptionIfFailedToReadCheckpointedOffsets
- shouldThrowStreamsExceptionIfNoPartitionsFoundForStore
- shouldUsePollMsPlusRequestTimeoutInPollDuringRestoreAndTimeoutWhenNoProgressDuringRestore
org.apache.kafka.streams.processor.internals.GlobalStateTaskTest:
- shouldCheckpointDuringClose
- shouldCheckpointDuringInitialization
- shouldCheckpointIfReceivedEnoughRecordsAndFlushIntervalHasElapsed
- shouldCheckpointIfReceivedEnoughRecordsFromMultipleTopicsAndFlushIntervalElapsed
- shouldCheckpointOffsetsWhenStateIsFlushed
- shouldFlushStateManagerWithOffsets
- shouldInitializeContext
- shouldInitializeProcessorTopology
- shouldInitializeStateManager
- shouldNotCheckpointIfNotReceivedEnoughRecords
- shouldNotCheckpointWhenFlushIntervalHasNotLapsed
- shouldNotThrowStreamsExceptionWhenKeyDeserializationFailsWithSkipHandler
- shouldNotThrowStreamsExceptionWhenValueDeserializationFails
- shouldProcessRecordsForOtherTopic
- shouldProcessRecordsForTopic
- shouldThrowStreamsExceptionWhenKeyDeserializationFails
- shouldThrowStreamsExceptionWhenValueDeserializationFails
- shouldWipeGlobalStateDirectory
org.apache.kafka.streams.processor.internals.GlobalStreamThreadTest:
- shouldBeRunningAfterSuccessfulStart
- shouldCloseStateStoresOnClose
- shouldDieOnInvalidOffsetExceptionDuringStartup
- shouldDieOnInvalidOffsetExceptionWhileRunning
- shouldGetGlobalConsumerClientInstanceId
- shouldGetGlobalConsumerClientInstanceIdWithInternalTimeoutException
- shouldReturnErrorIfInstanceIdNotInitialized
- shouldReturnNullIfTelemetryDisabled
- shouldStayDeadAfterTwoCloses
- shouldStopRunningWhenClosedByUser
- shouldThrowStreamsExceptionOnStartupIfExceptionOccurred
- shouldThrowStreamsExceptionOnStartupIfThereIsAStreamsException
- shouldTimeOutOnGlobalConsumerInstanceId
- shouldTransitionToRunningOnStart
org.apache.kafka.streams.processor.internals.HighAvailabilityStreamsPartitionAssignorTest:
- shouldReturnAllActiveTasksToPreviousOwnerRegardlessOfBalanceAndTriggerRebalanceIfEndOffsetFetchFailsAndHighAvailabilityEnabled
- shouldScheduleProbingRebalanceOnThisClientIfWarmupTasksRequired
org.apache.kafka.streams.processor.internals.InternalTopicConfigTest:
- shouldAugmentCompactionLagMsWithVersionedChangelog
- shouldAugmentRetentionMsWithWindowedChangelog
- shouldSetCreateTimeByDefaultForRepartitionTopic
- shouldSetCreateTimeByDefaultForUnwindowedUnversionedChangelog
- shouldSetCreateTimeByDefaultForVersionedChangelog
- shouldSetCreateTimeByDefaultForWindowedChangelog
- shouldThrowIfNameIsInvalid
- shouldThrowIfNameIsNull
- shouldThrowNpeIfTopicConfigIsNull
- shouldUseSuppliedConfigsForRepartitionConfig
- shouldUseSuppliedConfigsForUnwindowedUnversionedChangelogConfig
- shouldUseSuppliedConfigsForVersionedChangelogConfig
- shouldUseSuppliedConfigsForWindowedChangelogConfig
org.apache.kafka.streams.processor.internals.InternalTopicManagerTest:
- shouldCleanUpWhenCreateTopicsResultsDoNotContainTopic
- shouldCleanUpWhenCreateTopicsTimesOut
- shouldCleanUpWhenUnexpectedExceptionIsThrownDuringSetup
- shouldCompleteTopicValidationOnRetry
- shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess
- shouldCreateRequiredTopics
- shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound
- shouldCreateTopics
- shouldExhaustRetriesOnMarkedForDeletionTopic
- shouldExhaustRetriesOnTimeoutExceptionForMakeReady
- shouldLogWhenTopicNotFoundAndNotThrowException
- shouldNotCreateTopicIfExistsWithDifferentPartitions
- shouldNotCreateTopicsWithEmptyInput
- shouldNotThrowExceptionForEmptyTopicMap
- shouldNotThrowExceptionIfExistsWithDifferentReplication
- shouldNotThrowExceptionIfTopicExistsWithDifferentReplication
- shouldOnlyRetryDescribeConfigsWhenDescribeConfigsThrowsLeaderNotAvailableExceptionDuringValidation
- shouldOnlyRetryDescribeTopicsWhenDescribeTopicsThrowsLeaderNotAvailableExceptionDuringValidation
- shouldOnlyRetryNotSuccessfulFuturesDuringSetup
- shouldOnlyRetryNotSuccessfulFuturesDuringValidation
- shouldReportMisconfigurationsOfCleanupPolicyForRepartitionTopics
- shouldReportMisconfigurationsOfCleanupPolicyForUnwindowedUnversionedChangelogTopics
- shouldReportMisconfigurationsOfCleanupPolicyForVersionedChangelogTopics
- shouldReportMisconfigurationsOfCleanupPolicyForWindowedChangelogTopics
- shouldReportMisconfigurationsOfPartitionCount
- shouldReportMissingTopics
- shouldReportMultipleMisconfigurationsForSameTopic
- shouldRetryCreateTopicWhenCreationTimesOut
- shouldRetryCreateTopicWhenTopicNotYetDeleted
- shouldRetryDeleteTopicWhenFutureTimesOut
- shouldRetryDeleteTopicWhenLeaderNotAvailable
- shouldRetryDeleteTopicWhenTopicUnknown
- shouldRetryWhenCallsThrowTimeoutExceptionDuringValidation
- shouldReturnCorrectPartitionCounts
- shouldReturnCorrectPartitionInfo
- shouldThrowExceptionWhenKeepsTopicLeaderNotAvailable
- shouldThrowInformativeExceptionForOlderBrokers
- shouldThrowTimeoutExceptionIfGetNumPartitionsHasTopicDescriptionTimeout
- shouldThrowTimeoutExceptionIfGetPartitionInfoHasTopicDescriptionTimeout
- shouldThrowTimeoutExceptionIfTopicExistsDuringSetup
- shouldThrowTimeoutExceptionInGetPartitionInfo
- shouldThrowTimeoutExceptionWhenCreateTopicExceedsTimeout
- shouldThrowTimeoutExceptionWhenFuturesNeverCompleteDuringCleanUp
- shouldThrowTimeoutExceptionWhenFuturesNeverCompleteDuringSetup
- shouldThrowTimeoutExceptionWhenFuturesNeverCompleteDuringValidation
- shouldThrowTimeoutExceptionWhenTimeoutIsExceededDuringValidation
- shouldThrowWhenConfigDescriptionsDoNotCleanupPolicyForUnwindowedUnversionedConfigDuringValidation
- shouldThrowWhenConfigDescriptionsDoNotContainCleanupPolicyForRepartitionConfigDuringValidation
- shouldThrowWhenConfigDescriptionsDoNotContainCleanupPolicyForWindowedConfigDuringValidation
- shouldThrowWhenConfigDescriptionsDoNotContainRetentionBytesForRepartitionConfigDuringValidation
- shouldThrowWhenConfigDescriptionsDoNotContainRetentionBytesForWindowedConfigDuringValidation
- shouldThrowWhenConfigDescriptionsDoNotContainRetentionMsForRepartitionConfigDuringValidation
- shouldThrowWhenConfigDescriptionsDoNotContainRetentionMsForWindowedConfigDuringValidation
- shouldThrowWhenConfigDescriptionsDoNotContainTopicDuringValidation
- shouldThrowWhenCreateTopicsResultsDoNotContainTopic
- shouldThrowWhenCreateTopicsThrowsUnexpectedException
- shouldThrowWhenDeleteTopicsThrowsUnexpectedException
- shouldThrowWhenDescribeConfigsThrowsUnexpectedExceptionDuringValidation
- shouldThrowWhenDescribeTopicsThrowsUnexpectedExceptionDuringValidation
- shouldThrowWhenPartitionCountUnknown
- shouldThrowWhenTopicDescriptionsDoNotContainTopicDuringValidation
- shouldValidateSuccessfully
- shouldValidateSuccessfullyWithEmptyInternalTopics
org.apache.kafka.streams.processor.internals.InternalTopologyBuilderTest:
- newDeserializationExceptionHandlerConfigShouldOverwriteOldOne
- shouldAddInternalTopicConfigForNonWindowNonVersionedStores
- shouldAddInternalTopicConfigForRepartitionTopics
- shouldAddInternalTopicConfigForVersionedStores
- shouldAddInternalTopicConfigForWindowStores
- shouldAddPatternSourceWithoutOffsetReset
- shouldAddSourcePatternWithOffsetReset
- shouldAddSourceWithOffsetReset
- shouldAddSourceWithoutOffsetReset
- shouldAddTimestampExtractorPerSource
- shouldAddTimestampExtractorWithPatternPerSource
- shouldAllowAddingSameStoreBuilderMultipleTimes
- shouldAllowIncrementalBuilds
- shouldAssociateStateStoreNameWhenStateStoreSupplierIsExternal
- shouldAssociateStateStoreNameWhenStateStoreSupplierIsInternal
- shouldConnectGlobalStateStoreToInputTopic
- shouldConnectRegexMatchedTopicsToStateStore
- shouldCorrectlyMapStateStoreToInternalTopics
- shouldHandleWhenTopicPropertiesNumberOfPartitionsIsNull
- shouldHaveCorrectInternalTopicConfigWhenInternalTopicPropertiesAreNotPresent
- shouldHaveCorrectInternalTopicConfigWhenInternalTopicPropertiesArePresent
- shouldNotAddNullInternalTopic
- shouldNotAddNullInternalTopicProperties
- shouldNotAddNullStateStoreSupplier
- shouldNotAllowNullNameWhenAddingProcessor
- shouldNotAllowNullNameWhenAddingSink
- shouldNotAllowNullNameWhenAddingSource
- shouldNotAllowNullProcessorNameWhenConnectingProcessorAndStateStores
- shouldNotAllowNullProcessorSupplier
- shouldNotAllowNullStateStoreNameWhenConnectingProcessorAndStateStores
- shouldNotAllowNullTopicChooserWhenAddingSink
- shouldNotAllowNullTopicWhenAddingSink
- shouldNotAllowOffsetResetSourceWithDuplicateSourceName
- shouldNotAllowOffsetResetSourceWithoutTopics
- shouldNotAllowToAddGlobalStoreWithSourceNameEqualsProcessorName
- shouldNotAllowToAddGlobalStoresWithSameName
- shouldNotAllowToAddStoresWithSameName
- shouldNotAllowToAddStoresWithSameNameWhenFirstStoreIsGlobal
- shouldNotAllowToAddStoresWithSameNameWhenSecondStoreIsGlobal
- shouldNotOverrideGlobalStreamsConfigWhenGivenUnnamedTopologyProps
- shouldNotSetApplicationIdToNull
- shouldNotSetStreamsConfigToNull
- shouldOverrideGlobalStreamsConfigWhenGivenNamedTopologyProps
- shouldSetCorrectSourceNodesWithRegexUpdatedTopics
- shouldSetTopologyConfigOnRewriteTopology
- shouldSortProcessorNodesCorrectly
- shouldThrowIfBothTopicAndPatternAreNotNull
- shouldThrowIfNameIsNull
- shouldThrowIfTopicAndPatternAreNull
- shouldThrowOnInvalidProcessorWrapperClassName
- shouldUseNonDeprecatedConfigToSetCacheBytesWhenBothDeprecatedAndNonDeprecatedConfigsUsed
- shouldWrapFixedKeyProcessorSupplier
- shouldWrapProcessorSupplier
- sourceShouldBeEqualIfNameAndPatternAreTheSame
- sourceShouldBeEqualIfNameAndTopicListAreTheSame
- sourceShouldNotBeEqualForDifferentNamesWithSamePattern
- sourceShouldNotBeEqualForDifferentNamesWithSameTopicList
- sourceShouldNotBeEqualForDifferentPattern
- sourceShouldNotBeEqualForDifferentTopicList
- testAddGlobalStoreWithBadSupplier
- testAddMoreThanOnePatternSourceNode
- testAddProcessorWithBadSupplier
- testAddProcessorWithEmptyParents
- testAddProcessorWithNullParents
- testAddProcessorWithSameName
- testAddProcessorWithSelfParent
- testAddProcessorWithWrongParent
- testAddSinkConnectedWithMultipleParent
- testAddSinkConnectedWithParent
- testAddSinkWithEmptyParents
- testAddSinkWithNullParents
- testAddSinkWithSameName
- testAddSinkWithSelfParent
- testAddSinkWithWrongParent
- testAddSourceWithSameName
- testAddSourceWithSameTopic
- testAddStateStore
- testAddStateStoreWithNonExistingProcessor
- testAddStateStoreWithSink
- testAddStateStoreWithSource
- testBuild
- testNameSourceTopicsWithGlobalTopics
- testNamedTopicMatchesAlreadyProvidedPattern
- testOnlyTopicNameSourceTopics
- testPatternAndNameSourceTopics
- testPatternMatchesAlreadyProvidedTopicSource
- testPatternSourceTopic
- testPatternSourceTopicsWithGlobalTopics
- testStateStoreNamesForSubtopology
- testSubscribeTopicNameAndPattern
- testTopicGroups
- testTopicGroupsByStateStore
org.apache.kafka.streams.processor.internals.KeyValueStoreMaterializerTest:
- shouldCreateDefaultTimestampedBuilderWithCachingAndLoggingDisabled
- shouldCreateDefaultTimestampedBuilderWithCachingDisabled
- shouldCreateDefaultTimestampedBuilderWithLoggingDisabled
- shouldCreateTimestampedBuilderWithCachingAndLoggingEnabledByDefault
- shouldCreateTimestampedStoreWithProvidedSupplierAndCachingAndLoggingDisabled
- shouldCreateTimestampedStoreWithProvidedSupplierAndCachingAndLoggingEnabledByDefault
- shouldCreateTimestampedStoreWithProvidedSupplierAndCachingDisabled
- shouldCreateTimestampedStoreWithProvidedSupplierAndLoggingDisabled
- shouldCreateVersionedStoreWithProvidedSupplierAndLoggingDisabled
- shouldCreateVersionedStoreWithProvidedSupplierAndLoggingEnabledByDefault
- shouldNotBuildVersionedStoreWithCachingEvenIfExplicitlySet
org.apache.kafka.streams.processor.internals.NamedTopologyTest:
- shouldAllowAddingAndRemovingNamedTopologyAndReturnBeforeCallingStart
- shouldAllowSameStoreNameToBeUsedByMultipleNamedTopologies
- shouldBuildMultipleIdenticalNamedTopologyWithRepartition
- shouldBuildSingleNamedTopology
- shouldDescribeWithEmptyNamedTopology
- shouldDescribeWithMultipleNamedTopologies
- shouldDescribeWithSingleNamedTopology
- shouldReturnEmptyWhenLookingUpNonExistentTopologyByName
- shouldReturnTopologyByName
- shouldThrowIllegalArgumentOnIllegalName
- shouldThrowTopologyExceptionWhenAddingNamedTopologyReadingFromSameInputTopicAfterStart
- shouldThrowTopologyExceptionWhenAddingNamedTopologyReadingFromSameInputTopicBeforeStart
- shouldThrowTopologyExceptionWhenMultipleNamedTopologiesCreateStreamAndTableFromSameInputTopic
- shouldThrowTopologyExceptionWhenMultipleNamedTopologiesCreateStreamFromOverlappingInputTopicCollection
- shouldThrowTopologyExceptionWhenMultipleNamedTopologiesCreateStreamFromSameInputTopic
- shouldThrowTopologyExceptionWhenMultipleNamedTopologiesCreateStreamFromSamePattern
- shouldThrowTopologyExceptionWhenMultipleNamedTopologiesCreateTableFromSameInputTopic
- shouldThrowUnknownStateStoreExceptionForQueryMetadataForKey
- shouldThrowUnknownStateStoreExceptionForStore
- shouldThrowUnknownStateStoreExceptionForStreamsMetadataForStore
- shouldThrowUnknownTopologyExceptionForAllLocalStorePartitionLags
- shouldThrowUnknownTopologyExceptionForQueryMetadataForKey
- shouldThrowUnknownTopologyExceptionForStore
- shouldThrowUnknownTopologyExceptionForStreamsMetadataForStore
org.apache.kafka.streams.processor.internals.PartitionGroupTest:
- shouldBeReadyIfAllPartitionsAreBuffered
- shouldChooseNextRecordBasedOnHeadTimestamp
- shouldEmptyPartitionsOnClear
- shouldIdleAsSpecifiedWhenLagIsZero
- shouldNeverWaitIfIdlingIsDisabled
- shouldSetPartitionTimestampAndStreamTime
- shouldThrowIllegalStateExceptionUponAddRecordsIfPartitionUnknown
- shouldThrowIllegalStateExceptionUponGetHeadRecordOffsetIfPartitionUnknown
- shouldThrowIllegalStateExceptionUponGetPartitionTimestampIfPartitionUnknown
- shouldThrowIllegalStateExceptionUponHeadRecordLeaderEpochIfPartitionUnknown
- shouldThrowIllegalStateExceptionUponNumBufferedIfPartitionUnknown
- shouldThrowIllegalStateExceptionUponSetPartitionTimestampIfPartitionUnknown
- shouldUpdateBufferSizeCorrectlyForSkippedRecords
- shouldUpdateLags
- shouldUpdatePartitionQueuesExpand
- shouldUpdatePartitionQueuesShrink
- shouldUpdatePartitionQueuesShrinkAndExpand
- shouldWaitForFetchesWhenMetadataIsIncomplete
- shouldWaitForPollWhenLagIsNonzero
- testTimeTracking
org.apache.kafka.streams.processor.internals.PartitionGrouperTest:
- shouldComputeGroupingForSingleGroupWithMultipleTopics
- shouldComputeGroupingForTwoGroups
- shouldNotCreateAnyTasksBecauseOneTopicHasUnknownPartitions
org.apache.kafka.streams.processor.internals.ProcessorContextImplTest:
- globalKeyValueStoreShouldBeReadOnly
- globalSessionStoreShouldBeReadOnly
- globalTimestampedKeyValueStoreShouldBeReadOnly
- globalTimestampedWindowStoreShouldBeReadOnly
- globalWindowStoreShouldBeReadOnly
- localKeyValueStoreShouldNotAllowInitOrClose
- localSessionStoreShouldNotAllowInitOrClose
- localTimestampedKeyValueStoreShouldNotAllowInitOrClose
- localTimestampedWindowStoreShouldNotAllowInitOrClose
- localWindowStoreShouldNotAllowInitOrClose
- shouldAddAndGetProcessorKeyValue
- shouldMatchStreamTime
- shouldNotSendRecordHeadersToChangelogTopic
- shouldSendRecordHeadersToChangelogTopicWhenConsistencyEnabled
- shouldSetAndGetProcessorMetaData
- shouldThrowUnsupportedOperationExceptionOnCommit
- shouldThrowUnsupportedOperationExceptionOnCurrentNode
- shouldThrowUnsupportedOperationExceptionOnForward
- shouldThrowUnsupportedOperationExceptionOnForwardWithTo
- shouldThrowUnsupportedOperationExceptionOnGetStateStore
- shouldThrowUnsupportedOperationExceptionOnLogChange
- shouldThrowUnsupportedOperationExceptionOnOffset
- shouldThrowUnsupportedOperationExceptionOnPartition
- shouldThrowUnsupportedOperationExceptionOnRecordContext
- shouldThrowUnsupportedOperationExceptionOnSchedule
- shouldThrowUnsupportedOperationExceptionOnSetRecordContext
- shouldThrowUnsupportedOperationExceptionOnTimestamp
- shouldThrowUnsupportedOperationExceptionOnTopic
org.apache.kafka.streams.processor.internals.ProcessorContextTest:
- shouldNotAllowToScheduleSubMillisecondPunctuation
- shouldNotAllowToScheduleZeroMillisecondPunctuation
org.apache.kafka.streams.processor.internals.ProcessorMetadataTest:
- shouldAddAndGetKeyValueWithEmptyConstructor
- shouldAddAndGetKeyValueWithExistingMeta
- shouldDeserializeNull
- shouldNotUseCommitFlagForHashcodeAndEquals
- shouldSerializeAndDeserialize
- shouldUpdate
- shouldUpdateCommitFlag
org.apache.kafka.streams.processor.internals.ProcessorNodeTest:
- shouldBuildDeadLetterQueueRecordsInDefaultProcessingExceptionHandler
- shouldBuildDeadLetterQueueRecordsInLogAndContinueProcessingExceptionHandler
- shouldFailWithDeadLetterQueueRecords
- shouldFailWithoutDeadLetterQueueRecords
- shouldNotBeModifiable
- shouldNotHandleInternalExceptionsThrownDuringProcessing
- shouldNotThrowFailedProcessingExceptionWhenProcessingExceptionHandlerRepliesWithContinue
- shouldResumeWithDeadLetterQueueRecords
- shouldResumeWithoutDeadLetterQueueRecords
- shouldReturnsEmptyList
- shouldThrowFailedProcessingExceptionWhenProcessingExceptionHandlerRepliesWithFail
- shouldThrowFailedProcessingExceptionWhenProcessingExceptionHandlerThrowsAnException
- shouldThrowStreamsExceptionIfExceptionCaughtDuringClose
- shouldThrowStreamsExceptionIfExceptionCaughtDuringInit
- testMetricsWithBuiltInMetricsVersionLatest
- testTopologyLevelClassCastException
- testTopologyLevelClassCastExceptionDirect
- testTopologyLevelConfigException
org.apache.kafka.streams.processor.internals.ProcessorRecordContextTest:
- shouldEstimateEmptyHeaderAsZeroLength
- shouldEstimateHeadersLength
- shouldEstimateNullTopicAndEmptyHeadersAsZeroLength
- shouldEstimateNullValueInHeaderAsZero
- shouldEstimateTopicLength
- shouldNotAllowNullHeaders
org.apache.kafka.streams.processor.internals.ProcessorStateManagerTest:
- shouldBeAbleToCloseWithoutRegisteringAnyStores
- shouldClearStoreCache
- shouldCloseAllStoresEvenIfStoreThrowsException
- shouldDeleteCheckPointFileIfEosEnabled
- shouldFindSingleStoreForChangelog
- shouldFlushCheckpointAndClose
- shouldFlushGoodStoresEvenSomeThrowsException
- shouldGetChangelogPartitionForRegisteredStore
- shouldGetRegisteredStore
- shouldInitializeOffsetsFromCheckpointFile
- shouldInitializeOffsetsFromCheckpointFileAndDeleteIfEOSEnabled
- shouldLoadMissingFileAsEmptyPosition
- shouldLogAWarningIfCheckpointThrowsAnIOException
- shouldNotDeleteCheckPointFileIfEosNotEnabled
- shouldNotRegisterNonLoggedStore
- shouldNotThrowTaskCorruptedExceptionAfterCheckpointing
- shouldNotThrowTaskCorruptedWithoutInMemoryStoreCheckpointAndNonEmptyDir
- shouldNotWriteCheckpointForNonPersistentStore
- shouldNotWriteCheckpointForStoresWithoutChangelogTopic
- shouldOverrideOffsetsWhenRestoreAndProcess
- shouldPreserveStreamsExceptionOnCloseIfStoreThrows
- shouldPreserveStreamsExceptionOnFlushIfStoreThrows
- shouldRecycleStoreAndReregisterChangelog
- shouldRegisterNonPersistentStore
- shouldRegisterPersistentStores
- shouldReportChangelogAsSource
- shouldReportTaskType
- shouldRestoreNonTimestampedStoreWithNoConverter
- shouldRestoreStoreWithRestoreCallback
- shouldRestoreTimestampedStoreWithConverter
- shouldReturnBaseDir
- shouldReturnDefaultChangelogTopicName
- shouldReturnDefaultChangelogTopicNameWithNamedTopology
- shouldThrowIfLoadCheckpointThrows
- shouldThrowIfRestoreCallbackThrows
- shouldThrowIfRestoringUnregisteredStore
- shouldThrowIfStateStoreHasLoggingDisabled
- shouldThrowIfStateStoreIsNotRegistered
- shouldThrowIllegalArgumentExceptionIfStoreNameIsSameAsCheckpointFileName
- shouldThrowIllegalArgumentExceptionOnRegisterWhenStoreHasAlreadyBeenRegistered
- shouldThrowIllegalStateIfInitializingOffsetsForCorruptedTasks
- shouldThrowOnFailureToWritePositionCheckpointFile
- shouldThrowProcessorStateExceptionOnCloseIfStoreThrowsAFailedProcessingException
- shouldThrowProcessorStateExceptionOnCloseIfStoreThrowsAnException
- shouldThrowProcessorStateExceptionOnFlushCacheIfStoreThrowsAFailedProcessingException
- shouldThrowProcessorStateExceptionOnFlushIfStoreThrowsAFailedProcessingException
- shouldThrowProcessorStateExceptionOnFlushIfStoreThrowsAnException
- shouldThrowTaskCorruptedWithoutPersistentStoreCheckpointAndNonEmptyDir
- shouldUnregisterChangelogsDuringClose
- shouldWriteCheckpointForPersistentStore
- shouldWritePositionCheckpointFile
org.apache.kafka.streams.processor.internals.ProcessorTopologyTest:
- inMemoryStoreShouldNotResultInPersistentLocalStore
- persistentLocalStoreShouldBeDetected
- shouldAddHeaders
- shouldConsiderHeaders
- shouldConsiderModifiedTimeStamps
- shouldConsiderModifiedTimeStampsForMultipleProcessors
- shouldConsiderTimeStamps
- shouldCreateStringWithMultipleSourcesAndTopics
- shouldCreateStringWithProcessors
- shouldCreateStringWithSourceAndTopics
- shouldGetTerminalNodes
- shouldRecursivelyPrintChildren
- shouldThrowIfMultipleSourceNodeOfSameSubtopologySubscribedToSameTopic
- shouldThrowIfSourceNodeToUpdateDoesNotExist
- shouldUpdateSourceTopicsOnlyForSourceNodesWithinTheSubtopology
- shouldUpdateSourceTopicsWithAllTopicsRemoved
- shouldUpdateSourceTopicsWithNewMatchingTopic
- shouldUpdateSourceTopicsWithRemovedTopic
- statelessTopologyShouldNotHavePersistentStore
- testDrivingConnectedStateStoreInDifferentProcessorsTopology
- testDrivingConnectedStateStoreTopology
- testDrivingForwardToSourceTopology
- testDrivingInternalRepartitioningForwardingTimestampTopology
- testDrivingInternalRepartitioningTopology
- testDrivingSimpleMultiSourceTopology
- testDrivingSimpleTopology
- testDrivingSimpleTopologyWithDroppingPartitioner
- testDrivingStatefulTopology
- testPrefixScanInMemoryStoreNoCachingNoLogging
- testPrefixScanInMemoryStoreWithCachingNoLogging
- testPrefixScanInMemoryStoreWithCachingWithLogging
- testPrefixScanLruMapNoCachingNoLogging
- testPrefixScanLruMapWithCachingNoLogging
- testPrefixScanLruMapWithCachingWithLogging
- testPrefixScanPersistentStoreNoCachingNoLogging
- testPrefixScanPersistentStoreWithCachingNoLogging
- testPrefixScanPersistentStoreWithCachingWithLogging
- testPrefixScanPersistentTimestampedStoreNoCachingNoLogging
- testPrefixScanPersistentTimestampedStoreWithCachingNoLogging
- testPrefixScanPersistentTimestampedStoreWithCachingWithLogging
- testTopologyMetadata
org.apache.kafka.streams.processor.internals.PunctuationQueueTest:
- testPunctuationInterval
- testPunctuationIntervalCancelFromPunctuator
- testPunctuationIntervalCustomAlignment
org.apache.kafka.streams.processor.internals.QuickUnionTest:
- testUnite
- testUniteMany
org.apache.kafka.streams.processor.internals.RackAwarenessStreamsPartitionAssignorTest:
- shouldDistributeOnDistinguishingTagSubset
- shouldDistributePartiallyWhenDoNotHaveEnoughClients
- shouldDistributeWithMaximumNumberOfClientTags
- shouldDistributeWithMultipleStandbys
org.apache.kafka.streams.processor.internals.ReadOnlyTaskTest:
- shouldDelegateChangelogPartitions
- shouldDelegateCommitNeededIfStandby
- shouldDelegateCommitRequested
- shouldDelegateId
- shouldDelegateInputPartitions
- shouldDelegateIsActive
- shouldDelegateNeedsInitializationOrRestoration
- shouldDelegateState
- shouldThrowUnsupportedOperationExceptionForCommitNeededIfActive
- shouldThrowUnsupportedOperationExceptionForForbiddenMethods
org.apache.kafka.streams.processor.internals.RecordCollectorTest:
- shouldAbortTxOnCloseDirtyIfEosEnabled
- shouldBroadcastToAllPartitions
- shouldBuildDeadLetterQueueRecordsInDefaultExceptionHandler
- shouldBuildDeadLetterQueueRecordsInDefaultExceptionHandlerDuringDeserialization
- shouldCallOldImplementationWithRecordContextExceptionHandler
- shouldClearOffsetsOnCloseClean
- shouldClearOffsetsOnCloseDirty
- shouldDropAllRecords
- shouldDropRecordExceptionUsingAlwaysContinueExceptionHandler
- shouldFailWithDeadLetterQueueRecords
- shouldFailWithoutDeadLetterQueueRecords
- shouldForwardFlushToStreamsProducer
- shouldForwardFlushToStreamsProducerEosEnabled
- shouldForwardRuntimeExceptionFromStreamPartitionerWithoutWrappingIt
- shouldForwardTimeoutExceptionFromStreamPartitionerWithoutWrappingIt
- shouldFreeRawRecordsInContextBeforeSending
- shouldHaveRawDataDuringExceptionInSerialization
- shouldNotAbortTxOnCloseCleanIfEosEnabled
- shouldNotAbortTxnOnEOSCloseDirtyIfNothingSent
- shouldNotBeModifiable
- shouldNotCallProductionExceptionHandlerOnClassCastException
- shouldNotCloseInternalProducerForEOS
- shouldNotCloseInternalProducerForNonEOS
- shouldNotFailIfContextIsNotAvailableOnSendError
- shouldNotFailIfContextIsNotAvailableOnSerializationError
- shouldNotFailIfRecordContextIsNotAvailableOnSendError
- shouldNotFailIfRecordContextIsNotAvailableOnSerializationError
- shouldNotSendIfSendOfOtherTaskFailedInCallback
- shouldNotThrowStreamsExceptionOnSubsequentCallIfASendFailsWithContinueExceptionHandler
- shouldNotThrowTaskCorruptedExceptionOnUnknownTopicOrPartitionExceptionUsingAlwaysContinueExceptionHandler
- shouldPassThroughRecordHeaderToSerializer
- shouldRecordRecordsAndBytesProduced
- shouldResumeWithDeadLetterQueueRecords
- shouldResumeWithoutDeadLetterQueueRecords
- shouldRetryWithoutDeadLetterQueueRecords
- shouldReturnsEmptyList
- shouldSendOnlyToEvenPartitions
- shouldSendToSpecificPartition
- shouldSendWithNoPartition
- shouldSendWithPartitioner
- shouldSwallowTransactionAbortedExceptionAndNotCallProductionExceptionHandler
- shouldThrowIfTopicIsUnknownOnSendWithPartitioner
- shouldThrowInformativeStreamsExceptionOnKafkaExceptionFromStreamPartitioner
- shouldThrowInformativeStreamsExceptionOnKeyAndNullValueClassCastException
- shouldThrowInformativeStreamsExceptionOnKeyClassCastException
- shouldThrowInformativeStreamsExceptionOnValueAndNullKeyClassCastException
- shouldThrowInformativeStreamsExceptionOnValueClassCastException
- shouldThrowStreamsExceptionOnSubsequentCloseIfASendFailsWithDefaultExceptionHandler
- shouldThrowStreamsExceptionOnSubsequentCloseIfFatalEvenWithContinueExceptionHandler
- shouldThrowStreamsExceptionOnSubsequentFlushIfASendFailsAndProductionExceptionHandlerReturnsNull
- shouldThrowStreamsExceptionOnSubsequentFlushIfASendFailsAndProductionExceptionHandlerThrows
- shouldThrowStreamsExceptionOnSubsequentFlushIfASendFailsWithDefaultExceptionHandler
- shouldThrowStreamsExceptionOnSubsequentFlushIfFatalEvenWithContinueExceptionHandler
- shouldThrowStreamsExceptionOnSubsequentSendIfASendFailsWithDefaultExceptionHandler
- shouldThrowStreamsExceptionOnSubsequentSendIfFatalEvenWithContinueExceptionHandler
- shouldThrowStreamsExceptionOnUnknownTopicOrPartitionExceptionWhenExceptionHandlerReturnsFail
- shouldThrowStreamsExceptionOnUnknownTopicOrPartitionExceptionWithDefaultExceptionHandler
- shouldThrowStreamsExceptionUsingDefaultExceptionHandler
- shouldThrowStreamsExceptionWhenKeySerializationFailedAndProductionExceptionHandlerRepliesWithFail
- shouldThrowStreamsExceptionWhenSerializationFailedAndProductionExceptionHandlerReturnsNull
- shouldThrowStreamsExceptionWhenSerializationFailedAndProductionExceptionHandlerThrows
- shouldThrowStreamsExceptionWhenValueSerializationFailedAndProductionExceptionHandlerRepliesWithFail
- shouldThrowTaskMigratedExceptionOnSubsequentCloseWhenInvalidEpochInCallback
- shouldThrowTaskMigratedExceptionOnSubsequentCloseWhenInvalidPidMappingInCallback
- shouldThrowTaskMigratedExceptionOnSubsequentCloseWhenProducerFencedInCallback
- shouldThrowTaskMigratedExceptionOnSubsequentFlushWhenInvalidEpochInCallback
- shouldThrowTaskMigratedExceptionOnSubsequentFlushWhenInvalidPidMappingInCallback
- shouldThrowTaskMigratedExceptionOnSubsequentFlushWhenProducerFencedInCallback
- shouldThrowTaskMigratedExceptionOnSubsequentSendWhenInvalidEpochInCallback
- shouldThrowTaskMigratedExceptionOnSubsequentSendWhenInvalidPidMappingInCallback
- shouldThrowTaskMigratedExceptionOnSubsequentSendWhenProducerFencedInCallback
- shouldTreatRetryAsFailForNonRetriableException
- shouldUpdateOffsetsUponCompletion
- shouldUseDefaultPartitionerAsPartitionReturnsEmptyOptional
- shouldUseDefaultPartitionerAsStreamPartitionerIsNull
- shouldUseDefaultPartitionerViaPartitions
org.apache.kafka.streams.processor.internals.RecordDeserializerTest:
- shouldBuildDeadLetterQueueRecordsInDefaultDeserializationException
- shouldBuildDeadLetterQueueRecordsInLogAndContinueDeserializationException
- shouldFailWhenDeserializationFailsAndExceptionHandlerReturnsNull
- shouldFailWhenDeserializationFailsAndExceptionHandlerThrows
- shouldFailWithDeadLetterQueueRecords
- shouldFailWithoutDeadLetterQueueRecords
- shouldNotBeModifiable
- shouldNotThrowStreamsExceptionWhenDeserializationFailsAndExceptionHandlerRepliesWithContinue
- shouldResumeWithDeadLetterQueueRecords
- shouldResumeWithoutDeadLetterQueueRecords
- shouldReturnConsumerRecordWithDeserializedValueWhenNoExceptions
- shouldReturnsEmptyList
- shouldThrowStreamsExceptionWhenDeserializationFailsAndExceptionHandlerRepliesWithFail
org.apache.kafka.streams.processor.internals.RecordQueueTest:
- shouldDropOnNegativeTimestamp
- shouldNotThrowStreamsExceptionWhenKeyDeserializationFailsWithSkipHandler
- shouldNotThrowStreamsExceptionWhenValueDeserializationFailsWithSkipHandler
- shouldPassPartitionTimeToTimestampExtractor
- shouldSetTimestampAndRespectMaxTimestampPolicy
- shouldThrowOnNegativeTimestamp
- shouldThrowStreamsExceptionWhenKeyDeserializationFails
- shouldThrowStreamsExceptionWhenValueDeserializationFails
- shouldTrackPartitionTimeAsMaxProcessedTimestamp
- testConsumedSensor
- testTimeTracking
org.apache.kafka.streams.processor.internals.RepartitionOptimizingTest:
- shouldSendCorrectRecords_OPTIMIZED
- shouldSendCorrectResults_NO_OPTIMIZATION
org.apache.kafka.streams.processor.internals.RepartitionTopicConfigTest:
- shouldNotThrowAnExceptionWhenSettingNumberOfPartitionsIfTheyAreNotEnforced
- shouldThrowAnExceptionWhenSettingNumberOfPartitionsIfTheyAreEnforced
org.apache.kafka.streams.processor.internals.RepartitionTopicsTest:
- shouldNotSetupRepartitionTopicsWhenTopologyDoesNotContainAnyRepartitionTopics
- shouldReturnMissingSourceTopics
- shouldSetRepartitionTopicPartitionCountFromUpstreamExternalSourceTopic
- shouldSetRepartitionTopicPartitionCountFromUpstreamInternalRepartitionSourceTopic
- shouldSetupRepartitionTopics
- shouldThrowTaskAssignmentExceptionIfPartitionCountCannotBeComputedForAllRepartitionTopics
- shouldThrowTaskAssignmentExceptionIfSourceTopicHasNoPartitionCount
org.apache.kafka.streams.processor.internals.RepartitionWithMergeOptimizingTest:
- shouldSendCorrectRecords_OPTIMIZED
- shouldSendCorrectResults_NO_OPTIMIZATION
org.apache.kafka.streams.processor.internals.SinkNodeTest:
- shouldThrowStreamsExceptionOnInputRecordWithInvalidTimestamp
- shouldThrowStreamsExceptionOnUndefinedKeySerde
- shouldThrowStreamsExceptionOnUndefinedValueSerde
- shouldThrowStreamsExceptionWithExplicitErrorMessage
org.apache.kafka.streams.processor.internals.SourceNodeTest:
- shouldExposeProcessMetrics
- shouldProvideTopicHeadersAndDataToKeyDeserializer
- shouldProvideTopicHeadersAndDataToValueDeserializer
- shouldThrowStreamsExceptionOnUndefinedKeySerde
- shouldThrowStreamsExceptionOnUndefinedValueSerde
- shouldThrowStreamsExceptionWithExplicitErrorMessage
org.apache.kafka.streams.processor.internals.StandbyTaskTest:
- shouldAlwaysCheckpointStateIfEnforced
- shouldAlwaysSuspendCreatedTasks
- shouldAlwaysSuspendRunningTasks
- shouldClearTaskTimeout
- shouldCloseStateManagerOnTaskCreated
- shouldDeleteStateDirOnTaskCreatedAndEosV2UncleanClose
- shouldFlushAndCheckpointStateManagerOnCommit
- shouldInitTaskTimeoutAndEventuallyThrow
- shouldNotFlushAndThrowOnCloseDirty
- shouldNotThrowFromStateManagerCloseInCloseDirty
- shouldOnlyCheckpointStateWithBigAdvanceIfNotEnforced
- shouldOnlyNeedCommitWhenChangelogOffsetChanged
- shouldPrepareRecycleSuspendedTask
- shouldRecordRestoredRecords
- shouldRequireSuspendingCreatedTasksBeforeClose
- shouldReturnStateManagerChangelogOffsets
- shouldSuspendAndCommitBeforeCloseClean
- shouldThrowIfCommittingOnIllegalState
- shouldThrowLockExceptionIfFailedToLockStateDirectory
- shouldThrowOnCloseCleanCheckpointError
- shouldThrowOnCloseCleanError
- shouldTransitToRunningAfterInitialization
- shouldUnregisterMetricsInCloseClean
- shouldUnregisterMetricsInCloseDirty
org.apache.kafka.streams.processor.internals.StateConsumerTest:
- shouldAssignPartitionsToConsumer
- shouldCloseConsumer
- shouldCloseStateMaintainer
- shouldSeekToInitialOffsets
- shouldUpdateStateWithReceivedRecordsForAllTopicPartition
- shouldUpdateStateWithReceivedRecordsForPartition
- shouldWipeStoreOnClose
org.apache.kafka.streams.processor.internals.StateDirectoryTest:
- shouldAssignStartupTaskToStreamThread
- shouldBeAbleToUnlockEvenWithoutLocking
- shouldBeTrueIfAlreadyHoldsLock
- shouldCleanUpTaskStateDirectoriesThatAreNotCurrentlyLocked
- shouldCleanupAllTaskDirectoriesIncludingGlobalOne
- shouldCleanupObsoleteTaskDirectoriesAndDeleteTheDirectoryItself
- shouldCleanupObsoleteTaskDirectoriesInNamedTopologiesAndDeleteTheParentDirectories
- shouldCleanupStateDirectoriesWhenLastModifiedIsLessThanNowMinusCleanupDelay
- shouldCloseStartupTasksOnDirectoryClose
- shouldCreateBaseDirectory
- shouldCreateDirectoriesIfParentDoesntExist
- shouldCreateTaskDirectoriesUnderNamedTopologyDirs
- shouldCreateTaskStateDirectory
- shouldDeleteAppDirWhenCleanUpIfEmpty
- shouldGetFreshProcessIdIfJsonUnreadable
- shouldGetFreshProcessIdIfProcessFileDeleted
- shouldHaveSecurePermissions
- shouldInitializeStandbyTasksForLocalState
- shouldLockMultipleTaskDirectories
- shouldLockTaskStateDirectoryWhenDirectoryCreationDisabled
- shouldLogManualUserCallMessage
- shouldLogStateDirCleanerMessage
- shouldLogTempDirMessage
- shouldNotAssignStartupTasksWeDontHave
- shouldNotCloseStartupTasksOnAutoCleanUp
- shouldNotCreateBaseDirectory
- shouldNotCreateGlobalStateDirectory
- shouldNotCreateTaskStateDirectory
- shouldNotDeleteAppDirWhenCleanUpIfNotEmpty
- shouldNotFailWhenCreatingTaskDirectoryInParallel
- shouldNotInitializeStandbyTasksWhenNoLocalState
- shouldNotLockStateDirLockedByAnotherThread
- shouldNotRemoveDirsThatDoNotMatchNamedTopologyDirsWhenCallingClean
- shouldNotRemoveNonTaskDirectoriesAndFiles
- shouldNotThrowIfStateDirectoryHasBeenDeleted
- shouldNotUnLockStateDirLockedByAnotherThread
- shouldOnlyListNonEmptyTaskDirectories
- shouldOnlyListNonEmptyTaskDirectoriesInNamedTopologies
- shouldParseNamedTaskId
- shouldParseUnnamedTaskId
- shouldPersistProcessIdAcrossRestart
- shouldReadFutureProcessFileFormat
- shouldRemoveEmptyNamedTopologyDirsWhenCallingClean
- shouldRemoveEmptyNamedTopologyDirsWhenCallingClearLocalStateForNamedTopology
- shouldRemoveNonEmptyNamedTopologyDirsWhenCallingClean
- shouldRemoveNonEmptyNamedTopologyDirsWhenCallingClearLocalStateForNamedTopology
- shouldReportDirectoryEmpty
- shouldReturnEmptyArrayForNonPersistentApp
- shouldReturnEmptyArrayIfListFilesReturnsNull
- shouldReturnEmptyArrayIfStateDirDoesntExist
- shouldThrowProcessorStateException
- shouldThrowProcessorStateExceptionIfStateDirOccupied
- shouldThrowProcessorStateExceptionIfTestDirOccupied
- shouldUnlockStartupTasksOnClose
org.apache.kafka.streams.processor.internals.StateManagerUtilTest:
- shouldNotCloseStateManagerIfUnableToLockTaskDirectory
- shouldNotWipeStateStoresIfUnableToLockTaskDirectory
- shouldStillWipeStateStoresIfCloseThrowsException
- testCloseStateManagerClean
- testCloseStateManagerThrowsExceptionWhenClean
- testCloseStateManagerThrowsExceptionWhenDirty
- testCloseStateManagerWithStateStoreWipeOut
- testCloseStateManagerWithStateStoreWipeOutRethrowWrappedIOException
- testRegisterStateStoreFailToLockStateDirectory
- testRegisterStateStoreWhenTopologyEmpty
- testRegisterStateStores
org.apache.kafka.streams.processor.internals.StateRestoreCallbackAdapterTest:
- shouldConvertToKeyValue
- shouldConvertToKeyValueBatches
- shouldPassRecordsThrough
- shouldThrowOnRestore
- shouldThrowOnRestoreAll
org.apache.kafka.streams.processor.internals.StoreChangelogReaderTest:
- shouldCheckCompletionIfPositionLargerThanEndOffset
- shouldInitializeChangelogAndCheckForCompletion
- shouldNotRegisterSameStoreMultipleTimes
- shouldNotRegisterStoreWithoutMetadata
- shouldNotThrowOnUnknownRevokedPartition
- shouldNotUpdateLimitForNonSourceStandbyChangelog
- shouldOnlyRestoreStandbyChangelogInUpdateStandbyState
- shouldPollWithRightTimeoutWithStateUpdater
- shouldPollWithRightTimeoutWithStateUpdaterDefault
- shouldPollWithRightTimeoutWithoutStateUpdater
- shouldRequestCommittedOffsetsAndHandleTimeoutException
- shouldRequestEndOffsetsAndHandleTimeoutException
- shouldRequestPositionAndHandleTimeoutException
- shouldRestoreFromBeginningAndCheckCompletion
- shouldRestoreFromPositionAndCheckForCompletion
- shouldRestoreMultipleChangelogs
- shouldRestoreToLimitInStandbyState
- shouldSupportUnregisterChangelogAfterCompletion
- shouldSupportUnregisterChangelogBeforeCompletion
- shouldSupportUnregisterChangelogBeforeInitialization
- shouldThrowIfCommittedOffsetsFail
- shouldThrowIfEndOffsetsFail
- shouldThrowIfPositionFail
- shouldThrowIfRestoreCallbackThrows
- shouldThrowIfUnsubscribeFail
- shouldTransitState
- shouldTransitStateBackToActiveRestoringAfterRemovingLastTask
- shouldTriggerRestoreListenerWithOffsetZeroIfPositionThrowsTimeoutException
org.apache.kafka.streams.processor.internals.StreamTaskTest:
- closeShouldBeIdempotent
- punctuateShouldNotHandleFailProcessingExceptionAndThrowStreamsException
- punctuateShouldNotHandleTaskCorruptedExceptionAndThrowItAsIs
- punctuateShouldNotHandleTaskMigratedExceptionAndThrowItAsIs
- punctuateShouldNotThrowStreamsExceptionWhenProcessingExceptionHandlerRepliesWithContinue
- punctuateShouldThrowFailedProcessingExceptionWhenProcessingExceptionHandlerThrowsAnException
- punctuateShouldThrowStreamsExceptionWhenProcessingExceptionHandlerRepliesWithFail
- punctuateShouldThrowStreamsExceptionWhenProcessingExceptionHandlerReturnsNull
- shouldAlwaysCheckpointStateIfEnforced
- shouldAlwaysSuspendCreatedTasks
- shouldAlwaysSuspendRestoringTasks
- shouldAlwaysSuspendRunningTasks
- shouldAttemptToDeleteStateDirectoryWhenCloseDirtyAndEosEnabled
- shouldAutoOffsetResetIfNoCommittedOffsetFound
- shouldBeProcessableIfAllPartitionsBuffered
- shouldBeRecordIdlingTimeIfSuspended
- shouldCallPunctuateOnPassedInProcessorNode
- shouldCheckpointAfterRestorationWhenAtLeastOnceEnabled
- shouldCheckpointForSuspendedRunningTaskWithLargeProgress
- shouldCheckpointForSuspendedTask
- shouldCheckpointOffsetsOnCommitIfSnapshotMuchChanged
- shouldCheckpointOffsetsOnPostCommit
- shouldCheckpointOnCloseRestoringIfNoProgress
- shouldCheckpointWhileUpdateSnapshotWithTheConsumedOffsetsForSuspendedRunningTask
- shouldClearCommitStatusesInCloseDirty
- shouldClearTaskTimeout
- shouldCloseStateManagerEvenDuringFailureOnUncleanTaskClose
- shouldCommitFetchedNextOffsetIfRecordQueueIsEmpty
- shouldCommitNextOffsetAndProcessorMetadataFromQueueIfAvailable
- shouldCommitOldProcessorMetadataWhenNotDirty
- shouldFailOnCommitIfTaskIsClosed
- shouldFlushStateManagerAndRecordCollector
- shouldInitTaskTimeoutAndEventuallyThrow
- shouldMaybeReturnOffsetsForRepartitionTopicsForPurging
- shouldNotAttemptToLockIfNoStores
- shouldNotCheckpointAfterRestorationWhenExactlyOnceEnabled
- shouldNotCheckpointForSuspendedRunningTaskWithSmallProgress
- shouldNotCheckpointOffsetsAgainOnCommitIfSnapshotNotChangedMuch
- shouldNotCheckpointOffsetsOnCommitIfEosIsEnabled
- shouldNotCheckpointOnCloseCreated
- shouldNotGetOffsetsIfPrepareCommitDirty
- shouldNotProcessRecordsAfterPrepareCommitWhenEosV2Enabled
- shouldNotPunctuateSystemTimeWhenIntervalNotElapsed
- shouldNotShareHeadersBetweenPunctuateIterations
- shouldNotThrowExceptionOnScheduleIfCurrentNodeIsNotNull
- shouldNotThrowFromStateManagerCloseInCloseDirty
- shouldOnlyCheckpointStateWithBigAdvanceIfNotEnforced
- shouldPauseAndResumeBasedOnBufferedRecords
- shouldPrepareRecycleSuspendedTask
- shouldProcessInOrder
- shouldProcessRecordsAfterPrepareCommitWhenEosDisabled
- shouldPunctuateOnceStreamTimeAfterGap
- shouldPunctuateOnceSystemTimeAfterGap
- shouldPunctuateSystemTimeWhenIntervalElapsed
- shouldReInitializeTopologyWhenResuming
- shouldReadCommittedOffsetAndRethrowTimeoutWhenCompleteRestoration
- shouldReadCommittedStreamTimeAndMergeProcessorMetadataOnInitialize
- shouldReadCommittedStreamTimeAndProcessorMetadataOnInitialize
- shouldRecordBufferedRecords
- shouldRecordE2ELatencyOnSourceNodeAndTerminalNodes
- shouldRecordProcessRatio
- shouldRecordRestoredRecords
- shouldResetOffsetsToLastCommittedForSpecifiedPartitions
- shouldRespectCommitNeeded
- shouldRespectCommitRequested
- shouldRespectPunctuateCancellationStreamTime
- shouldRespectPunctuateCancellationSystemTime
- shouldResumePartitionWhenSkippingOverRecordsWithInvalidTs
- shouldReturnStateManagerChangelogOffsets
- shouldSetProcessorNodeOnContextBackToNullAfterSuccessfulPunctuate
- shouldSkipCheckpointingSuspendedCreatedTask
- shouldThrowExceptionOnCloseCleanError
- shouldThrowIfCleanClosingDirtyTask
- shouldThrowIfCommittingOnIllegalState
- shouldThrowIfPostCommittingOnIllegalState
- shouldThrowIfRecyclingDirtyTask
- shouldThrowIllegalStateExceptionIfCurrentNodeIsNotNullWhenPunctuateCalled
- shouldThrowIllegalStateExceptionOnScheduleIfCurrentNodeIsNull
- shouldThrowLockExceptionIfFailedToLockStateDirectory
- shouldThrowOnCloseCleanCheckpointError
- shouldThrowOnCloseCleanFlushError
- shouldThrowOnTimeoutExceptionAndBufferRecordForRetryIfEosDisabled
- shouldThrowStreamsExceptionWhenFetchCommittedFailed
- shouldThrowTaskCorruptedExceptionOnTimeoutExceptionIfEosEnabled
- shouldThrowTopologyExceptionIfTaskCreatedForUnknownTopic
- shouldTransitToRestoringThenRunningAfterCreation
- shouldUnregisterMetricsAndCloseInPrepareRecycle
- shouldUnregisterMetricsInCloseClean
- shouldUnregisterMetricsInCloseDirty
- shouldUpdateOffsetIfAllRecordsAreCorrupted
- shouldUpdateOffsetIfAllRecordsHaveInvalidTimestamp
- shouldUpdateOffsetIfCorruptedRecordFollowsValid
- shouldUpdateOffsetIfInvalidTimestampeRecordFollowsValid
- shouldUpdateOffsetIfValidRecordFollowsCorrupted
- shouldUpdateOffsetIfValidRecordFollowsInvalidTimestamp
- shouldUpdatePartitions
- shouldWrapKafkaExceptionWithStreamsExceptionWhenProcess
- shouldWrapKafkaExceptionsWithStreamsExceptionAndAddContextWhenPunctuatingStreamTime
- shouldWrapKafkaExceptionsWithStreamsExceptionAndAddContextWhenPunctuatingWallClockTimeTime
- testMetrics
org.apache.kafka.streams.processor.internals.StreamThreadTest:
- shouldAlsoPurgeWhenNothingGetsCommitted
- shouldAlwaysUpdateTasksMetadataAfterChangingState
- shouldCatchHandleCorruptionOnTaskCorruptedExceptionPath
- shouldCatchTaskMigratedExceptionOnOnTaskCorruptedExceptionPath
- shouldCatchTimeoutExceptionFromHandleCorruptionAndInvokeExceptionHandler
- shouldChangeStateAtStartClose
- shouldChangeStateInRebalanceListener
- shouldCheckStateUpdater
- shouldCheckStateUpdaterInBetweenProcessCalls
- shouldCommitAfterCommitInterval
- shouldConstructAdminMetrics
- shouldCreateMetricsAtStartup
- shouldCreateStandbyTask
- shouldEnforceRebalanceWhenScheduledAndNotCurrentlyRebalancing
- shouldEnforceRebalanceWhenTaskCorruptedExceptionIsThrownForAnActiveTask
- shouldGetMainAndRestoreConsumerInstanceId
- shouldGetMainAndRestoreConsumerInstanceIdWithInternalTimeout
- shouldInjectProducerPerThreadUsingClientSupplierOnCreateIfEosV2Enabled
- shouldInjectSharedProducerForAllTasksUsingClientSupplierOnCreateIfEosDisabled
- shouldLogAndRecordSkippedMetricForDeserializationException
- shouldLogAndRecordSkippedRecordsForInvalidTimestamps
- shouldNotBlockWhenPollingInPartitionsAssignedStateWithoutStateUpdater
- shouldNotCauseExceptionIfNothingCommitted
- shouldNotCloseTaskAndRemoveFromTaskManagerIfInvalidPidMappingOccurredInCommitTransactionWhenSuspendingTasks
- shouldNotCloseTaskAndRemoveFromTaskManagerIfPidMappingIsInvalidInCommitTransactionWhenCommitting
- shouldNotCloseTaskAndRemoveFromTaskManagerIfProducerGotFencedInCommitTransactionWhenCommitting
- shouldNotCloseTaskAndRemoveFromTaskManagerIfProducerGotFencedInCommitTransactionWhenSuspendingTasks
- shouldNotCloseTaskAndRemoveFromTaskManagerIfProducerWasFencedWhileProcessing
- shouldNotCloseTaskProducerWhenSuspending
- shouldNotCommitBeforeTheCommitInterval
- shouldNotCommitNonRunningNonRestoringTasks
- shouldNotCreateStandbyTaskIfStateStoresHaveLoggingDisabled
- shouldNotCreateStandbyTaskWithoutStateStores
- shouldNotEnforceRebalanceWhenCurrentlyRebalancing
- shouldNotEnforceRebalanceWhenTaskCorruptedExceptionIsThrownForAnInactiveTask
- shouldNotProcessWhenPartitionRevoked
- shouldNotPurgeBeforeThePurgeInterval
- shouldNotRecordFailedStreamThread
- shouldNotReturnDataAfterTaskMigrated
- shouldNotThrowWhenStandbyTasksAssignedAndNoStateStoresForTopology
- shouldNotUpdateStandbyTaskWhenPaused
- shouldOnlyCompleteShutdownAfterRebalanceNotInProgress
- shouldOnlyShutdownOnce
- shouldProcessWhenPartitionAssigned
- shouldProcessWhenRunning
- shouldProcessWhenStarting
- shouldPunctuateActiveTask
- shouldPunctuateWithTimestampPreservedInProcessorContext
- shouldPurgeAfterPurgeInterval
- shouldRecordCommitLatency
- shouldRecordFailedStreamThread
- shouldRecoverFromInvalidOffsetExceptionOnRestoreAndFinishRestore
- shouldReinitializeRevivedTasksInAnyState
- shouldRespectNumIterationsInMainLoopWithoutProcessingThreads
- shouldRespectPollTimeInPartitionsAssignedStateWithStateUpdater
- shouldResumePollingForPartitionsWithAvailableSpaceBeforePolling
- shouldReturnActiveTaskMetadataWhileRunningState
- shouldReturnErrorIfMainConsumerInstanceIdNotInitialized
- shouldReturnErrorIfProducerInstanceIdNotInitialized
- shouldReturnErrorIfRestoreConsumerInstanceIdNotInitialized
- shouldReturnNullIfMainConsumerTelemetryDisabled
- shouldReturnNullIfProducerTelemetryDisabled
- shouldReturnNullIfRestoreConsumerTelemetryDisabled
- shouldReturnStandbyTaskMetadataWhileRunningState
- shouldShutdownTaskManagerOnClose
- shouldShutdownTaskManagerOnCloseWithoutStart
- shouldThrowTaskMigratedExceptionHandlingRevocation
- shouldThrowTaskMigratedExceptionHandlingTaskLost
- shouldTimeOutOnMainConsumerInstanceId
- shouldTimeOutOnProducerInstanceId
- shouldTimeOutOnRestoreConsumerInstanceId
- shouldTransmitTaskManagerMetrics
- shouldUpdateLagsAfterPolling
- shouldUpdateStandbyTask
- testGetTopicPartitionInfo
- testNamedTopologyWithStreamsProtocol
- testStreamsProtocolRunOnceWithProcessingThreads
- testStreamsProtocolRunOnceWithProcessingThreadsMissingSourceTopic
- testStreamsProtocolRunOnceWithoutProcessingThreads
- testStreamsProtocolRunOnceWithoutProcessingThreadsMissingSourceTopic
- testStreamsRebalanceDataWithClassicProtocol
- testStreamsRebalanceDataWithExtraCopartition
- testStreamsRebalanceDataWithStreamsProtocol
org.apache.kafka.streams.processor.internals.StreamThreadTotalBlockedTimeTest:
- shouldComputeTotalBlockedTime
org.apache.kafka.streams.processor.internals.StreamsAssignmentScaleTest:
- testFallbackPriorTaskAssignorLargeNumConsumers
- testFallbackPriorTaskAssignorLargePartitionCount
- testFallbackPriorTaskAssignorManyStandbys
- testFallbackPriorTaskAssignorManyThreadsPerClient
- testHighAvailabilityTaskAssignorLargeNumConsumers
- testHighAvailabilityTaskAssignorLargePartitionCount
- testHighAvailabilityTaskAssignorManyStandbys
- testHighAvailabilityTaskAssignorManyThreadsPerClient
- testStickyTaskAssignorLargeNumConsumers
- testStickyTaskAssignorLargePartitionCount
- testStickyTaskAssignorManyStandbys
- testStickyTaskAssignorManyThreadsPerClient
org.apache.kafka.streams.processor.internals.StreamsMetadataStateTest:
- shouldFailWhenIqQueriedWithCustomPartitionerReturningMultiplePartitions
- shouldGetAllStreamInstances
- shouldGetAllStreamsInstancesWithNoStores
- shouldGetAnyHostForGlobalStoreByKeyAndPartitionerIfMyHostUnknown
- shouldGetAnyHostForGlobalStoreByKeyIfMyHostUnknown
- shouldGetInstanceWithKey
- shouldGetInstanceWithKeyAndCustomPartitioner
- shouldGetInstanceWithKeyWithMergedStreams
- shouldGetInstancesForStoreName
- shouldGetLocalMetadataWithRightActiveStandbyInfo
- shouldGetQueryMetadataForGlobalStoreWithKey
- shouldGetQueryMetadataForGlobalStoreWithKeyAndPartitioner
- shouldHaveGlobalStoreInAllMetadata
- shouldNotReturnMutableReferenceToInternalAllMetadataCollection
- shouldNotThrowExceptionWhenOnChangeNotCalled
- shouldReturnAllMetadataThatRemainsValidAfterChange
- shouldReturnEmptyCollectionOnGetAllInstancesWithStoreWhenStoreDoesntExist
- shouldReturnNotAvailableWhenClusterIsEmpty
- shouldReturnNullOnGetWithKeyWhenStoreDoesntExist
- shouldThrowIfStoreNameIsNull
- shouldThrowIfStoreNameIsNullOnGetAllInstancesWithStore
- shouldThrowIfStreamPartitionerIsNull
- shouldThrowWhenKeyIsNull
- shouldThrowWhenSerializerIsNull
org.apache.kafka.streams.processor.internals.StreamsPartitionAssignorTest:
- shouldAddUserDefinedEndPointToSubscription
- shouldAssignEvenlyAcrossConsumersOneClientMultipleThreads
- shouldEncodeAssignmentErrorIfV1SubscriptionAndFutureSubscriptionIsMixed
- shouldEncodeAssignmentErrorIfV2SubscriptionAndFutureSubscriptionIsMixed
- shouldEncodeMissingSourceTopicError
- shouldGenerateTasksForAllCreatedPartitions
- shouldGetAssignmentConfigs
- shouldGetTime
- shouldInterleaveTasksByGroupIdDuringNewAssignment
- shouldMapUserEndPointToTopicPartitions
- shouldNotAddStandbyTaskPartitionsToPartitionsForHost
- shouldNotAssignTemporaryStandbyTask
- shouldNotFailOnBranchedMultiLevelRepartitionConnectedTopology
- shouldNotLoopInfinitelyOnMissingMetadataAndShouldNotCreateRelatedTasks
- shouldProduceMaximallyStickyAssignmentWhenMemberLeaves
- shouldProduceStickyAndBalancedAssignmentWhenNewTasksAreAdded
- shouldProduceStickyAndBalancedAssignmentWhenNothingChanges
- shouldProduceStickyEnoughAssignmentWhenNewMemberJoins
- shouldRequestCommittedOffsetsForPreexistingSourceChangelogs
- shouldRequestEndOffsetsForPreexistingChangelogs
- shouldReturnInterleavedAssignmentForOnlyFutureInstancesDuringVersionProbing
- shouldReturnInterleavedAssignmentWithUnrevokedPartitionsRemovedWhenNewConsumerJoins
- shouldReturnLowestAssignmentVersionForDifferentSubscriptionVersionsV1V2
- shouldReturnLowestAssignmentVersionForDifferentSubscriptionVersionsV1V3
- shouldReturnLowestAssignmentVersionForDifferentSubscriptionVersionsV2V3
- shouldSkipListOffsetsRequestForNewlyCreatedChangelogTopics
- shouldSupportOnlyCooperativeRebalancingProtocol
- shouldThrowExceptionIfApplicationServerConfigIsNotHostPortPair
- shouldThrowExceptionIfApplicationServerConfigPortIsNotAnInteger
- shouldThrowIllegalStateExceptionIfAnyPartitionsMissingFromChangelogEndOffsets
- shouldThrowIllegalStateExceptionIfAnyTopicsMissingFromChangelogEndOffsets
- shouldThrowKafkaExceptionIfReferenceContainerConfigIsNotTaskManagerInstance
- shouldThrowKafkaExceptionIfReferenceContainerNotConfigured
- shouldThrowOnEagerSubscription
- shouldThrowTaskAssignmentExceptionWhenUnableToResolvePartitionCount
- shouldThrowTimeoutExceptionWhenCreatingChangelogTopicsTimesOut
- shouldThrowTimeoutExceptionWhenCreatingRepartitionTopicsTimesOut
- shouldTriggerImmediateRebalanceOnHostInfoChange
- shouldTriggerImmediateRebalanceOnTasksRevoked
- shouldUpdateClusterMetadataAndHostInfoOnAssignment
- testAssignBasic
- testAssignEmptyMetadata
- testAssignWithInternalTopicThatsSourceIsAnotherInternalTopic
- testAssignWithInternalTopics
- testAssignWithNewTasks
- testAssignWithStandbyReplicas
- testAssignWithStandbyReplicasAndLoggingDisabled
- testAssignWithStandbyReplicasAndStatelessTasks
- testAssignWithStandbyReplicasBalanceDense
- testAssignWithStandbyReplicasBalanceSparse
- testAssignWithStandbyReplicasBalanceWithStatelessTasks
- testAssignWithStates
- testClientTags
- testCooperativeSubscription
- testOnAssignment
- testUniqueField
- testUniqueFieldOverflow
org.apache.kafka.streams.processor.internals.StreamsProducerTest:
- shouldAbortTxOnEosAbort
- shouldBeginTxOnEosCommit
- shouldBeginTxOnEosSend
- shouldCloseExistingProducerOnResetProducer
- shouldCommitTxOnEosCommit
- shouldCommitTxWithConsumerGroupMetadataOnEosCommit
- shouldComputeTotalBlockedTime
- shouldComputeTotalBlockedTimeAfterReset
- shouldContinueTxnSecondEosSend
- shouldFailIfLogContextIsNull
- shouldFailIfProcessingModeIsNull
- shouldFailIfProducerIsNull
- shouldFailIfTimeIsNull
- shouldFailOnAbortIfEosDisabled
- shouldFailOnCommitIfEosDisabled
- shouldFailOnEosAbortTxFatal
- shouldFailOnEosBeginTxnFatal
- shouldFailOnEosCommitTxFatal
- shouldFailOnEosInitFatal
- shouldFailOnEosSendOffsetFatal
- shouldFailOnInitTxIfEosDisabled
- shouldFailOnMaybeBeginTransactionIfTransactionsNotInitializedForEos
- shouldFailOnResetProducerForAtLeastOnce
- shouldFailOnSendFatal
- shouldForwardCallToClose
- shouldForwardCallToFlush
- shouldForwardCallToMetrics
- shouldForwardCallToPartitionsFor
- shouldForwardRecordButNotCommitOnEosSend
- shouldForwardRecordOnSend
- shouldInitTxOnEos
- shouldNotBeginTxOnSendIfEosDisable
- shouldNotInitTxIfEosDisable
- shouldResetTransactionInFlightOnClose
- shouldResetTransactionInFlightOnReset
- shouldResetTransactionInitializedOnResetProducer
- shouldSendOffsetToTxOnEosCommit
- shouldSetNewProducerOnResetProducer
- shouldSkipAbortTxOnEosAbortIfNotTxInFlight
- shouldSwallowExceptionOnEosAbortTxInvalidEpoch
- shouldSwallowExceptionOnEosAbortTxInvalidPidMapping
- shouldSwallowExceptionOnEosAbortTxProducerFenced
- shouldThrowStreamsExceptionOnEosAbortTxError
- shouldThrowStreamsExceptionOnEosCommitTxError
- shouldThrowStreamsExceptionOnEosInitError
- shouldThrowStreamsExceptionOnEosSendOffsetError
- shouldThrowStreamsExceptionOnSendError
- shouldThrowTaskMigrateExceptionOnEosBeginTxnError
- shouldThrowTaskMigrateExceptionOnEosBeginTxnFenced
- shouldThrowTaskMigrateExceptionOnEosSendOffsetInvalidEpoch
- shouldThrowTaskMigrateExceptionOnEosSendOffsetInvalidPidMapping
- shouldThrowTaskMigrateExceptionOnEosSendOffsetProducerFenced
- shouldThrowTaskMigratedExceptionOnEosCommitWithInvalidEpoch
- shouldThrowTaskMigratedExceptionOnEosCommitWithInvalidPidMapping
- shouldThrowTaskMigratedExceptionOnEosCommitWithProducerFenced
- shouldThrowTaskMigratedExceptionOnEosSendInvalidEpoch
- shouldThrowTaskMigratedExceptionOnEosSendPInvalidPidMapping
- shouldThrowTaskMigratedExceptionOnEosSendProducerFenced
- shouldThrowTaskMigratedExceptionOnEosSendUnknownPid
- shouldThrowTimeoutExceptionOnEosInitTxTimeout
org.apache.kafka.streams.processor.internals.StreamsRebalanceListenerTest:
- shouldHandleAssignedPartitions
- shouldHandleLostPartitions
- shouldHandleRevokedPartitions
- shouldNotHandleEmptySetOfRevokedPartitions
- shouldNotHandleRevokedPartitionsIfStateCannotTransitToPartitionRevoked
- shouldSendShutdown
- shouldSwallowVersionProbingError
- shouldThrowMissingSourceTopicException
- shouldThrowTaskAssignmentException
- shouldThrowTaskAssignmentExceptionOnUnrecognizedErrorCode
org.apache.kafka.streams.processor.internals.SynchronizedPartitionGroupTest:
- testAddRawRecords
- testClear
- testClose
- testHeadRecordOffset
- testNextRecord
- testNumBuffered
- testNumBufferedWithTopicPartition
- testPartitionTimestamp
- testPartitions
- testReadyToProcess
- testSetPartitionTime
- testStreamTime
- testUpdateLags
- testUpdatePartitions
org.apache.kafka.streams.processor.internals.TaskAndActionTest:
- shouldCreateAddTaskAction
- shouldCreateRemoveTaskAction
- shouldThrowIfAddTaskActionIsCreatedWithNullTask
- shouldThrowIfRemoveTaskActionIsCreatedWithNullFuture
- shouldThrowIfRemoveTaskActionIsCreatedWithNullTaskId
org.apache.kafka.streams.processor.internals.TaskExecutionMetadataTest:
- testCanProcessWithoutNamedTopologies
- testNamedTopologiesCanBackoff
- testNamedTopologiesCanBePausedIndependently
- testNamedTopologiesCanBeStartedPaused
org.apache.kafka.streams.processor.internals.TaskExecutorTest:
- testCommitWithOpenTransactionButNoOffsetsEOSV2
- testPunctuateWithPause
org.apache.kafka.streams.processor.internals.TaskManagerTest:
- shouldAddFailedActiveTaskToRecycleDuringAssignmentToTaskRegistry
- shouldAddFailedActiveTasksToReassignWithDifferentInputPartitionsDuringAssignmentToTaskRegistry
- shouldAddFailedStandbyTaskToRecycleDuringAssignmentToTaskRegistry
- shouldAddNewActiveTasks
- shouldAddNonResumedSuspendedTasks
- shouldAddRecycledStandbyTasksFromActiveToPendingTasksToInitWithStateUpdaterEnabled
- shouldAddRecycledStandbyTasksFromActiveToTaskRegistryWithStateUpdaterDisabled
- shouldAddSubscribedTopicsFromAssignmentToTopologyMetadata
- shouldAddTasksToStateUpdater
- shouldAssignActiveTaskInTasksRegistryToBeClosedCleanlyWithStateUpdaterEnabled
- shouldAssignActiveTaskInTasksRegistryToUpdateInputPartitionsWithStateUpdaterEnabled
- shouldAssignMultipleTasksInStateUpdater
- shouldAssignMultipleTasksInTasksRegistryWithStateUpdaterEnabled
- shouldClassifyExistingTasksWithoutStateUpdater
- shouldCleanAndReviveCorruptedStandbyTasksBeforeCommittingNonCorruptedTasks
- shouldCloseActiveTasksAndIgnoreExceptionsOnUncleanShutdown
- shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdownWithAlos
- shouldCloseActiveTasksAndPropagateExceptionsOnCleanShutdownWithExactlyOnceV2
- shouldCloseActiveTasksAndPropagateStreamsProducerExceptionsOnCleanShutdown
- shouldCloseActiveTasksWhenHandlingLostTasks
- shouldCloseActiveUnassignedSuspendedTasksWhenClosingRevokedTasks
- shouldCloseAndReviveUncorruptedTasksWhenTimeoutExceptionThrownFromCommitDuringHandleCorruptedWithEOS
- shouldCloseAndReviveUncorruptedTasksWhenTimeoutExceptionThrownFromCommitDuringRevocationWithAlos
- shouldCloseAndReviveUncorruptedTasksWhenTimeoutExceptionThrownFromCommitDuringRevocationWithEOS
- shouldCloseAndReviveUncorruptedTasksWhenTimeoutExceptionThrownFromCommitWithAlos
- shouldCloseCleanTasksPendingInitOnPartitionLost
- shouldCloseCleanWhenRemoveAllActiveTasksFromStateUpdaterOnPartitionLost
- shouldCloseDirtyActiveUnassignedTasksWhenErrorCleanClosingTask
- shouldCloseDirtyWhenRemoveFailedActiveTasksFromStateUpdaterOnPartitionLost
- shouldCloseStandbyTasksOnShutdown
- shouldCloseStandbyUnassignedTasksWhenCreatingNewTasks
- shouldCloseTasksWhenRemoveFailedActiveTasksFromStateUpdaterOnPartitionLost
- shouldCollectFailedTaskFromStateUpdaterAndRethrow
- shouldCommitActiveAndStandbyTasks
- shouldCommitAllActiveTasksThatNeedCommittingOnHandleRevocationWithEosV2
- shouldCommitAllNeededTasksOnHandleRevocation
- shouldCommitNonCorruptedTasksOnTaskCorruptedException
- shouldCommitProvidedTasksIfNeeded
- shouldCommitViaConsumerIfEosDisabled
- shouldCommitViaProducerIfEosV2Enabled
- shouldComputeOffsetSumForNonRunningActiveTask
- shouldComputeOffsetSumForRestoringActiveTaskWithStateUpdater
- shouldComputeOffsetSumForRestoringStandbyTaskWithStateUpdater
- shouldComputeOffsetSumForRunningStatefulTaskAndRestoringTaskWithStateUpdater
- shouldComputeOffsetSumForStandbyTask
- shouldComputeOffsetSumForUnassignedTaskWeCanLock
- shouldComputeOffsetSumFromCheckpointFileForClosedTask
- shouldComputeOffsetSumFromCheckpointFileForUninitializedTask
- shouldConvertActiveTaskToStandbyTask
- shouldConvertStandbyTaskToActiveTask
- shouldCreateActiveTaskDuringAssignment
- shouldCreateStandbyTaskDuringAssignment
- shouldFailOnCommitFatal
- shouldFirstHandleTasksInStateUpdaterThenSuspendedActiveTasksInTaskRegistry
- shouldHandleExceptionThrownDuringRecyclingActiveTask
- shouldHandleExceptionThrownDuringRecyclingStandbyTask
- shouldHandleRebalanceEvents
- shouldHandleTimeoutExceptionInTransitRestoredTaskToRunning
- shouldHaveRemainingPartitionsUncleared
- shouldIgnorePurgeDataErrors
- shouldInitialiseNewStandbyTasks
- shouldInitializeNewActiveTasks
- shouldKeepReassignedActiveTaskInStateUpdater
- shouldKeepReassignedStandbyTaskInStateUpdater
- shouldListNotPausedTasks
- shouldLockActiveOnHandleAssignmentWithProcessingThreads
- shouldLockAffectedTasksOnHandleRevocation
- shouldLockAllTasksOnCorruptionWithProcessingThreads
- shouldLockCommitableTasksOnCorruptionWithProcessingThreads
- shouldLockTasksOnClose
- shouldMaybeCommitAllActiveTasksThatNeedCommit
- shouldMoveReassignedSuspendedActiveTaskToStateUpdater
- shouldNeverUpdateInputPartitionsOfStandbyTaskInStateUpdater
- shouldNotAttemptToCommitInHandleCorruptedDuringARebalance
- shouldNotCommitActiveAndStandbyTasksWhileRebalanceInProgress
- shouldNotCommitCreatedTasksOnRevocationOrClosure
- shouldNotCommitIfNoRevokedTasksNeedCommitting
- shouldNotCommitIfNoRevokedTasksNeedCommittingWithEOSv2
- shouldNotCommitNonCorruptedRestoringActiveTasksAndCommitRunningStandbyTasksWithStateUpdaterDisabled
- shouldNotCommitNonCorruptedRestoringActiveTasksAndNotCommitRunningStandbyTasksWithStateUpdaterEnabled
- shouldNotCommitNonRunningNonCorruptedTasks
- shouldNotCommitOffsetsIfOnlyStandbyTasksAssigned
- shouldNotCommitOnHandleAssignmentIfNoTaskClosed
- shouldNotCommitOnHandleAssignmentIfOnlyStandbyTaskClosed
- shouldNotCompleteRestorationIfTaskCannotCompleteRestoration
- shouldNotCompleteRestorationIfTasksCannotInitialize
- shouldNotFailForTimeoutExceptionOnConsumerCommit
- shouldNotFailOnTimeoutException
- shouldNotLockAnythingIfStateDirIsEmpty
- shouldNotPauseReadyTasksWithStateUpdaterOnRebalanceComplete
- shouldNotReportOffsetSumsAndReleaseLockForUnassignedTaskWithoutCheckpoint
- shouldNotReportOffsetSumsForTaskWeCantLock
- shouldNotReturnStateUpdaterTasksInOwnedTasks
- shouldNotRevokeStandbyTaskInStateUpdaterOnRevocation
- shouldNotSendPurgeDataIfPreviousNotDone
- shouldNotSuspendActiveTaskWithoutRevokedInputPartitionsInStateUpdater
- shouldNotUpdateExistingStandbyTaskIfStandbyIsReassignedWithSameInputPartitionWithoutStateUpdater
- shouldOnlyCommitRevokedStandbyTaskAndPropagatePrepareCommitException
- shouldPassUpIfExceptionDuringSuspend
- shouldPauseAllTopicsWithoutStateUpdaterOnRebalanceComplete
- shouldPinOffsetSumToLongMaxValueInCaseOfOverflow
- shouldProcessActiveTasks
- shouldPropagateExceptionFromActiveCommit
- shouldPropagateExceptionFromStandbyCommit
- shouldPropagateKafkaExceptionsInPunctuateActiveTasks
- shouldPropagateTaskMigratedExceptionsInProcessActiveTasks
- shouldPropagateTaskMigratedExceptionsInPunctuateActiveTasks
- shouldPunctuateActiveTasks
- shouldReAddRevivedTasksToStateUpdater
- shouldReInitializeStreamsProducerOnHandleLostAllIfEosV2Enabled
- shouldRecycleActiveTaskInStateUpdater
- shouldRecycleStandbyTaskInStateUpdater
- shouldRecycleStartupTasksFromStateDirectoryAsActive
- shouldRecycleStartupTasksFromStateDirectoryAsActiveWithStateUpdater
- shouldReleaseLockForUnassignedTasksAfterRebalance
- shouldReleaseLockForUnassignedTasksAfterRebalanceWithStateUpdater
- shouldRemoveUnusedActiveTaskFromStateUpdaterAndCloseCleanly
- shouldRemoveUnusedFailedActiveTaskFromStateUpdaterAndCloseDirty
- shouldRemoveUnusedFailedStandbyTaskFromStateUpdaterAndCloseDirty
- shouldRemoveUnusedStandbyTaskFromStateUpdaterAndCloseCleanly
- shouldReportLatestOffsetAsOffsetSumForRunningTask
- shouldResumeActiveRunningTaskInTasksRegistryWithStateUpdaterEnabled
- shouldResumeActiveSuspendedTaskInTasksRegistryAndAddToStateUpdater
- shouldResumePollingForPartitionsWithAvailableSpaceForAllActiveTasks
- shouldRethrowRuntimeExceptionInInitTaskWithStateUpdater
- shouldRethrowStreamsExceptionFromStateUpdater
- shouldRethrowTaskCorruptedExceptionFromInitialization
- shouldRethrowTaskCorruptedExceptionFromStateUpdater
- shouldRetryInitializationWhenLockExceptionInStateUpdater
- shouldRetryInitializationWithBackoffWhenInitializationFails
- shouldReturnCorrectBooleanWhenTryingToCompleteRestorationWithStateUpdater
- shouldReturnFalseFromCheckStateUpdaterIfActiveTasksAreNotRestoringAndNoPendingTaskToRecycleButPendingTasksToInit
- shouldReturnFalseFromCheckStateUpdaterIfActiveTasksAreRestoring
- shouldReturnFalseWhenThereAreStillNonRunningTasks
- shouldReturnRunningTasksStateUpdaterTasksAndTasksToInitInAllTasks
- shouldReturnTrueFromCheckStateUpdaterIfActiveTasksAreNotRestoringAndNoPendingInit
- shouldReviveCorruptTasks
- shouldReviveCorruptTasksEvenIfTheyCannotCloseClean
- shouldSendPurgeData
- shouldShutDownStateUpdaterAndCloseDirtyTasksFailedDuringRemoval
- shouldShutDownStateUpdaterAndCloseFailedTasksDirty
- shouldShutdownSchedulingTaskManager
- shouldSkipUnknownOffsetsWhenComputingOffsetSum
- shouldStartStateUpdaterOnInit
- shouldStreamsExceptionOnCommitError
- shouldSuspendActiveTaskWithRevokedInputPartitionsInStateUpdater
- shouldSuspendActiveTasksDuringRevocation
- shouldSuspendAllRevokedActiveTasksAndPropagateSuspendException
- shouldSuspendAllTasksButSkipCommitIfSuspendingFailsDuringRevocation
- shouldSuspendMultipleActiveTasksWithRevokedInputPartitionsInStateUpdater
- shouldThrowDuringAssignmentIfStandbyTaskToCloseIsFoundInTasksRegistryWithStateUpdaterEnabled
- shouldThrowDuringAssignmentIfStandbyTaskToRecycleIsFoundInTasksRegistryWithStateUpdaterEnabled
- shouldThrowDuringAssignmentIfStandbyTaskToUpdateInputPartitionsIsFoundInTasksRegistryWithStateUpdaterEnabled
- shouldThrowIfRevokingTasksInStateUpdaterFindsFailedTasks
- shouldThrowRuntimeExceptionWhenEncounteredUnknownExceptionDuringTaskClose
- shouldThrowSameKafkaExceptionWhenEncounteredDuringTaskClose
- shouldThrowTaskCorruptedExceptionForTimeoutExceptionOnCommitWithEosV2
- shouldThrowTaskMigratedExceptionOnCommitFailed
- shouldThrowTaskMigratedWhenAllTaskCloseExceptionsAreTaskMigrated
- shouldTransitMultipleRestoredTasksToRunning
- shouldTransitRestoredTaskToRunning
- shouldTransmitProducerMetrics
- shouldTryToLockValidTaskDirsAtRebalanceStart
- shouldUnlockEmptyDirsAtRebalanceStart
- shouldUpdateExistingStandbyTaskIfStandbyIsReassignedWithDifferentInputPartitionWithoutStateUpdater
- shouldUpdateInputPartitionOfActiveTaskInStateUpdater
- shouldUpdateInputPartitionsAfterRebalance
- shouldUpdateLagForAllActiveTasks
- shouldUseStartupTasksFromStateDirectoryAsStandby
- shouldUseStartupTasksFromStateDirectoryAsStandbyWithStateUpdater
- shouldWrapRuntimeExceptionsInProcessActiveTasksAndSetTaskId
org.apache.kafka.streams.processor.internals.TaskMetadataImplTest:
- shouldBeEqualsIfOnlyDifferInCommittedOffsets
- shouldBeEqualsIfOnlyDifferInEndOffsets
- shouldBeEqualsIfOnlyDifferInIdlingTime
- shouldBeEqualsIfSameObject
- shouldNotAllowModificationOfInternalStateViaGetters
- shouldNotBeEqualsIfDifferInTaskID
- shouldNotBeEqualsIfDifferInTopicPartitions
org.apache.kafka.streams.processor.internals.TasksTest:
- shouldAddFailedTask
- shouldCheckStateWhenRemoveTask
- shouldClearFailedTask
- shouldDrainPendingTasksToCreate
- shouldKeepAddedTasks
- shouldRemoveFailedTask
- shouldVerifyIfPendingActiveTaskToInitAreDrained
- shouldVerifyIfPendingTaskToInitExist
org.apache.kafka.streams.processor.internals.ThreadMetadataImplTest:
- shouldBeEqualIfSameObject
- shouldNotAllowModificationOfInternalStateViaGetters
- shouldNotBeEqualIfDifferInActiveTasks
- shouldNotBeEqualIfDifferInAdminClientId
- shouldNotBeEqualIfDifferInClientId
- shouldNotBeEqualIfDifferInConsumerClientId
- shouldNotBeEqualIfDifferInProducerClientIds
- shouldNotBeEqualIfDifferInStandByTasks
- shouldNotBeEqualIfDifferInThreadName
- shouldNotBeEqualIfDifferInThreadState
org.apache.kafka.streams.processor.internals.TopicPartitionMetadataTest:
- shouldDecodeEmptyStringVersionTwo
- shouldDecodeVersionOne
- shouldEncodeDecodeEmptyMetaVersionTwo
- shouldEncodeDecodeVersionTwo
- shouldGetPartitionTimeAndProcessorMeta
- shouldReturnUnknownTimestampIfInvalidMetadata
- shouldReturnUnknownTimestampIfUnknownVersion
org.apache.kafka.streams.processor.internals.TopologyMetadataTest:
- testPauseResume
- testSubtopologyCompare
org.apache.kafka.streams.processor.internals.WriteConsistencyVectorTest:
- shouldSendConsistencyVectorToChangelogTopic
org.apache.kafka.streams.processor.internals.assignment.AssignmentInfoTest:
- nextRebalanceTimeShouldBeMaxValueByDefault
- shouldDecodeDefaultNextRebalanceTime
- shouldEncodeAndDecodeNextRebalanceTime
- shouldEncodeAndDecodeSmallerCommonlySupportedVersion
- shouldEncodeAndDecodeVersion1
- shouldEncodeAndDecodeVersion10
- shouldEncodeAndDecodeVersion10WithNamedTopologies
- shouldEncodeAndDecodeVersion2
- shouldEncodeAndDecodeVersion3
- shouldEncodeAndDecodeVersion4
- shouldEncodeAndDecodeVersion5
- shouldEncodeAndDecodeVersion6
- shouldEncodeAndDecodeVersion7
- shouldEncodeAndDecodeVersion8
- shouldEncodeAndDecodeVersion9
- shouldNotEncodeAndDecodeNamedTopologiesWithOlderVersion
- shouldThrowForUnknownVersion1
- shouldThrowForUnknownVersion2
- shouldUseLatestSupportedVersionByDefault
org.apache.kafka.streams.processor.internals.assignment.AssignorConfigurationTest:
- configsShouldRejectZeroWarmups
- shouldSupportAllUpgradeFromVersionsFromCooperativeRebalancingOn
org.apache.kafka.streams.processor.internals.assignment.ClientStateTest:
- previousStateConstructorShouldCreateAValidObject
- shouldAddActiveTasksToBothAssignedAndActive
- shouldAddPreviousActiveTasksToPreviousAssignedAndPreviousActive
- shouldAddPreviousStandbyTasksToPreviousAssignedAndPreviousStandby
- shouldAddStandbyTasksToBothStandbyAndAssigned
- shouldAddTasksInOffsetSumsMapToPrevStandbyTasks
- shouldAddTasksWithLatestOffsetToPrevActiveTasks
- shouldComputeTaskLags
- shouldCopyState
- shouldFilterOutUnrecognizedPartitionsAndInitializePrevTasksWhenUsingNamedTopologies
- shouldHaveAssignedTaskIfActiveTaskAssigned
- shouldHaveAssignedTaskIfStandbyTaskAssigned
- shouldHaveMoreAvailableCapacityWhenCapacityHigherAndSameAssignedTaskCount
- shouldHaveMoreAvailableCapacityWhenCapacityIsTheSameButAssignedTasksIsLess
- shouldHaveMoreAvailableCapacityWhenCapacityTheSameButFewerAssignedTasks
- shouldHaveNotReachedCapacityWhenAssignedTasksLessThanCapacity
- shouldHaveReachedCapacityWhenAssignedTasksGreaterThanOrEqualToCapacity
- shouldHaveUnfulfilledQuotaWhenActiveTaskSizeLessThanCapacityTimesTasksPerThread
- shouldNotHaveAssignedTaskIfTaskNotAssigned
- shouldNotHaveUnfulfilledQuotaWhenActiveTaskSizeGreaterEqualThanCapacityTimesTasksPerThread
- shouldNotModifyActiveView
- shouldNotModifyAssignedView
- shouldNotModifyStandbyView
- shouldNotTryToLookupTasksThatWerePreviouslyAssignedButNoLongerExist
- shouldRefuseActiveAndStandbyTask
- shouldRefuseDoubleActiveTask
- shouldRefuseDoubleStandbyTask
- shouldRefuseStandbyAndActiveTask
- shouldRefuseToUnassignActiveTaskAsStandby
- shouldRefuseToUnassignNotAssignedActiveTask
- shouldRefuseToUnassignNotAssignedStandbyTask
- shouldRefuseToUnassignStandbyTaskAsActive
- shouldReturnAssignedTasksForConsumer
- shouldReturnClientTags
- shouldReturnEmptyClientTagsMapByDefault
- shouldReturnEndOffsetSumForLagOfTaskWeDidNotPreviouslyOwn
- shouldReturnEndOffsetSumIfOffsetSumIsGreaterThanEndOffsetSum
- shouldReturnLatestOffsetForLagOfPreviousActiveRunningTask
- shouldReturnPreviousActiveStandbyTasksForConsumer
- shouldReturnPreviousStatefulTasksForConsumer
- shouldReturnUnknownOffsetSumForLagOfTaskWithUnknownOffset
- shouldSetProcessId
- shouldThrowIllegalStateExceptionIfAssignedTasksForConsumerToNonClientAssignActive
- shouldThrowIllegalStateExceptionIfAttemptingToInitializeNonEmptyPrevTaskSets
- shouldThrowIllegalStateExceptionIfCapacityOfOtherClientStateIsZero
- shouldThrowIllegalStateExceptionIfCapacityOfThisClientStateIsZero
- shouldThrowIllegalStateExceptionIfTaskLagsMapIsNotEmpty
- shouldThrowIllegalStateExceptionOnLagForUnknownTask
- shouldThrowWhenSomeOwnedPartitionsAreNotRecognizedWhenInitializingPrevTasks
- shouldUnassignActiveTask
- shouldUnassignStandbyTask
- shouldUseMultiplesOfCapacityToDetermineClientWithMoreAvailableCapacity
org.apache.kafka.streams.processor.internals.assignment.ClientTagAwareStandbyTaskAssignorTest:
- shouldDeclineSingleTaskMoveWhenReduceClientTagCount
- shouldDeclineTaskMovementWhenClientTagsDoNotMatch
- shouldDistributeClientsOnDifferentZoneTagsEvenWhenClientsReachedCapacity
- shouldDistributeStandbyTasksOnLeastLoadedClientsWhenClientsAreNotOnDifferentTagDimensions
- shouldDistributeStandbyTasksUsingFunctionAndSupplierTags
- shouldDistributeStandbyTasksWhenActiveTasksAreLocatedOnSameCluster
- shouldDistributeStandbyTasksWhenActiveTasksAreLocatedOnSameZone
- shouldDoThePartialRackAwareness
- shouldHandleOverlappingTagValuesBetweenDifferentTagKeys
- shouldIgnoreTagsThatAreNotPresentInRackAwareness
- shouldNotAssignStandbyTasksIfThereAreNoEnoughClients
- shouldNotAssignStatelessTasksToAnyClients
- shouldPermitSingleTaskMoveWhenClientTagMatch
- shouldPermitSingleTaskMoveWhenDifferentClientTagCountNotChange
- shouldPermitTaskMovementWhenClientTagsMatch
- shouldRemoveClientToRemainingStandbysAndNotPopulatePendingStandbyTasksToClientIdWhenAllStandbyTasksWereAssigned
- shouldUpdateClientToRemainingStandbysAndPendingStandbyTasksToClientIdWhenNotAllStandbyTasksWereAssigned
org.apache.kafka.streams.processor.internals.assignment.ConstrainedPrioritySetTest:
- shouldApplyPollFilter
- shouldNotRetainDuplicates
- shouldOnlyReturnValidClients
- shouldReturnLeastLoadedClient
- shouldReturnNull
- shouldReturnOnlyClient
org.apache.kafka.streams.processor.internals.assignment.CustomStickyTaskAssignorTest:
- largeAssignmentShouldTerminateWithinAcceptableTime
- shouldAssignActiveAndStandbyTasks
- shouldAssignAtLeastOneTaskToEachClientIfPossible
- shouldAssignBasedOnCapacity
- shouldAssignBasedOnCapacityWhenMultipleClientHaveStandbyTasks
- shouldAssignEachActiveTaskToOneClientWhenMoreClientsThanTasks
- shouldAssignMoreTasksToClientWithMoreCapacity
- shouldAssignMultipleReplicasOfStandbyTask
- shouldAssignMultipleStandbys
- shouldAssignOneActiveTaskToEachProcessWhenTaskCountSameAsProcessCount
- shouldAssignStandbyTasksToDifferentClientThanCorrespondingActiveTaskIsAssignedTo
- shouldAssignTasksEvenlyWithUnequalTopicGroupSizes
- shouldAssignTasksToClientWithPreviousStandbyTasks
- shouldAssignTopicGroupIdEvenlyAcrossClientsWithNoStandByTasks
- shouldAssignTopicGroupIdEvenlyAcrossClientsWithStandByTasks
- shouldBalanceActiveAndStandbyTasksAcrossAvailableClients
- shouldEvenlyDistributeByTaskIdAndPartition
- shouldKeepActiveTaskStickinessWhenMoreClientThanActiveTasks
- shouldMigrateActiveTasksToNewProcessWithoutChangingAllAssignments
- shouldNotAssignStandbyTaskReplicasWhenNoClientAvailableWithoutHavingTheTaskAssigned
- shouldNotHaveSameAssignmentOnAnyTwoHosts
- shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks
- shouldNotMigrateActiveTaskToOtherProcess
org.apache.kafka.streams.processor.internals.assignment.FallbackPriorTaskAssignorTest:
- shouldViolateBalanceToPreserveActiveTaskStickiness
org.apache.kafka.streams.processor.internals.assignment.GraphTest:
- testBasic
- testDeterministic
- testDisconnectedGraph
- testDisconnectedGraphCrossSourceSink
- testInvalidFlow
- testInvalidOperation
- testInvalidSink
- testInvalidSource
- testJustSourceSink
- testMaxFlowBoundBySinkEdges
- testMaxFlowBoundBySourceEdges
- testMaxFlowOnlySourceAndSink
- testMinCostDetectNodeNotInNegativeCycle
- testMinCostFlow
- testMissingSource
- testNullNode
- testResidualGraph
org.apache.kafka.streams.processor.internals.assignment.HighAvailabilityTaskAssignorTest:
- shouldAssignActiveStatefulTasksEvenlyOverClientsAndStreamThreadsWithEqualStreamThreadsPerClientAsTasks
- shouldAssignActiveStatefulTasksEvenlyOverClientsWhereNumberOfClientsIntegralDivisorOfNumberOfTasks
- shouldAssignActiveStatefulTasksEvenlyOverClientsWhereNumberOfClientsNotIntegralDivisorOfNumberOfTasks
- shouldAssignActiveStatefulTasksEvenlyOverClientsWhereNumberOfThreadsIntegralDivisorOfNumberOfTasks
- shouldAssignActiveStatefulTasksEvenlyOverClientsWithMoreClientsThanTasks
- shouldAssignActiveStatefulTasksEvenlyOverStreamThreadsButBestEffortOverClients
- shouldAssignActiveStatefulTasksEvenlyOverUnevenlyDistributedStreamThreads
- shouldAssignActiveTasksToNotCaughtUpClientIfNoneExist
- shouldAssignRandomInput
- shouldAssignStandbysForStatefulTasks
- shouldAssignToMostCaughtUpIfActiveTasksWasNotOnCaughtUpClient
- shouldAssignWarmUpTasksIfStatefulActiveTasksBalancedOverStreamThreadsButNotOverClients
- shouldAssignWarmupReplicasEvenIfNoStandbyReplicasConfigured
- shouldBeStickyForActiveAndStandbyTasksWhileWarmingUp
- shouldComputeNewAssignmentIfActiveTasksWasNotOnCaughtUpClient
- shouldComputeNewAssignmentIfThereAreUnassignedActiveTasks
- shouldComputeNewAssignmentIfThereAreUnassignedStandbyTasks
- shouldDistributeStatefulActiveTasksToAllClients
- shouldDistributeStatelessTasksEvenlyOverClientsWithEqualStreamThreadsPerClientAsTasksAndNoStatefulTasks
- shouldDistributeStatelessTasksEvenlyOverClientsWithLessStreamThreadsPerClientAsTasksAndNoStatefulTasks
- shouldDistributeStatelessTasksEvenlyOverClientsWithUnevenlyDistributedStreamThreadsAndNoStatefulTasks
- shouldDistributeStatelessTasksEvenlyWithPreviousAssignmentAndNoStatefulTasks
- shouldDistributeStatelessTasksToBalanceTotalTaskLoad
- shouldEvenlyAssignActiveStatefulTasksIfClientsAreWarmedUpToBalanceTaskOverClients
- shouldNotAssignAnyStandbysWithInsufficientCapacity
- shouldNotAssignMoreThanMaxWarmupReplicas
- shouldNotAssignMoreThanMaxWarmupReplicasWithStandbys
- shouldNotAssignStandbysForStatelessTasks
- shouldNotAssignWarmupAndStandbyToTheSameClient
- shouldRemainOriginalAssignmentWithoutTrafficCostForMinCostStrategy
- shouldReturnFalseIfNoWarmupTasksAreAssigned
- shouldReturnFalseIfPreviousAssignmentIsReused
- shouldReturnTrueIfWarmupTasksAreAssigned
- shouldSkipWarmupsWhenAcceptableLagIsMax
org.apache.kafka.streams.processor.internals.assignment.KafkaStreamsAssignmentTest:
- shouldHaveReadableString
org.apache.kafka.streams.processor.internals.assignment.KafkaStreamsStateTest:
- shouldCorrectlyReturnTasksByLag
- shouldThrowExceptionOnLagOperationsIfLagsWereNotComputed
org.apache.kafka.streams.processor.internals.assignment.LegacyStickyTaskAssignorTest:
- shouldAssignActiveAndStandbyTasks
- shouldAssignAtLeastOneTaskToEachClientIfPossible
- shouldAssignBasedOnCapacity
- shouldAssignBasedOnCapacityWhenMultipleClientHaveStandbyTasks
- shouldAssignEachActiveTaskToOneClientWhenMoreClientsThanTasks
- shouldAssignMoreTasksToClientWithMoreCapacity
- shouldAssignMultipleReplicasOfStandbyTask
- shouldAssignNewTasksToNewClientWhenPreviousTasksAssignedToOldClients
- shouldAssignOneActiveTaskToEachProcessWhenTaskCountSameAsProcessCount
- shouldAssignRandomInput
- shouldAssignStandbyTasksToDifferentClientThanCorrespondingActiveTaskIsAssignedTo
- shouldAssignTasksEvenlyWithUnequalTopicGroupSizes
- shouldAssignTasksNotPreviouslyActiveToMultipleNewClients
- shouldAssignTasksNotPreviouslyActiveToNewClient
- shouldAssignTasksToClientWithPreviousStandbyTasks
- shouldAssignTasksToNewClient
- shouldAssignTasksToNewClientWithoutFlippingAssignmentBetweenExistingAndBouncedClients
- shouldAssignTasksToNewClientWithoutFlippingAssignmentBetweenExistingClients
- shouldAssignTopicGroupIdEvenlyAcrossClientsWithNoStandByTasks
- shouldAssignTopicGroupIdEvenlyAcrossClientsWithStandByTasks
- shouldBalanceActiveAndStandbyTasksAcrossAvailableClients
- shouldEvenlyDistributeByTaskIdAndPartition
- shouldKeepActiveTaskStickinessWhenMoreClientThanActiveTasks
- shouldMigrateActiveTasksToNewProcessWithoutChangingAllAssignments
- shouldMoveMinimalNumberOfTasksWhenPreviouslyAboveCapacityAndNewClientAdded
- shouldNotAssignStandbyTaskReplicasWhenNoClientAvailableWithoutHavingTheTaskAssigned
- shouldNotHaveSameAssignmentOnAnyTwoHosts
- shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousActiveTasks
- shouldNotHaveSameAssignmentOnAnyTwoHostsWhenThereArePreviousStandbyTasks
- shouldNotMigrateActiveTaskToOtherProcess
- shouldNotMoveAnyTasksWhenNewTasksAdded
- shouldOptimizeStatefulAndStatelessTaskTraffic
- shouldReBalanceTasksAcrossAllClientsWhenCapacityAndTaskCountTheSame
- shouldReBalanceTasksAcrossClientsWhenCapacityLessThanTaskCount
- shouldRebalanceTasksToClientsBasedOnCapacity
- shouldRemainOriginalAssignmentWithoutTrafficCostForMinCostStrategy
- shouldViolateBalanceToPreserveActiveTaskStickiness
org.apache.kafka.streams.processor.internals.assignment.RackAwareGraphConstructorFactoryTest:
- shouldReturnBalanceSubtopologyConstructor
- shouldReturnMinCostConstructor
org.apache.kafka.streams.processor.internals.assignment.RackAwareGraphConstructorTest:
- testAssignTaskFromMinCostFlow
- testBalanceSubtopologyGraphConstructor
- testMinCostGraphConstructor
- testSubtopologyShouldContainAllTasks
org.apache.kafka.streams.processor.internals.assignment.RackAwareTaskAssignorTest:
- shouldBalanceAssignmentWithMoreCost
- shouldDisableActiveWhenMissingClusterInfo
- shouldDisableActiveWhenRackMissingInNode
- shouldDisableAssignorFromConfig
- shouldDisableRackAwareAssignorWithDescribingTopicsFailure
- shouldDisableRackAwareAssignorWithStandbyDescribingTopicsFailure
- shouldEnableRackAwareAssignorWithCacheResult
- shouldEnableRackAwareAssignorWithDescribingTopics
- shouldEnableRackAwareAssignorWithStandbyDescribingTopics
- shouldEnableRackAwareAssignorWithoutDescribingTopics
- shouldMaintainOriginalAssignmentForMinCost
- shouldNotCrashForEmptyStandby
- shouldOptimizeActiveTasks
- shouldOptimizeActiveTasksWithMoreClients
- shouldOptimizeActiveTasksWithMoreClientsWithMoreThanOneTask
- shouldOptimizeEmptyActiveTasks
- shouldOptimizeRandomActive
- shouldOptimizeRandomStandby
- shouldOptimizeStandbyTasksWhenTasksAllMovable
- shouldOptimizeStandbyTasksWithMovingConstraint
- shouldPopulateRacksForProcess
- shouldReturnFalseWhenRackMissingInProcess
- shouldReturnInvalidClientRackWhenRackDiffersInSameProcess
- shouldReturnInvalidClientRackWhenRackMissingInClientConsumer
- shouldThrowIfMissingCallCanEnableRackAwareAssignor
- shouldThrowIfTaskInMultipleClients
- shouldThrowIfTaskMissingInClients
org.apache.kafka.streams.processor.internals.assignment.StandbyTaskAssignmentUtilsTest:
- shouldComputeTasksToRemainingStandbys
- shouldReturnNumberOfStandbyTasksThatWereNotAssigned
- shouldReturnZeroWhenAllStandbyTasksWereSuccessfullyAssigned
org.apache.kafka.streams.processor.internals.assignment.StandbyTaskAssignorFactoryTest:
- shouldReturnClientTagAwareStandbyTaskAssignorWhenRackAwareAssignmentTagsIsSet
- shouldReturnDefaultOrRackAwareStandbyTaskAssignorWhenRackAwareAssignmentTagsIsEmpty
org.apache.kafka.streams.processor.internals.assignment.SubscriptionInfoTest:
- generatedVersion1ShouldBeDecodableByLegacyLogic
- generatedVersion1ShouldDecodeLegacyFormat
- generatedVersion2ShouldBeDecodableByLegacyLogic
- generatedVersion2ShouldDecodeLegacyFormat
- generatedVersion3And4ShouldBeDecodableByLegacyLogic
- generatedVersion3To6ShouldDecodeLegacyFormat
- shouldAllowToDecodeFutureSupportedVersion
- shouldConvertTaskOffsetSumMapToTaskSets
- shouldConvertTaskSetsToTaskOffsetSumMapWithOlderSubscription
- shouldEncodeAndDecodeSmallerLatestSupportedVersion
- shouldEncodeAndDecodeVersion1
- shouldEncodeAndDecodeVersion10
- shouldEncodeAndDecodeVersion10WithNamedTopologies
- shouldEncodeAndDecodeVersion11
- shouldEncodeAndDecodeVersion2
- shouldEncodeAndDecodeVersion3And4
- shouldEncodeAndDecodeVersion5
- shouldEncodeAndDecodeVersion7
- shouldEncodeAndDecodeVersion8
- shouldEncodeAndDecodeVersion9
- shouldNotErrorAccessingFutureVars
- shouldReturnEmptyMapOfClientTagsOnOlderVersions
- shouldReturnEncodeDecodeEmptyClientTagsOnVersion11
- shouldReturnMapOfClientTagsOnVersion11
- shouldReturnTaskOffsetSumsMapForDecodedSubscription
- shouldThrowForUnknownVersion1
- shouldThrowForUnknownVersion2
- shouldThrowIfAttemptingToUseNamedTopologiesWithOlderVersion
org.apache.kafka.streams.processor.internals.assignment.TaskAssignmentUtilsTest:
- shouldAssignStandbyTasksByClientLoad
- shouldAssignStandbyTasksWithClientTags
- shouldCorrectlyReturnIdentityAssignment
- shouldNotViolateClientTagsAssignmentDuringStandbyOptimization
- shouldOptimizeActiveTaskSimple
- shouldOptimizeStandbyTasksBasic
- shouldOptimizeStandbyTasksWithMultipleRacks
- testValidateTaskAssignment
org.apache.kafka.streams.processor.internals.assignment.TaskAssignorConvergenceTest:
- assignmentShouldConvergeAfterAddingNode
- droppingNodesShouldConverge
- randomClusterPerturbationsShouldConverge
- staticAssignmentShouldConvergeWithTheFirstAssignment
org.apache.kafka.streams.processor.internals.assignment.TaskMovementTest:
- shouldAssignAllTasksToClientsAndReturnFalseIfNoClientsAreCaughtUp
- shouldAssignTasksToClientsAndReturnFalseWhenAllClientsCaughtUp
- shouldMoveTasksToCaughtUpClientsAndAssignWarmupReplicasInTheirPlace
- shouldMoveTasksToMostCaughtUpClientsAndAssignWarmupReplicasInTheirPlace
- shouldNotCountPreviousStandbyTasksTowardsMaxWarmupReplicas
- shouldOnlyGetUpToMaxWarmupReplicasAndReturnTrue
org.apache.kafka.streams.processor.internals.metrics.ProcessorNodeMetricsTest:
- shouldGetIdempotentUpdateSkipSensor
- shouldGetProcessAtSourceSensor
- shouldGetSuppressionEmitSensor
org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImplTest:
- shouldAddAmountRate
- shouldAddAmountRateAndSum
- shouldAddAvgAndMinAndMaxMetricsToSensor
- shouldAddAvgAndTotalMetricsToSensor
- shouldAddClientLevelImmutableMetric
- shouldAddClientLevelMutableMetric
- shouldAddInvocationRateToSensor
- shouldAddLatencyRateTotalSensor
- shouldAddLatencyRateTotalSensorWithCustomTags
- shouldAddMinAndMaxMetricsToSensor
- shouldAddNewStoreLevelMutableMetric
- shouldAddRateTotalSensor
- shouldAddRateTotalSensorWithCustomTags
- shouldAddSum
- shouldAddThreadLevelImmutableMetric
- shouldAddThreadLevelMutableMetric
- shouldAddThreadLevelMutableMetricWithAdditionalTags
- shouldAddTotalCountAndSumMetricsToSensor
- shouldAddValue
- shouldCleanupThreadLevelImmutableMetric
- shouldCleanupThreadLevelMutableMetric
- shouldCreateMetricOnceDuringConcurrentMetricCreationRequest
- shouldCreateNewStoreLevelMutableMetric
- shouldGetCacheLevelTagMap
- shouldGetClientLevelTagMap
- shouldGetExistingCacheLevelSensor
- shouldGetExistingClientLevelSensor
- shouldGetExistingNodeLevelSensor
- shouldGetExistingStoreLevelSensor
- shouldGetExistingTaskLevelSensor
- shouldGetExistingThreadLevelSensor
- shouldGetExistingTopicLevelSensor
- shouldGetNewCacheLevelSensor
- shouldGetNewClientLevelSensor
- shouldGetNewNodeLevelSensor
- shouldGetNewStoreLevelSensorIfNoneExists
- shouldGetNewTaskLevelSensor
- shouldGetNewThreadLevelSensor
- shouldGetNewTopicLevelSensor
- shouldGetStoreLevelTagMap
- shouldGetThreadLevelTagMap
- shouldMeasureLatency
- shouldNotAddStoreLevelMutableMetricIfAlreadyExists
- shouldNotMeasureLatencyBecauseSensorHasNoMetrics
- shouldNotMeasureLatencyDueToRecordingLevel
- shouldNotUseSameStoreLevelSensorKeyWithDifferentStoreNames
- shouldNotUseSameStoreLevelSensorKeyWithDifferentTaskIds
- shouldNotUseSameStoreLevelSensorKeyWithDifferentThreadIds
- shouldProvideCorrectStrings
- shouldRemoveClientLevelMetricsAndSensors
- shouldRemoveStateStoreLevelSensors
- shouldRemoveThreadLevelSensors
- shouldReturnMetricsVersionCurrent
- shouldReturnSameMetricIfAlreadyCreated
- shouldThrowIfLatencyRateTotalSensorIsAddedWithOddTags
- shouldThrowIfRateTotalSensorIsAddedWithOddTags
- shouldUseSameStoreLevelSensorKeyWithSameSensorNames
- shouldUseSameStoreLevelSensorKeyWithTwoDifferentSensorNames
- testLatencyMetrics
- testMultiLevelSensorRemoval
- testNullMetrics
- testRemoveNullSensor
- testRemoveSensor
- testThroughputMetrics
- testTotalMetricDoesntDecrease
org.apache.kafka.streams.processor.internals.metrics.TaskMetricsTest:
- shouldGetActiveBufferCountSensor
- shouldGetActiveProcessRatioSensor
- shouldGetDroppedRecordsSensor
- shouldGetEnforcedProcessingSensor
- shouldGetProcessLatencySensor
- shouldGetPunctuateSensor
- shouldGetRecordLatenessSensor
- shouldGetTotalCacheSizeInBytesSensor
org.apache.kafka.streams.processor.internals.metrics.ThreadMetricsTest:
- shouldAddThreadStartTimeMetric
- shouldAddThreadStateJmxMetric
- shouldAddThreadStateTelemetryMetric
- shouldAddTotalBlockedTimeMetric
- shouldGetCloseTaskSensor
- shouldGetCommitRatioSensor
- shouldGetCommitSensor
- shouldGetCreateTaskSensor
- shouldGetPollRatioSensor
- shouldGetPollRecordsSensor
- shouldGetPollSensor
- shouldGetProcessLatencySensor
- shouldGetProcessRateSensor
- shouldGetProcessRatioSensor
- shouldGetProcessRecordsSensor
- shouldGetPunctuateRatioSensor
- shouldGetPunctuateSensor
org.apache.kafka.streams.processor.internals.metrics.TopicMetricsTest:
- shouldGetRecordsAndBytesConsumedSensor
- shouldGetRecordsAndBytesProducedSensor
org.apache.kafka.streams.processor.internals.tasks.DefaultTaskExecutorTest:
- shouldAwaitProcessableTasksIfNoneAssignable
- shouldClearTaskReleaseFutureOnShutdown
- shouldClearTaskTimeoutOnProcessed
- shouldNotFlushOnException
- shouldProcessTasks
- shouldPunctuateStreamTime
- shouldPunctuateSystemTime
- shouldRespectProcessingDisabledByTaskExecutionMetadata
- shouldRespectPunctuationDisabledByTaskExecutionMetadata
- shouldSetTaskTimeoutOnTimeoutException
- shouldSetUncaughtStreamsException
- shouldShutdownTaskExecutor
- shouldUnassignTaskWhenNotProgressing
- shouldUnassignTaskWhenRequired
org.apache.kafka.streams.processor.internals.tasks.DefaultTaskManagerTest:
- shouldAddTask
- shouldAssignTaskThatCanBeProcessed
- shouldAssignTasksThatCanBeStreamTimePunctuated
- shouldAssignTasksThatCanBeSystemTimePunctuated
- shouldBlockOnAwait
- shouldLockATaskThatWasVoluntarilyReleased
- shouldLockAnEmptySetOfTasks
- shouldNotAssignAnyLockedTask
- shouldNotAssignLockedTask
- shouldNotAssignTasksForProcessingIfProcessingDisabled
- shouldNotAssignTasksForPunctuationIfPunctuationDisabled
- shouldNotAssignTasksIfUncaughtExceptionPresent
- shouldNotRemoveAssignedTask
- shouldNotRemoveUnlockedTask
- shouldNotSetUncaughtExceptionsForUnassignedTasks
- shouldNotSetUncaughtExceptionsTwice
- shouldNotUnassignNotOwnedTask
- shouldRemoveTask
- shouldReturnAndClearExceptionsOnDrainExceptions
- shouldReturnFromAwaitOnAdding
- shouldReturnFromAwaitOnInterruption
- shouldReturnFromAwaitOnSignalProcessableTasks
- shouldReturnFromAwaitOnUnassignment
- shouldReturnFromAwaitOnUnlocking
- shouldShutdownTaskExecutors
- shouldStartTaskExecutors
- shouldUnassignLockingTask
- shouldUnassignTask
org.apache.kafka.streams.query.MultiVersionedKeyQueryTest:
- shouldThrowNPEWithNullKey
org.apache.kafka.streams.query.PositionBoundTest:
- shouldCopyPosition
- shouldEqualPosition
- shouldEqualSelf
- shouldEqualUnbounded
- shouldNotEqualNull
- shouldNotHash
- unboundedShouldBeUnbounded
- unboundedShouldReturnEmptyPosition
org.apache.kafka.streams.query.PositionTest:
- shouldCopy
- shouldCreateFromMap
- shouldCreateFromNullMap
- shouldMatchOnEqual
- shouldMatchSelf
- shouldMerge
- shouldMergeNull
- shouldMonotonicallyIncreasePartitionPosition
- shouldNotHash
- shouldNotMatchNull
- shouldNotMatchOnUnEqual
- shouldUpdateComponentMonotonically
org.apache.kafka.streams.query.StateQueryResultTest:
- getOnlyPartitionResultMultipleResults
- getOnlyPartitionResultNoResultsTest
- getOnlyPartitionResultWithSingleResultTest
org.apache.kafka.streams.query.VersionedKeyQueryTest:
- shouldThrowNPEWithNullAsOftimestamp
- shouldThrowNPEWithNullKey
org.apache.kafka.streams.state.HostInfoTest:
- shouldCreateHostInfo
- shouldReturnNullHostInfoForEmptyEndPoint
- shouldReturnNullHostInfoForNullEndPoint
- shouldThrowConfigExceptionForNonsenseEndPoint
org.apache.kafka.streams.state.StateSerdesTest:
- shouldReturnSerdesForBuiltInKeyAndValueTypesForBuiltinTypes
- shouldSkipValueAndTimestampeInformationForErrorOnTimestampAndValueSerialization
- shouldThrowForUnknownKeyTypeForBuiltinTypes
- shouldThrowForUnknownValueTypeForBuiltinTypes
- shouldThrowIfIncompatibleSerdeForKey
- shouldThrowIfIncompatibleSerdeForValue
- shouldThrowIfKeyClassIsNull
- shouldThrowIfKeyClassIsNullForBuiltinTypes
- shouldThrowIfTopicNameIsNull
- shouldThrowIfTopicNameIsNullForBuiltinTypes
- shouldThrowIfValueClassIsNull
- shouldThrowIfValueClassIsNullForBuiltinTypes
org.apache.kafka.streams.state.StoresTest:
- shouldBuildKeyValueStore
- shouldBuildSessionStore
- shouldBuildTimestampedKeyValueStore
- shouldBuildTimestampedKeyValueStoreThatWrapsInMemoryKeyValueStore
- shouldBuildTimestampedKeyValueStoreThatWrapsKeyValueStore
- shouldBuildTimestampedWindowStore
- shouldBuildTimestampedWindowStoreThatWrapsInMemoryWindowStore
- shouldBuildTimestampedWindowStoreThatWrapsWindowStore
- shouldBuildVersionedKeyValueStore
- shouldBuildWindowStore
- shouldCreateInMemoryKeyValueStore
- shouldCreateMemoryNavigableCache
- shouldCreateRocksDbSessionStore
- shouldCreateRocksDbStore
- shouldCreateRocksDbTimestampedStore
- shouldCreateRocksDbTimestampedWindowStore
- shouldCreateRocksDbVersionedStore
- shouldCreateRocksDbWindowStore
- shouldThrowIfILruMapStoreCapacityIsNegative
- shouldThrowIfILruMapStoreNameIsNull
- shouldThrowIfIMemoryKeyValueStoreStoreNameIsNull
- shouldThrowIfIPersistentSessionStoreRetentionPeriodIsNegative
- shouldThrowIfIPersistentSessionStoreStoreNameIsNull
- shouldThrowIfIPersistentTimestampedWindowStoreIfWindowSizeIsNegative
- shouldThrowIfIPersistentTimestampedWindowStoreRetentionPeriodIsNegative
- shouldThrowIfIPersistentTimestampedWindowStoreStoreNameIsNull
- shouldThrowIfIPersistentWindowStoreIfWindowSizeIsNegative
- shouldThrowIfIPersistentWindowStoreRetentionPeriodIsNegative
- shouldThrowIfIPersistentWindowStoreStoreNameIsNull
- shouldThrowIfPersistentKeyValueStoreStoreNameIsNull
- shouldThrowIfPersistentTimestampedKeyValueStoreStoreNameIsNull
- shouldThrowIfPersistentVersionedKeyValueStoreHistoryRetentionIsNegative
- shouldThrowIfPersistentVersionedKeyValueStoreSegmentIntervalIsZeroOrNegative
- shouldThrowIfPersistentVersionedKeyValueStoreStoreNameIsNull
- shouldThrowIfSupplierIsNullForKeyValueStoreBuilder
- shouldThrowIfSupplierIsNullForSessionStoreBuilder
- shouldThrowIfSupplierIsNullForVersionedKeyValueStoreBuilder
- shouldThrowIfSupplierIsNullForWindowStoreBuilder
org.apache.kafka.streams.state.StreamsMetadataTest:
- shouldBeEqualsIfSameObject
- shouldNotAllowModificationOfInternalStateViaGetters
- shouldNotBeEqualIfDifferInHostInfo
- shouldNotBeEqualIfDifferInStandByStores
- shouldNotBeEqualIfDifferInStandByTopicPartitions
- shouldNotBeEqualIfDifferInTopicPartitions
- shouldNotBeEqualIfDifferStateStoreNames
org.apache.kafka.streams.state.internals.BlockBasedTableConfigWithAccessibleCacheTest:
- shouldReturnNoBlockCacheIfNoneIsSet
- shouldSetBlockCacheAndMakeItAccessible
org.apache.kafka.streams.state.internals.BufferValueTest:
- shouldAccountForDeduplicationInSizeEstimate
- shouldCompactDuplicates
- shouldDeduplicateEqualValues
- shouldDeduplicateIdenticalValues
- shouldDeduplicateNullValues
- shouldDeserializeCompactedDuplicates
- shouldDeserializeNew
- shouldDeserializeOld
- shouldDeserializePrior
- shouldSerializeNew
- shouldSerializeNulls
- shouldSerializeOld
- shouldSerializePrior
- shouldStoreDifferentValues
- shouldStoreDifferentValuesWithOldNull
- shouldStoreDifferentValuesWithPriorNull
org.apache.kafka.streams.state.internals.CachingInMemoryKeyValueStoreTest:
- prefixScanShouldNotThrowConcurrentModificationException
- shouldAvoidFlushingDeletionsWithoutDirtyKeys
- shouldClearNamespaceCacheOnClose
- shouldCloseCacheAfterErrorDuringStateStoreClose
- shouldCloseWrappedStoreAfterErrorDuringCacheClose
- shouldCloseWrappedStoreAndCacheAfterErrorDuringCacheFlush
- shouldDelegateInit
- shouldDeleteFromStore
- shouldDeleteIfSerializedValueIsNull
- shouldDeleteItemsFromCache
- shouldFlushEvictedItemsIntoUnderlyingStore
- shouldForwardDirtyItemToListenerWhenEvicted
- shouldForwardDirtyItemsWhenFlushCalled
- shouldForwardOldValuesWhenEnabled
- shouldGetRecordsWithPrefixKey
- shouldGetRecordsWithPrefixKeyExcludingNextLargestKey
- shouldIterateAllStoredItems
- shouldIterateOverRange
- shouldMatchPositionAfterPutWithFlushListener
- shouldMatchPositionAfterPutWithoutFlushListener
- shouldNotForwardOldValuesWhenDisabled
- shouldNotIncludeDeletedFromRangeResult
- shouldNotShowItemsDeletedFromCacheButFlushedToStoreBeforeDelete
- shouldNotThrowConcurrentModificationException
- shouldNotThrowInvalidRangeExceptionWithFromLargerThanTo
- shouldNotThrowInvalidRangeExceptionWithNegativeFromKey
- shouldNotThrowInvalidReverseRangeExceptionWithFromLargerThanTo
- shouldNotThrowInvalidReverseRangeExceptionWithNegativeFromKey
- shouldNotThrowNullPointerExceptionOnPutAllNullKey
- shouldNotThrowNullPointerExceptionOnPutIfAbsentNullValue
- shouldNotThrowNullPointerExceptionOnPutNullValue
- shouldPutAll
- shouldPutGetToFromCache
- shouldPutIfAbsent
- shouldPutReverseAll
- shouldReturnSameResultsForGetAndRangeWithEqualKeys
- shouldReturnSameResultsForGetAndReverseRangeWithEqualKeys
- shouldReturnUnderlying
- shouldReturnValueOnRangeKeyToNull
- shouldReturnValueOnRangeNullToKey
- shouldReturnValueOnRangeNullToNull
- shouldReturnValueOnReverseRangeKeyToNull
- shouldReturnValueOnReverseRangeNullToKey
- shouldReturnValueOnReverseRangeNullToNull
- shouldReverseIterateAllStoredItems
- shouldReverseIterateOverRange
- shouldSetFlushListener
- shouldThrowIfTryingToDeleteFromClosedCachingStore
- shouldThrowIfTryingToDoAllQueryOnClosedCachingStore
- shouldThrowIfTryingToDoGetApproxSizeOnClosedCachingStore
- shouldThrowIfTryingToDoPutAllClosedCachingStore
- shouldThrowIfTryingToDoPutIfAbsentClosedCachingStore
- shouldThrowIfTryingToDoRangeQueryOnClosedCachingStore
- shouldThrowIfTryingToDoReverseAllQueryOnClosedCachingStore
- shouldThrowIfTryingToDoReverseRangeQueryOnClosedCachingStore
- shouldThrowIfTryingToGetFromClosedCachingStore
- shouldThrowIfTryingToWriteToClosedCachingStore
- shouldThrowNullPointerExceptionOnDeleteNullKey
- shouldThrowNullPointerExceptionOnGetNullKey
- shouldThrowNullPointerExceptionOnPutAllNullKey
- shouldThrowNullPointerExceptionOnPutAllWithNullKey
- shouldThrowNullPointerExceptionOnPutIfAbsentNullKey
- shouldThrowNullPointerExceptionOnPutIfAbsentWithNullKey
- shouldThrowNullPointerExceptionOnPutNullKey
- shouldThrowNullPointerExceptionOnPutWithNullKey
- testPutGetRange
- testPutGetReverseRange
- testPutGetWithDefaultSerdes
- testPutIfAbsent
- testRestore
- testRestoreWithDefaultSerdes
- testSize
org.apache.kafka.streams.state.internals.CachingInMemorySessionStoreTest:
- shouldBackwardFetchAllSessionsWithSameRecordKey
- shouldBackwardFetchCorrectlyAcrossSegments
- shouldBackwardFetchRangeCorrectlyAcrossSegments
- shouldClearNamespaceCacheOnClose
- shouldCloseCacheAfterErrorDuringWrappedStoreClose
- shouldCloseWrappedStoreAfterErrorDuringCacheClose
- shouldCloseWrappedStoreAndCacheAfterErrorDuringCacheFlush
- shouldDelegateInit
- shouldFetchAllSessionsWithSameRecordKey
- shouldFetchCorrectlyAcrossSegments
- shouldFetchRangeCorrectlyAcrossSegments
- shouldFlushItemsToStoreOnEviction
- shouldForwardChangedValuesDuringFlush
- shouldMatchPositionAfterPutWithFlushListener
- shouldMatchPositionAfterPutWithoutFlushListener
- shouldNotForwardChangedValuesDuringFlushWhenSendOldValuesDisabled
- shouldNotThrowInvalidRangeExceptionWhenBackwardWithNegativeFromKey
- shouldNotThrowInvalidRangeExceptionWithNegativeFromKey
- shouldPutBackwardFetchAllKeysFromCache
- shouldPutBackwardFetchRangeFromCache
- shouldPutFetchAllKeysFromCache
- shouldPutFetchFromCache
- shouldPutFetchRangeFromCache
- shouldQueryItemsInCacheAndStore
- shouldRemove
- shouldReturnSameResultsForSingleKeyFindSessionsAndEqualKeyRangeFindSessions
- shouldReturnSameResultsForSingleKeyFindSessionsBackwardsAndEqualKeyRangeFindSessions
- shouldSetFlushListener
- shouldThrowIfTryingToFetchFromClosedCachingStore
- shouldThrowIfTryingToFindMergeSessionFromClosedCachingStore
- shouldThrowIfTryingToPutIntoClosedCachingStore
- shouldThrowIfTryingToRemoveFromClosedCachingStore
- shouldThrowNullPointerExceptionOnFetchNullKey
- shouldThrowNullPointerExceptionOnFindSessionsNullKey
- shouldThrowNullPointerExceptionOnPutNullKey
- shouldThrowNullPointerExceptionOnRemoveNullKey
org.apache.kafka.streams.state.internals.CachingPersistentSessionStoreTest:
- shouldBackwardFetchAllSessionsWithSameRecordKey
- shouldBackwardFetchCorrectlyAcrossSegments
- shouldBackwardFetchRangeCorrectlyAcrossSegments
- shouldClearNamespaceCacheOnClose
- shouldCloseCacheAfterErrorDuringWrappedStoreClose
- shouldCloseWrappedStoreAfterErrorDuringCacheClose
- shouldCloseWrappedStoreAndCacheAfterErrorDuringCacheFlush
- shouldFetchAllSessionsWithSameRecordKey
- shouldFetchCorrectlyAcrossSegments
- shouldFetchRangeCorrectlyAcrossSegments
- shouldFlushItemsToStoreOnEviction
- shouldForwardChangedValuesDuringFlush
- shouldMatchPositionAfterPutWithFlushListener
- shouldMatchPositionAfterPutWithoutFlushListener
- shouldNotForwardChangedValuesDuringFlushWhenSendOldValuesDisabled
- shouldNotThrowInvalidRangeExceptionWhenBackwardWithNegativeFromKey
- shouldNotThrowInvalidRangeExceptionWithNegativeFromKey
- shouldPutBackwardFetchAllKeysFromCache
- shouldPutBackwardFetchRangeFromCache
- shouldPutFetchAllKeysFromCache
- shouldPutFetchFromCache
- shouldPutFetchRangeFromCache
- shouldQueryItemsInCacheAndStore
- shouldRemove
- shouldReturnSameResultsForSingleKeyFindSessionsAndEqualKeyRangeFindSessions
- shouldReturnSameResultsForSingleKeyFindSessionsBackwardsAndEqualKeyRangeFindSessions
- shouldSetFlushListener
- shouldThrowIfTryingToFetchFromClosedCachingStore
- shouldThrowIfTryingToFindMergeSessionFromClosedCachingStore
- shouldThrowIfTryingToPutIntoClosedCachingStore
- shouldThrowIfTryingToRemoveFromClosedCachingStore
- shouldThrowNullPointerExceptionOnFetchNullKey
- shouldThrowNullPointerExceptionOnFindSessionsNullKey
- shouldThrowNullPointerExceptionOnPutNullKey
- shouldThrowNullPointerExceptionOnRemoveNullKey
org.apache.kafka.streams.state.internals.CachingPersistentWindowStoreTest:
- shouldBackwardFetchAndIterateOverExactKeys
- shouldClearNamespaceCacheOnClose
- shouldCloseCacheAfterErrorDuringStateStoreClose
- shouldCloseCacheAndWrappedStoreAfterErrorDuringCacheFlush
- shouldCloseWrappedStoreAfterErrorDuringCacheClose
- shouldDelegateInit
- shouldFetchAllBackwardWithinTimestampRange
- shouldFetchAllWithinTimestampRange
- shouldFetchAndIterateOverExactKeys
- shouldFetchAndIterateOverKeyBackwardRange
- shouldFetchAndIterateOverKeyRange
- shouldFlushEvictedItemsIntoUnderlyingStore
- shouldForwardDirtyItemToListenerWhenEvicted
- shouldForwardDirtyItemsWhenFlushCalled
- shouldForwardOldValuesWhenDisabled
- shouldForwardOldValuesWhenEnabled
- shouldGetAllBackwardFromCache
- shouldGetAllFromCache
- shouldIterateAcrossWindows
- shouldIterateBackwardAcrossWindows
- shouldIterateBackwardCacheAndStore
- shouldIterateBackwardCacheAndStoreKeyRange
- shouldIterateCacheAndStore
- shouldIterateCacheAndStoreKeyRange
- shouldMatchPositionAfterPutWithFlushListener
- shouldMatchPositionAfterPutWithoutFlushListener
- shouldNotReturnDuplicatesInRanges
- shouldNotThrowInvalidBackwardRangeExceptionWithNegativeFromKey
- shouldNotThrowInvalidRangeExceptionWithNegativeFromKey
- shouldNotThrowNullPointerExceptionOnPutNullValue
- shouldPutBackwardFetchRangeFromCacheForNullKeyFrom
- shouldPutBackwardFetchRangeFromCacheForNullKeyFromKeyTo
- shouldPutBackwardFetchRangeFromCacheForNullKeyTo
- shouldPutFetchFromCache
- shouldPutFetchRangeFromCache
- shouldPutFetchRangeFromCacheForNullKeyFrom
- shouldPutFetchRangeFromCacheForNullKeyFromKeyTo
- shouldPutFetchRangeFromCacheForNullKeyTo
- shouldReturnSameResultsForSingleKeyFetchAndEqualKeyRangeBackwardFetch
- shouldReturnSameResultsForSingleKeyFetchAndEqualKeyRangeFetch
- shouldSetFlushListener
- shouldTakeValueFromCacheIfSameTimestampFlushedToRocks
- shouldThrowIfTryingToFetchFromClosedCachingStore
- shouldThrowIfTryingToFetchRangeFromClosedCachingStore
- shouldThrowIfTryingToWriteToClosedCachingStore
- shouldThrowNullPointerExceptionOnFetchNullKey
- shouldThrowNullPointerExceptionOnPutNullKey
org.apache.kafka.streams.state.internals.ChangeLoggingKeyValueBytesStoreTest:
- shouldDelegateInit
- shouldGetRecordsWithPrefixKey
- shouldLogKeyNullOnDelete
- shouldLogPositionOnPut
- shouldNotWriteToChangeLogOnPutIfAbsentWhenValueForKeyExists
- shouldNotWriteToInnerOnPutIfAbsentWhenValueForKeyExists
- shouldPropagateDelete
- shouldReturnCurrentValueOnPutIfAbsent
- shouldReturnNullOnGetWhenDoesntExist
- shouldReturnNullOnPutIfAbsentWhenNoPreviousValue
- shouldReturnOldValueOnDelete
- shouldReturnValueOnGetWhenExists
- shouldWriteAllKeyValueToInnerStoreOnPutAll
- shouldWriteKeyValueBytesToInnerStoreOnPut
- shouldWriteToChangelogOnPutIfAbsentWhenNoPreviousValue
- shouldWriteToInnerOnPutIfAbsentNoPreviousValue
org.apache.kafka.streams.state.internals.ChangeLoggingSessionBytesStoreTest:
- shouldCloseUnderlyingStore
- shouldDelegateInit
- shouldDelegateToUnderlyingStoreWhenBackwardFetching
- shouldDelegateToUnderlyingStoreWhenBackwardFetchingRange
- shouldDelegateToUnderlyingStoreWhenBackwardFindingSessionRange
- shouldDelegateToUnderlyingStoreWhenBackwardFindingSessions
- shouldDelegateToUnderlyingStoreWhenFetching
- shouldDelegateToUnderlyingStoreWhenFetchingRange
- shouldDelegateToUnderlyingStoreWhenFindingSessionRange
- shouldDelegateToUnderlyingStoreWhenFindingSessions
- shouldFlushUnderlyingStore
- shouldLogPuts
- shouldLogPutsWithPosition
- shouldLogRemoves
org.apache.kafka.streams.state.internals.ChangeLoggingTimestampedKeyValueBytesStoreTest:
- shouldDelegateInit
- shouldLogChangesOnPutAll
- shouldLogKeyNullOnDelete
- shouldNotWriteToChangeLogOnPutIfAbsentWhenValueForKeyExists
- shouldNotWriteToInnerOnPutIfAbsentWhenValueForKeyExists
- shouldPropagateDelete
- shouldReturnCurrentValueOnPutIfAbsent
- shouldReturnNullOnGetWhenDoesntExist
- shouldReturnNullOnPutIfAbsentWhenNoPreviousValue
- shouldReturnOldValueOnDelete
- shouldReturnValueOnGetWhenExists
- shouldWriteAllKeyValueToInnerStoreOnPutAll
- shouldWriteKeyValueBytesToInnerStoreOnPut
- shouldWriteToChangelogOnPutIfAbsentWhenNoPreviousValue
- shouldWriteToInnerOnPutIfAbsentNoPreviousValue
org.apache.kafka.streams.state.internals.ChangeLoggingTimestampedWindowBytesStoreTest:
- shouldDelegateInit
- shouldDelegateToUnderlyingStoreWhenFetching
- shouldDelegateToUnderlyingStoreWhenFetchingRange
- shouldLogPuts
- shouldLogPutsWithPosition
- shouldRetainDuplicatesWhenSet
org.apache.kafka.streams.state.internals.ChangeLoggingVersionedKeyValueBytesStoreTest:
- shouldDelegateGet
- shouldDelegateGetWithTimestamp
- shouldDelegateInit
- shouldNotLogOnDeleteIfInnerStoreThrows
- shouldNotLogOnPutAllIfInnerStoreThrows
- shouldNotLogOnPutIfAbsentIfInnerStoreThrows
- shouldPropagateAndLogOnDeleteWithTimestamp
- shouldPropagateAndLogOnPut
- shouldPropagateAndLogOnPutNull
- shouldThrowIfInnerIsNotVersioned
org.apache.kafka.streams.state.internals.ChangeLoggingWindowBytesStoreTest:
- shouldDelegateInit
- shouldDelegateToUnderlyingStoreWhenBackwardFetching
- shouldDelegateToUnderlyingStoreWhenBackwardFetchingRange
- shouldDelegateToUnderlyingStoreWhenFetching
- shouldDelegateToUnderlyingStoreWhenFetchingRange
- shouldLogPuts
- shouldLogPutsWithPosition
- shouldRetainDuplicatesWhenSet
org.apache.kafka.streams.state.internals.CompositeReadOnlyKeyValueStoreTest:
- shouldFindValueForKeyWhenMultiStores
- shouldGetApproximateEntriesAcrossAllStores
- shouldNotGetValuesFromOtherStores
- shouldReturnKeysWithGivenPrefixExcludingNextKeyLargestKey
- shouldReturnLongMaxValueOnOverflow
- shouldReturnLongMaxValueOnUnderflow
- shouldReturnNullIfKeyDoesNotExist
- shouldReturnValueIfExists
- shouldReturnValueOnRangeNullFromKey
- shouldReturnValueOnRangeNullToKey
- shouldReturnValueOnReverseRangeNullFromKey
- shouldReturnValueOnReverseRangeNullToKey
- shouldSupportAllAcrossMultipleStores
- shouldSupportPrefixScan
- shouldSupportPrefixScanAcrossMultipleKVStores
- shouldSupportRange
- shouldSupportRangeAcrossMultipleKVStores
- shouldSupportReverseAllAcrossMultipleStores
- shouldSupportReverseRange
- shouldSupportReverseRangeAcrossMultipleKVStores
- shouldThrowInvalidStoreExceptionDuringRebalance
- shouldThrowInvalidStoreExceptionOnAllDuringRebalance
- shouldThrowInvalidStoreExceptionOnApproximateNumEntriesDuringRebalance
- shouldThrowInvalidStoreExceptionOnPrefixScanDuringRebalance
- shouldThrowInvalidStoreExceptionOnRangeDuringRebalance
- shouldThrowInvalidStoreExceptionOnReverseAllDuringRebalance
- shouldThrowInvalidStoreExceptionOnReverseRangeDuringRebalance
- shouldThrowNoSuchElementExceptionWhileNext
- shouldThrowNoSuchElementExceptionWhileNextForPrefixScan
- shouldThrowNoSuchElementExceptionWhilePeekNext
- shouldThrowNoSuchElementExceptionWhilePeekNextForPrefixScan
- shouldThrowNullPointerExceptionOnGetNullKey
- shouldThrowNullPointerExceptionOnPrefixScanNullPrefix
- shouldThrowNullPointerExceptionOnPrefixScanNullPrefixKeySerializer
- shouldThrowUnsupportedOperationExceptionWhilePrefixScan
- shouldThrowUnsupportedOperationExceptionWhileRange
- shouldThrowUnsupportedOperationExceptionWhileRemove
- shouldThrowUnsupportedOperationExceptionWhileReverseRange
org.apache.kafka.streams.state.internals.CompositeReadOnlySessionStoreTest:
- shouldFetchKeyRangeAcrossStores
- shouldFetchKeyRangeAcrossStoresWithNullKeyFrom
- shouldFetchKeyRangeAcrossStoresWithNullKeyFromKeyTo
- shouldFetchKeyRangeAcrossStoresWithNullKeyTo
- shouldFetchResultsFromUnderlyingSessionStore
- shouldFindValueForKeyWhenMultiStores
- shouldNotGetValueFromOtherStores
- shouldReturnEmptyIteratorIfNoData
- shouldThrowInvalidStateStoreExceptionIfSessionFetchThrows
- shouldThrowInvalidStateStoreExceptionOnRebalance
- shouldThrowNPEIfKeyIsNull
- shouldThrowNullPointerExceptionIfFetchingNullKey
org.apache.kafka.streams.state.internals.CompositeReadOnlyWindowStoreTest:
- emptyBackwardIteratorAlwaysReturnsFalse
- emptyBackwardIteratorNextShouldThrowNoSuchElementException
- emptyBackwardIteratorPeekNextKeyShouldThrowNoSuchElementException
- emptyIteratorAlwaysReturnsFalse
- emptyIteratorNextShouldThrowNoSuchElementException
- emptyIteratorPeekNextKeyShouldThrowNoSuchElementException
- shouldBackwardFetchAllAcrossStores
- shouldBackwardFetchKeyRangeAcrossStores
- shouldBackwardFetchKeyRangeAcrossStoresWithNullKeyFrom
- shouldBackwardFetchKeyRangeAcrossStoresWithNullKeyFromKeyTo
- shouldBackwardFetchKeyRangeAcrossStoresWithNullKeyTo
- shouldBackwardFetchValuesFromWindowStore
- shouldFetchAllAcrossStores
- shouldFetchKeyRangeAcrossStores
- shouldFetchKeyRangeAcrossStoresWithNullKeyFrom
- shouldFetchKeyRangeAcrossStoresWithNullKeyFromKeyTo
- shouldFetchKeyRangeAcrossStoresWithNullKeyTo
- shouldFetchKeyValueAcrossStores
- shouldFetchValuesFromWindowStore
- shouldFindValueForKeyWhenMultiStores
- shouldFindValueForKeyWhenMultiStoresBackwards
- shouldGetAllAcrossStores
- shouldGetBackwardAllAcrossStores
- shouldNotGetValuesBackwardFromOtherStores
- shouldNotGetValuesFromOtherStores
- shouldReturnBackwardEmptyIteratorIfNoData
- shouldReturnEmptyIteratorIfNoData
- shouldThrowInvalidStateStoreExceptionIfBackwardFetchThrows
- shouldThrowInvalidStateStoreExceptionIfFetchThrows
- shouldThrowInvalidStateStoreExceptionOnRebalance
- shouldThrowInvalidStateStoreExceptionOnRebalanceWhenBackwards
- shouldThrowNPEIfKeyIsNull
org.apache.kafka.streams.state.internals.ContextualRecordTest:
- testEquals
- testEqualsSameInstance
- testHashCodeThrowsException
- testNotEqualsDifferentContent
org.apache.kafka.streams.state.internals.DelegatingPeekingKeyValueIteratorTest:
- shouldPeekAndIterate
- shouldPeekNext
- shouldPeekNextKey
- shouldThrowNoSuchElementWhenNoMoreItemsLeftAndNextCalled
- shouldThrowNoSuchElementWhenNoMoreItemsLeftAndPeekNextCalled
org.apache.kafka.streams.state.internals.FilteredCacheIteratorTest:
- shouldAllowEntryMatchingHasNextCondition
- shouldFilterEntriesNotMatchingHasNextCondition
- shouldNotHaveNextIfHasNextConditionNotMet
- shouldPeekNext
- shouldPeekNextKey
- shouldThrowUnsupportedOperationExceptionOnRemove
org.apache.kafka.streams.state.internals.GlobalStateStoreProviderTest:
- shouldNotReturnKeyValueStoreAsTimestampedStore
- shouldNotReturnWindowStoreAsTimestampedStore
- shouldReturnEmptyItemListIfStoreDoesntExist
- shouldReturnKeyValueStore
- shouldReturnSessionStore
- shouldReturnSingleItemListIfStoreExists
- shouldReturnTimestampedKeyValueStore
- shouldReturnTimestampedKeyValueStoreAsKeyValueStore
- shouldReturnTimestampedWindowStoreAsWindowStore
- shouldReturnWindowStore
- shouldThrowExceptionIfStoreIsntOpen
org.apache.kafka.streams.state.internals.InMemoryKeyValueLoggedStoreTest:
- prefixScanShouldNotThrowConcurrentModificationException
- shouldDeleteFromStore
- shouldDeleteIfSerializedValueIsNull
- shouldNotIncludeDeletedFromRangeResult
- shouldNotThrowConcurrentModificationException
- shouldNotThrowInvalidRangeExceptionWithFromLargerThanTo
- shouldNotThrowInvalidRangeExceptionWithNegativeFromKey
- shouldNotThrowInvalidReverseRangeExceptionWithFromLargerThanTo
- shouldNotThrowInvalidReverseRangeExceptionWithNegativeFromKey
- shouldNotThrowNullPointerExceptionOnPutAllNullKey
- shouldNotThrowNullPointerExceptionOnPutIfAbsentNullValue
- shouldNotThrowNullPointerExceptionOnPutNullValue
- shouldPutAll
- shouldPutReverseAll
- shouldReturnSameResultsForGetAndRangeWithEqualKeys
- shouldReturnSameResultsForGetAndReverseRangeWithEqualKeys
- shouldReturnValueOnRangeKeyToNull
- shouldReturnValueOnRangeNullToKey
- shouldReturnValueOnRangeNullToNull
- shouldReturnValueOnReverseRangeKeyToNull
- shouldReturnValueOnReverseRangeNullToKey
- shouldReturnValueOnReverseRangeNullToNull
- shouldThrowNullPointerExceptionOnDeleteNullKey
- shouldThrowNullPointerExceptionOnGetNullKey
- shouldThrowNullPointerExceptionOnPutAllNullKey
- shouldThrowNullPointerExceptionOnPutIfAbsentNullKey
- shouldThrowNullPointerExceptionOnPutNullKey
- testPutGetRange
- testPutGetReverseRange
- testPutGetWithDefaultSerdes
- testPutIfAbsent
- testRestore
- testRestoreWithDefaultSerdes
- testSize
org.apache.kafka.streams.state.internals.InMemoryKeyValueStoreTest:
- iteratorHasNextOnDeletedEntryShouldReturnFalse
- iteratorHasNextOnEmptyStoreShouldReturnFalse
- iteratorHasNextShouldNotAdvanceIterator
- iteratorHasNextShouldReturnTrueIfElementsRemaining
- iteratorNextAfterHasNextShouldReturnNextElement
- iteratorNextOnEmptyStoreShouldThrowException
- iteratorNextShouldIterateOverAllElements
- iteratorNextShouldReturnNextElement
- iteratorNextShouldSkipDeletedElements
- iteratorNextShouldThrowExceptionIfRemainingElementsDeleted
- iteratorPeekNextKeyOnDeletedEntryShouldThrowException
- iteratorPeekNextKeyOnEmptyStoreShouldThrowException
- iteratorPeekNextKeyShouldNotAdvanceIterator
- iteratorPeekNextKeyShouldSkipDeletedElements
- iteratorShouldThrowIllegalStateExceptionIfAlreadyClosed
- prefixScanShouldNotThrowConcurrentModificationException
- shouldDeleteFromStore
- shouldDeleteIfSerializedValueIsNull
- shouldMatchPositionAfterPut
- shouldNotIncludeDeletedFromRangeResult
- shouldNotThrowConcurrentModificationException
- shouldNotThrowInvalidRangeExceptionWithFromLargerThanTo
- shouldNotThrowInvalidRangeExceptionWithNegativeFromKey
- shouldNotThrowInvalidReverseRangeExceptionWithFromLargerThanTo
- shouldNotThrowInvalidReverseRangeExceptionWithNegativeFromKey
- shouldNotThrowNullPointerExceptionOnPutAllNullKey
- shouldNotThrowNullPointerExceptionOnPutIfAbsentNullValue
- shouldNotThrowNullPointerExceptionOnPutNullValue
- shouldPutAll
- shouldPutReverseAll
- shouldRemoveKeysWithNullValues
- shouldReturnKeysWithGivenPrefix
- shouldReturnKeysWithGivenPrefixExcludingNextKeyLargestKey
- shouldReturnNoKeys
- shouldReturnSameResultsForGetAndRangeWithEqualKeys
- shouldReturnSameResultsForGetAndReverseRangeWithEqualKeys
- shouldReturnUUIDsWithStringPrefix
- shouldReturnValueOnRangeKeyToNull
- shouldReturnValueOnRangeNullToKey
- shouldReturnValueOnRangeNullToNull
- shouldReturnValueOnReverseRangeKeyToNull
- shouldReturnValueOnReverseRangeNullToKey
- shouldReturnValueOnReverseRangeNullToNull
- shouldThrowNullPointerExceptionOnDeleteNullKey
- shouldThrowNullPointerExceptionOnGetNullKey
- shouldThrowNullPointerExceptionOnPutAllNullKey
- shouldThrowNullPointerExceptionOnPutIfAbsentNullKey
- shouldThrowNullPointerExceptionOnPutNullKey
- shouldThrowNullPointerIfPrefixKeySerializerIsNull
- testPutGetRange
- testPutGetReverseRange
- testPutGetWithDefaultSerdes
- testPutIfAbsent
- testRestore
- testRestoreWithDefaultSerdes
- testSize
org.apache.kafka.streams.state.internals.InMemoryLRUCacheStoreTest:
- prefixScanShouldNotThrowConcurrentModificationException
- shouldDeleteFromStore
- shouldDeleteIfSerializedValueIsNull
- shouldNotIncludeDeletedFromRangeResult
- shouldNotThrowConcurrentModificationException
- shouldNotThrowInvalidRangeExceptionWithFromLargerThanTo
- shouldNotThrowInvalidRangeExceptionWithNegativeFromKey
- shouldNotThrowInvalidReverseRangeExceptionWithFromLargerThanTo
- shouldNotThrowInvalidReverseRangeExceptionWithNegativeFromKey
- shouldNotThrowNullPointerExceptionOnPutAllNullKey
- shouldNotThrowNullPointerExceptionOnPutIfAbsentNullValue
- shouldNotThrowNullPointerExceptionOnPutNullValue
- shouldPutAll
- shouldPutAllKeyValuePairs
- shouldPutReverseAll
- shouldReturnSameResultsForGetAndRangeWithEqualKeys
- shouldReturnSameResultsForGetAndReverseRangeWithEqualKeys
- shouldReturnValueOnRangeKeyToNull
- shouldReturnValueOnRangeNullToKey
- shouldReturnValueOnRangeNullToNull
- shouldReturnValueOnReverseRangeKeyToNull
- shouldReturnValueOnReverseRangeNullToKey
- shouldReturnValueOnReverseRangeNullToNull
- shouldThrowNullPointerExceptionOnDeleteNullKey
- shouldThrowNullPointerExceptionOnGetNullKey
- shouldThrowNullPointerExceptionOnPutAllNullKey
- shouldThrowNullPointerExceptionOnPutIfAbsentNullKey
- shouldThrowNullPointerExceptionOnPutNullKey
- shouldUpdateValuesForExistingKeysOnPutAll
- testEvict
- testPutGetRange
- testPutGetReverseRange
- testPutGetWithDefaultSerdes
- testPutIfAbsent
- testRestore
- testRestoreEvict
- testRestoreWithDefaultSerdes
- testSize
org.apache.kafka.streams.state.internals.InMemorySessionStoreTest:
- shouldBackwardFetchAllSessionsWithSameRecordKey
- shouldBackwardFetchAllSessionsWithinKeyRange
- shouldBackwardFetchAndIterateOverExactBinaryKeys
- shouldBackwardFetchExactKeys
- shouldBackwardFindSessionsToMerge
- shouldBackwardFindValuesWithinMergingSessionWindowRange
- shouldCloseOpenIteratorsWhenStoreIsClosedAndNotThrowInvalidStateStoreExceptionOnHasNext
- shouldFetchAllSessionsWithSameRecordKey
- shouldFetchAllSessionsWithinKeyRange
- shouldFetchAndIterateOverExactBinaryKeys
- shouldFetchExactKeys
- shouldFetchExactSession
- shouldFindSessionsForTimeRange
- shouldFindSessionsToMerge
- shouldFindValuesWithinMergingSessionWindowRange
- shouldMatchPositionAfterPut
- shouldMeasureExpiredRecords
- shouldNotExpireFromOpenIterator
- shouldNotFetchExpiredSessions
- shouldNotThrowExceptionRemovingNonexistentKey
- shouldNotThrowInvalidRangeExceptionWithNegativeFromKey
- shouldPutAndBackwardFindSessionsInRange
- shouldPutAndFindSessionsInRange
- shouldRemove
- shouldRemoveExpired
- shouldRemoveOnNullAggValue
- shouldRestore
- shouldReturnNullOnSessionNotFound
- shouldReturnSameResultsForSingleKeyFindSessionsAndEqualKeyRangeFindSessions
- shouldThrowNullPointerExceptionOnFetchNullKey
- shouldThrowNullPointerExceptionOnFindSessionsNullKey
- shouldThrowNullPointerExceptionOnPutNullKey
- shouldThrowNullPointerExceptionOnRemoveNullKey
- testIteratorPeek
- testIteratorPeekBackward
org.apache.kafka.streams.state.internals.InMemoryTimeOrderedKeyValueChangeBufferTest:
- bufferShouldAllowCacheDisablement
- bufferShouldAllowCacheEnablement
- bufferShouldAllowLoggingDisablement
- bufferShouldAllowLoggingEnablement
org.apache.kafka.streams.state.internals.InMemoryWindowStoreTest:
- shouldBackwardFetchAllInTimeRange
- shouldCloseOpenIteratorsWhenStoreIsClosedAndNotThrowInvalidStateStoreExceptionOnHasNext
- shouldEarlyClosedIteratorStillGetAllRecords
- shouldFetchAllInTimeRange
- shouldFetchAndIterateOverExactBinaryKeys
- shouldFetchAndIterateOverExactKeys
- shouldGetAll
- shouldGetAllNonDeletedRecords
- shouldGetAllReturnTimestampOrderedRecords
- shouldGetBackwardAll
- shouldMatchPositionAfterPut
- shouldMeasureExpiredRecords
- shouldNotExpireFromOpenIterator
- shouldNotThrowConcurrentModificationException
- shouldNotThrowExceptionWhenFetchRangeIsExpired
- shouldNotThrowInvalidRangeExceptionWithNegativeFromKey
- shouldRestore
- shouldReturnNullOnWindowNotFound
- shouldReturnSameResultsForSingleKeyFetchAndEqualKeyRangeFetch
- shouldThrowNullPointerExceptionOnGetNullKey
- shouldThrowNullPointerExceptionOnPutNullKey
- testBackwardFetchRange
- testDeleteAndUpdate
- testExpiration
- testFetchDuplicates
- testFetchRange
- testPutAndFetchAfter
- testPutAndFetchBefore
- testPutSameKeyTimestamp
- testRangeAndSinglePointFetch
- testValueIteratorPeek
- testWindowIteratorPeek
org.apache.kafka.streams.state.internals.KeyValueIteratorFacadeTest:
- shouldCloseInnerIterator
- shouldForwardHasNext
- shouldForwardPeekNextKey
- shouldReturnPlainKeyValuePairOnGet
org.apache.kafka.streams.state.internals.KeyValueSegmentTest:
- shouldBeEqualIfIdIsEqual
- shouldCompareSegmentIdOnly
- shouldDeleteStateDirectoryOnDestroy
- shouldHashOnSegmentIdOnly
org.apache.kafka.streams.state.internals.KeyValueSegmentsTest:
- futureEventsShouldNotCauseSegmentRoll
- shouldBaseSegmentIntervalOnRetentionAndNumSegments
- shouldCleanupSegmentsThatHaveExpired
- shouldClearSegmentsOnClose
- shouldCloseAllOpenSegments
- shouldCreateSegments
- shouldGetCorrectSegmentString
- shouldGetSegmentForTimestamp
- shouldGetSegmentIdsFromTimestamp
- shouldGetSegmentNameFromId
- shouldGetSegmentsWithinBackwardTimeRange
- shouldGetSegmentsWithinTimeBackwardRangeOutOfOrder
- shouldGetSegmentsWithinTimeRange
- shouldGetSegmentsWithinTimeRangeOutOfOrder
- shouldNotCreateSegmentThatIsAlreadyExpired
- shouldOpenExistingSegments
- shouldRollSegments
- shouldUpdateSegmentFileNameFromOldColonFormatToNewFormat
- shouldUpdateSegmentFileNameFromOldDateFormatToNewFormat
org.apache.kafka.streams.state.internals.KeyValueStoreBuilderTest:
- shouldHaveCachingAndChangeLoggingWhenBothEnabled
- shouldHaveCachingStoreWhenEnabled
- shouldHaveChangeLoggingStoreByDefault
- shouldHaveChangeLoggingStoreWhenLoggingEnabled
- shouldHaveMeteredStoreAsOuterStore
- shouldNotHaveChangeLoggingStoreWhenDisabled
- shouldThrowNullPointerIfInnerIsNull
- shouldThrowNullPointerIfMetricsScopeIsNull
- shouldThrowNullPointerIfTimeIsNull
org.apache.kafka.streams.state.internals.KeyValueStoreWrapperTest:
- shouldCloseTimestampedStore
- shouldCloseVersionedStore
- shouldFlushTimestampedStore
- shouldFlushVersionedStore
- shouldGetFromTimestampedStore
- shouldGetFromVersionedStore
- shouldGetNameForTimestampedStore
- shouldGetNameForVersionedStore
- shouldGetNullFromTimestampedStore
- shouldGetNullFromVersionedStore
- shouldGetPositionForTimestampedStore
- shouldGetPositionForVersionedStore
- shouldGetTimestampedStore
- shouldGetVersionedStore
- shouldInitTimestampedStore
- shouldInitVersionedStore
- shouldPutNullToTimestampedStore
- shouldPutNullToVersionedStore
- shouldPutToTimestampedStore
- shouldPutToVersionedStore
- shouldQueryTimestampedStore
- shouldQueryVersionedStore
- shouldReturnIsOpenForTimestampedStore
- shouldReturnIsOpenForVersionedStore
- shouldReturnPersistentForTimestampedStore
- shouldReturnPersistentForVersionedStore
- shouldThrowOnNonTimestampedOrVersionedStore
org.apache.kafka.streams.state.internals.LeftOrRightValueSerializerTest:
- shouldSerializeIntegerValue
- shouldSerializeStringValue
- shouldThrowIfSerializeOtherValueAsNull
- shouldThrowIfSerializeValueAsNull
org.apache.kafka.streams.state.internals.ListValueStoreTest:
- shouldAllowDeleteWhileIterateRecords
- shouldGetAll
- shouldGetAllNonDeletedRecords
- shouldGetAllReturnTimestampOrderedRecords
- shouldNotReturnMoreDataWhenIteratorClosed
org.apache.kafka.streams.state.internals.LogicalKeyValueSegmentTest:
- shouldCloseOpenIteratorsWhenStoreClosed
- shouldCloseOpenIteratorsWhenStoreWithNegativeIdClosed
- shouldDelete
- shouldDeleteFromSegmentWithNegativeId
- shouldDeleteRange
- shouldDeleteRangeFromSegmentWithNegativeId
- shouldDestroy
- shouldNotDestroySegmentWithNegativeId
- shouldPut
- shouldPutAll
- shouldPutIfAbsent
- shouldReturnAll
- shouldReturnAllFromSegmentWithNegativeId
- shouldReturnValuesOnRange
- shouldReturnValuesOnRangeFromSegmentWithNegativeId
org.apache.kafka.streams.state.internals.LogicalKeyValueSegmentsTest:
- shouldCleanupSegmentsThatHaveExpired
- shouldClearSegmentsOnClose
- shouldCreateReservedSegments
- shouldCreateSegments
- shouldGetSegmentForTimestamp
- shouldGetSegmentIdsFromTimestamp
- shouldGetSegmentsWithinBackwardTimeRange
- shouldGetSegmentsWithinTimeRange
- shouldNotCleanUpReservedSegments
- shouldNotCreateReservedSegmentFromRegularMethod
- shouldNotCreateReservedSegmentWithNonNegativeId
- shouldNotCreateSegmentThatIsAlreadyExpired
org.apache.kafka.streams.state.internals.MaybeTest:
- shouldAnswerIsDefined
- shouldReturnDefinedValue
- shouldThrowOnGetUndefinedValue
- shouldUpholdEqualityCorrectness
- shouldUpholdHashCodeCorrectness
org.apache.kafka.streams.state.internals.MergedSortedCacheKeyValueBytesStoreIteratorTest:
- shouldIgnoreIfDeletedInCacheButExistsInStore
- shouldIterateCacheOnly
- shouldIterateOverRange
- shouldIterateStoreOnly
- shouldNotHaveNextIfAllCachedItemsDeleted
- shouldNotHaveNextIfBothIteratorsInitializedEmpty
- shouldNotHaveNextIfOnlyCacheItemsAndAllDeleted
- shouldPeekNextKey
- shouldPeekNextKeyReverse
- shouldReverseIterateOverRange
- shouldSkipAllDeletedFromCache
- shouldSkipLargerDeletedCacheValue
- shouldSkipSmallerDeletedCachedValue
org.apache.kafka.streams.state.internals.MergedSortedCacheWrappedSessionStoreIteratorTest:
- shouldGetNextFromCache
- shouldGetNextFromReverseCache
- shouldGetNextFromReverseStore
- shouldGetNextFromStore
- shouldHaveNextFromCache
- shouldHaveNextFromReverseCache
- shouldHaveNextFromReverseStore
- shouldHaveNextFromStore
- shouldIterateBothStoreAndCache
- shouldPeekNextKeyFromCache
- shouldPeekNextKeyFromReverseCache
- shouldPeekNextKeyFromReverseStore
- shouldPeekNextKeyFromStore
- shouldReverseIterateBothStoreAndCache
org.apache.kafka.streams.state.internals.MergedSortedCacheWrappedWindowStoreIteratorTest:
- shouldIterateOverValueFromBothIterators
- shouldPeekNextCacheKey
- shouldPeekNextCacheKeyReverse
- shouldPeekNextStoreKey
- shouldPeekNextStoreKeyReverse
- shouldReverseIterateOverValueFromBothIterators
org.apache.kafka.streams.state.internals.MergedSortedCacheWrappedWindowStoreKeyValueIteratorTest:
- shouldGetNextFromCache
- shouldGetNextFromReverseCache
- shouldGetNextFromReverseStore
- shouldGetNextFromStore
- shouldHaveNextFromCache
- shouldHaveNextFromReverseCache
- shouldHaveNextFromReverseStore
- shouldHaveNextFromStore
- shouldIterateBothStoreAndCache
- shouldPeekNextKeyFromCache
- shouldPeekNextKeyFromReverseCache
- shouldPeekNextKeyFromReverseStore
- shouldPeekNextKeyFromStore
- shouldReverseIterateBothStoreAndCache
org.apache.kafka.streams.state.internals.MeteredKeyValueStoreTest:
- shouldDelegateInit
- shouldDeleteFromInnerStoreAndRecordDeleteMetric
- shouldFlushInnerWhenFlushTimeRecords
- shouldGetAllFromInnerStoreAndRecordAllMetric
- shouldGetBytesFromInnerStoreAndReturnGetMetric
- shouldGetRangeFromInnerStoreAndRecordRangeMetric
- shouldGetRecordsWithPrefixKey
- shouldNotSetFlushListenerOnWrappedNoneCachingStore
- shouldNotThrowNullPointerExceptionIfGetReturnsNull
- shouldPassChangelogTopicNameToStateStoreSerde
- shouldPassDefaultChangelogTopicNameToStateStoreSerdeIfLoggingDisabled
- shouldPutAllToInnerStoreAndRecordPutAllMetric
- shouldPutIfAbsentAndRecordPutIfAbsentMetric
- shouldRecordRestoreLatencyOnInit
- shouldRemoveMetricsEvenIfWrappedStoreThrowsOnClose
- shouldRemoveMetricsOnClose
- shouldSetFlushListenerOnWrappedCachingStore
- shouldThrowNullPointerOnDeleteIfKeyIsNull
- shouldThrowNullPointerOnGetIfKeyIsNull
- shouldThrowNullPointerOnPrefixScanIfPrefixIsNull
- shouldThrowNullPointerOnPutAllIfAnyKeyIsNull
- shouldThrowNullPointerOnPutIfAbsentIfKeyIsNull
- shouldThrowNullPointerOnPutIfKeyIsNull
- shouldThrowNullPointerOnRangeIfFromIsNull
- shouldThrowNullPointerOnRangeIfToIsNull
- shouldThrowNullPointerOnReverseRangeIfFromIsNull
- shouldThrowNullPointerOnReverseRangeIfToIsNull
- shouldTimeIteratorDuration
- shouldTrackOldestOpenIteratorTimestamp
- shouldTrackOpenIteratorsMetric
- shouldWriteBytesToInnerStoreAndRecordPutMetric
- testMetrics
org.apache.kafka.streams.state.internals.MeteredSessionStoreTest:
- shouldBackwardFetchForKeyAndRecordFetchMetric
- shouldBackwardFetchRangeFromStoreAndRecordFetchMetric
- shouldBackwardFindSessionRangeFromStoreAndRecordFetchMetric
- shouldBackwardFindSessionsFromStoreAndRecordFetchMetric
- shouldDelegateInit
- shouldFetchForKeyAndRecordFetchMetric
- shouldFetchRangeFromStoreAndRecordFetchMetric
- shouldFindSessionRangeFromStoreAndRecordFetchMetric
- shouldFindSessionsFromStoreAndRecordFetchMetric
- shouldNotFindExpiredSessionRangeFromStore
- shouldNotFindExpiredSessionRangeInBackwardOrderFromStore
- shouldNotSetFlushListenerOnWrappedNoneCachingStore
- shouldNotThrowNullPointerExceptionIfFetchSessionReturnsNull
- shouldPassChangelogTopicNameToStateStoreSerde
- shouldPassDefaultChangelogTopicNameToStateStoreSerdeIfLoggingDisabled
- shouldRecordRestoreTimeOnInit
- shouldRemoveFromStoreAndRecordRemoveMetric
- shouldRemoveMetricsEvenIfWrappedStoreThrowsOnClose
- shouldRemoveMetricsOnClose
- shouldReturnNoSessionsInBackwardOrderWhenFetchedKeyHasExpired
- shouldReturnNoSessionsWhenFetchedKeyHasExpired
- shouldSetFlushListenerOnWrappedCachingStore
- shouldThrowNullPointerOnBackwardFetchIfFromIsNull
- shouldThrowNullPointerOnBackwardFetchIfKeyIsNull
- shouldThrowNullPointerOnBackwardFetchIfToIsNull
- shouldThrowNullPointerOnBackwardFindSessionsIfKeyIsNull
- shouldThrowNullPointerOnBackwardFindSessionsRangeIfFromIsNull
- shouldThrowNullPointerOnBackwardFindSessionsRangeIfToIsNull
- shouldThrowNullPointerOnFetchIfKeyIsNull
- shouldThrowNullPointerOnFetchRangeIfFromIsNull
- shouldThrowNullPointerOnFetchRangeIfToIsNull
- shouldThrowNullPointerOnFetchSessionIfKeyIsNull
- shouldThrowNullPointerOnFindSessionsIfKeyIsNull
- shouldThrowNullPointerOnFindSessionsRangeIfFromIsNull
- shouldThrowNullPointerOnFindSessionsRangeIfToIsNull
- shouldThrowNullPointerOnPutIfKeyIsNull
- shouldThrowNullPointerOnPutIfWindowIsNull
- shouldThrowNullPointerOnPutIfWrappedKeyIsNull
- shouldThrowNullPointerOnRemoveIfKeyIsNull
- shouldThrowNullPointerOnRemoveIfWindowIsNull
- shouldThrowNullPointerOnRemoveIfWrappedKeyIsNull
- shouldTimeIteratorDuration
- shouldTrackOldestOpenIteratorTimestamp
- shouldTrackOpenIteratorsMetric
- shouldWriteBytesToInnerStoreAndRecordPutMetric
- testMetrics
org.apache.kafka.streams.state.internals.MeteredTimestampedKeyValueStoreTest:
- shouldDelegateInit
- shouldDeleteFromInnerStoreAndRecordDeleteMetric
- shouldFlushInnerWhenFlushTimeRecords
- shouldGetAllFromInnerStoreAndRecordAllMetric
- shouldGetBytesFromInnerStoreAndReturnGetMetric
- shouldGetRangeFromInnerStoreAndRecordRangeMetric
- shouldGetWithBinary
- shouldNotPutIfSameValuesAndGreaterTimestamp
- shouldNotSetFlushListenerOnWrappedNoneCachingStore
- shouldNotThrowExceptionIfSerdesCorrectlySetFromConstructorParameters
- shouldNotThrowExceptionIfSerdesCorrectlySetFromProcessorContext
- shouldPassChangelogTopicNameToStateStoreSerde
- shouldPassDefaultChangelogTopicNameToStateStoreSerdeIfLoggingDisabled
- shouldPutAllToInnerStoreAndRecordPutAllMetric
- shouldPutIfAbsentAndRecordPutIfAbsentMetric
- shouldPutIfOutOfOrder
- shouldSetFlushListenerOnWrappedCachingStore
- shouldTimeIteratorDuration
- shouldTrackOldestOpenIteratorTimestamp
- shouldTrackOpenIteratorsMetric
- shouldWriteBytesToInnerStoreAndRecordPutMetric
- testMetrics
org.apache.kafka.streams.state.internals.MeteredTimestampedWindowStoreTest:
- shouldCloseUnderlyingStore
- shouldDelegateInit
- shouldNotExceptionIfFetchReturnsNull
- shouldNotThrowExceptionIfSerdesCorrectlySetFromConstructorParameters
- shouldNotThrowExceptionIfSerdesCorrectlySetFromProcessorContext
- shouldPassChangelogTopicNameToStateStoreSerde
- shouldPassDefaultChangelogTopicNameToStateStoreSerdeIfLoggingDisabled
org.apache.kafka.streams.state.internals.MeteredVersionedKeyValueStoreTest:
- shouldDelegateAndAddExecutionInfoOnCustomQuery
- shouldDelegateAndRecordMetricsOnDelete
- shouldDelegateAndRecordMetricsOnFlush
- shouldDelegateAndRecordMetricsOnGet
- shouldDelegateAndRecordMetricsOnGetWithTimestamp
- shouldDelegateAndRecordMetricsOnPut
- shouldDelegateAndRemoveMetricsOnClose
- shouldDelegateGetPosition
- shouldDelegateInit
- shouldDelegateIsOpen
- shouldDelegateName
- shouldDelegatePersistent
- shouldNotSetFlushListenerIfInnerIsNotCaching
- shouldPassChangelogTopicNameToStateStoreSerde
- shouldPassDefaultChangelogTopicNameToStateStoreSerdeIfLoggingDisabled
- shouldRecordMetricsOnInit
- shouldRemoveMetricsOnCloseEvenIfInnerThrows
- shouldThrowNullPointerOnDeleteIfKeyIsNull
- shouldThrowNullPointerOnGetIfKeyIsNull
- shouldThrowNullPointerOnGetWithTimestampIfKeyIsNull
- shouldThrowNullPointerOnPutIfKeyIsNull
- shouldThrowOnIQv2KeyQuery
- shouldThrowOnIQv2RangeQuery
- shouldThrowOnMultiVersionedKeyQueryInvalidTimeRange
- shouldTimeIteratorDuration
- shouldTrackOldestOpenIteratorTimestamp
- shouldTrackOpenIteratorsMetric
org.apache.kafka.streams.state.internals.MeteredWindowStoreTest:
- shouldBackwardFetchAllFromInnerStoreAndRecordFetchMetrics
- shouldBackwardFetchFromInnerStoreAndRecordFetchMetrics
- shouldBackwardFetchRangeFromInnerStoreAndRecordFetchMetrics
- shouldCloseUnderlyingStore
- shouldDelegateInit
- shouldFetchAllFromInnerStoreAndRecordFetchMetrics
- shouldFetchFromInnerStoreAndRecordFetchMetrics
- shouldFetchRangeFromInnerStoreAndRecordFetchMetrics
- shouldNotSetFlushListenerOnWrappedNoneCachingStore
- shouldNotThrowNullPointerExceptionIfFetchReturnsNull
- shouldPassChangelogTopicNameToStateStoreSerde
- shouldPassDefaultChangelogTopicNameToStateStoreSerdeIfLoggingDisabled
- shouldPutToInnerStoreAndRecordPutMetrics
- shouldRecordFlushLatency
- shouldRecordRestoreLatencyOnInit
- shouldRemoveMetricsEvenIfWrappedStoreThrowsOnClose
- shouldRemoveMetricsOnClose
- shouldReturnNoRecordWhenFetchedKeyHasExpired
- shouldSetFlushListenerOnWrappedCachingStore
- shouldThrowNullPointerOnBackwardFetchIfKeyIsNull
- shouldThrowNullPointerOnFetchIfKeyIsNull
- shouldThrowNullPointerOnPutIfKeyIsNull
- shouldTimeIteratorDuration
- shouldTrackOldestOpenIteratorTimestamp
- shouldTrackOpenIteratorsMetric
- testMetrics
org.apache.kafka.streams.state.internals.Murmur3Test:
- testMurmur3_128
- testMurmur3_32
org.apache.kafka.streams.state.internals.NamedCacheTest:
- shouldBeReentrantAndNotBreakLRU
- shouldDeleteAndUpdateSize
- shouldEvictEldestEntry
- shouldFlushDirtEntriesOnEviction
- shouldKeepTrackOfMostRecentlyAndLeastRecentlyUsed
- shouldKeepTrackOfSize
- shouldNotThrowIllegalArgumentAfterEvictingDirtyRecordAndThenPuttingNewRecordWithSameKey
- shouldNotThrowNullPointerWhenCacheIsEmptyAndEvictionCalled
- shouldOverwriteAll
- shouldPutAll
- shouldPutGet
- shouldPutIfAbsent
- shouldRemoveDeletedValuesOnFlush
- shouldReturnNullIfKeyIsNull
- shouldThrowIllegalStateExceptionWhenTryingToOverwriteDirtyEntryWithCleanEntry
org.apache.kafka.streams.state.internals.OffsetCheckpointTest:
- shouldDeleteExistingCheckpointWhenNoOffsets
- shouldNotWriteCheckpointWhenNoOffsets
- shouldReadAndWriteSentinelOffset
- shouldSkipInvalidOffsetsDuringRead
- shouldThrowIOExceptionWhenWritingToNotExistedFile
- shouldThrowOnInvalidOffsetInWrite
- testReadWrite
org.apache.kafka.streams.state.internals.QueryableStoreProviderTest:
- shouldFindGlobalStores
- shouldReturnKVStoreWhenItExists
- shouldReturnKVStoreWithPartitionWhenItExists
- shouldReturnWindowStoreWhenItExists
- shouldReturnWindowStoreWithPartitionWhenItExists
- shouldThrowExceptionIfKVStoreDoesntExist
- shouldThrowExceptionIfWindowStoreDoesntExist
- shouldThrowExceptionWhenKVStoreWithPartitionDoesntExists
- shouldThrowExceptionWhenLookingForKVStoreWithDifferentType
- shouldThrowExceptionWhenLookingForWindowStoreWithDifferentType
- shouldThrowExceptionWhenWindowStoreWithPartitionDoesntExists
org.apache.kafka.streams.state.internals.ReadOnlyKeyValueStoreFacadeTest:
- shouldForwardApproximateNumEntries
- shouldReturnPlainKeyValuePairsForAllIterator
- shouldReturnPlainKeyValuePairsForPrefixScan
- shouldReturnPlainKeyValuePairsForRangeIterator
- shouldReturnPlainValueOnGet
org.apache.kafka.streams.state.internals.ReadOnlyWindowStoreFacadeTest:
- shouldReturnPlainKeyValuePairsOnAll
- shouldReturnPlainKeyValuePairsOnFetchAllInstantParameters
- shouldReturnPlainKeyValuePairsOnFetchAllLongParameters
- shouldReturnPlainKeyValuePairsOnRangeFetchInstantParameters
- shouldReturnPlainKeyValuePairsOnRangeFetchLongParameters
- shouldReturnPlainKeyValuePairsOnSingleKeyFetch
- shouldReturnPlainKeyValuePairsOnSingleKeyFetchInstantParameters
- shouldReturnPlainKeyValuePairsOnSingleKeyFetchLongParameters
org.apache.kafka.streams.state.internals.RecordConvertersTest:
- shouldAddTimestampToValueOnConversionWhenValueIsNotNull
- shouldPreserveNullValueOnConversion
org.apache.kafka.streams.state.internals.RocksDBGenericOptionsToDbOptionsColumnFamilyOptionsAdapterTest:
- shouldForwardAllColumnFamilyCalls
- shouldForwardAllDbOptionsCalls
- shouldLogWarningWhenSettingWalOptions
- shouldOverwriteAllOptionsMethods
org.apache.kafka.streams.state.internals.RocksDBRangeIteratorTest:
- shouldCallCloseCallbackOnClose
- shouldCloseIterator
- shouldExcludeEndOfRange
- shouldReturnAllKeysInPartiallyOverlappingRangeInForwardDirection
- shouldReturnAllKeysInPartiallyOverlappingRangeInReverseDirection
- shouldReturnAllKeysInTheRangeInForwardDirection
- shouldReturnAllKeysInTheRangeReverseDirection
- shouldReturnAllKeysWhenLastKeyIsGreaterThanLargestKeyInStateStoreInForwardDirection
- shouldReturnAllKeysWhenLastKeyIsSmallerThanSmallestKeyInStateStoreInReverseDirection
- shouldReturnNoKeysWhenLastKeyIsLargerThanLargestKeyInStateStoreReverseDirection
- shouldReturnNoKeysWhenLastKeyIsSmallerThanSmallestKeyInStateStoreForwardDirection
- shouldReturnTheCurrentKeyOnInvokingPeekNextKeyInForwardDirection
- shouldReturnTheCurrentKeyOnInvokingPeekNextKeyInReverseDirection
org.apache.kafka.streams.state.internals.RocksDBSegmentedBytesStoreTest:
- shouldBeAbleToWriteToReInitializedStore
- shouldCreateWriteBatches
- shouldFetchAllSegments
- shouldFindValuesWithinRange
- shouldGetAllSegments
- shouldHandleTombstoneRecords
- shouldLoadSegmentsWithOldStyleColonFormattedName
- shouldLoadSegmentsWithOldStyleDateFormattedName
- shouldMatchPositionAfterPut
- shouldMeasureExpiredRecords
- shouldNotThrowWhenRestoringOnMissingHeaders
- shouldPutAndBackwardFetch
- shouldPutAndFetch
- shouldRemove
- shouldRestoreRecordsAndConsistencyVectorMultipleTopics
- shouldRestoreRecordsAndConsistencyVectorSingleTopic
- shouldRestoreToByteStoreForActiveTask
- shouldRestoreToByteStoreForStandbyTask
- shouldRollSegments
org.apache.kafka.streams.state.internals.RocksDBSessionStoreTest:
- shouldBackwardFetchAllSessionsWithSameRecordKey
- shouldBackwardFetchAllSessionsWithinKeyRange
- shouldBackwardFetchAndIterateOverExactBinaryKeys
- shouldBackwardFetchExactKeys
- shouldBackwardFindSessionsToMerge
- shouldBackwardFindValuesWithinMergingSessionWindowRange
- shouldCloseOpenIteratorsWhenStoreIsClosedAndNotThrowInvalidStateStoreExceptionOnHasNext
- shouldFetchAllSessionsWithSameRecordKey
- shouldFetchAllSessionsWithinKeyRange
- shouldFetchAndIterateOverExactBinaryKeys
- shouldFetchExactKeys
- shouldFetchExactSession
- shouldFindSessionsForTimeRange
- shouldFindSessionsToMerge
- shouldFindValuesWithinMergingSessionWindowRange
- shouldMatchPositionAfterPut
- shouldMeasureExpiredRecords
- shouldNotFetchExpiredSessions
- shouldNotThrowExceptionRemovingNonexistentKey
- shouldNotThrowInvalidRangeExceptionWithNegativeFromKey
- shouldPutAndBackwardFindSessionsInRange
- shouldPutAndFindSessionsInRange
- shouldRemove
- shouldRemoveExpired
- shouldRemoveOnNullAggValue
- shouldRestore
- shouldReturnNullOnSessionNotFound
- shouldReturnSameResultsForSingleKeyFindSessionsAndEqualKeyRangeFindSessions
- shouldThrowNullPointerExceptionOnFetchNullKey
- shouldThrowNullPointerExceptionOnFindSessionsNullKey
- shouldThrowNullPointerExceptionOnPutNullKey
- shouldThrowNullPointerExceptionOnRemoveNullKey
- testIteratorPeek
- testIteratorPeekBackward
org.apache.kafka.streams.state.internals.RocksDBStoreTest:
- prefixScanShouldNotThrowConcurrentModificationException
- shouldAddValueProvidersWithStatisticsToInjectedMetricsRecorderWhenRecordingLevelDebug
- shouldAddValueProvidersWithoutStatisticsToInjectedMetricsRecorderWhenRecordingLevelInfo
- shouldAllowCustomManagedIterators
- shouldCallRocksDbConfigSetter
- shouldCloseOpenRangeIteratorsWhenStoreClosedAndThrowInvalidStateStoreOnHasNextAndNext
- shouldCloseStatisticsWhenUserProvidesNoStatistics
- shouldCloseStatisticsWhenUserProvidesStatistics
- shouldDeleteFromStore
- shouldDeleteIfSerializedValueIsNull
- shouldHandleDeletesAndPutBackOnRestoreAll
- shouldHandleDeletesOnRestoreAll
- shouldHandleToggleOfEnablingBloomFilters
- shouldHandleTombstoneRecords
- shouldMatchPositionAfterPut
- shouldNotAllowOpenIteratorsWhenUsingAutoManagedIterators
- shouldNotIncludeDeletedFromRangeResult
- shouldNotSetCacheInValueProvidersWhenUserProvidesPlainTableFormatConfig
- shouldNotSetStatisticsInValueProvidersWhenUserProvidesStatistics
- shouldNotThrowConcurrentModificationException
- shouldNotThrowExceptionOnRestoreWhenThereIsPreExistingRocksDbFiles
- shouldNotThrowInvalidRangeExceptionWithFromLargerThanTo
- shouldNotThrowInvalidRangeExceptionWithNegativeFromKey
- shouldNotThrowInvalidReverseRangeExceptionWithFromLargerThanTo
- shouldNotThrowInvalidReverseRangeExceptionWithNegativeFromKey
- shouldNotThrowNullPointerExceptionOnPutAllNullKey
- shouldNotThrowNullPointerExceptionOnPutIfAbsentNullValue
- shouldNotThrowNullPointerExceptionOnPutNullValue
- shouldNotThrowWhenRestoringOnMissingHeaders
- shouldPerformAllQueriesWithCachingDisabled
- shouldPerformRangeQueriesWithCachingDisabled
- shouldPutAll
- shouldPutOnlyIfAbsentValue
- shouldPutReverseAll
- shouldRemoveValueProvidersFromInjectedMetricsRecorderOnClose
- shouldRequireOpenIteratorsWhenUsingCustomManagedIterators
- shouldRestoreAll
- shouldRestoreRecordsAndConsistencyVectorMultipleTopics
- shouldRestoreRecordsAndConsistencyVectorSingleTopic
- shouldRestoreThenDeleteOnRestoreAll
- shouldReturnKeysWithGivenPrefix
- shouldReturnKeysWithGivenPrefixExcludingNextKeyLargestKey
- shouldReturnNoKeys
- shouldReturnSameResultsForGetAndRangeWithEqualKeys
- shouldReturnSameResultsForGetAndReverseRangeWithEqualKeys
- shouldReturnUUIDsWithStringPrefix
- shouldReturnValueOnRange
- shouldReturnValueOnRangeKeyToNull
- shouldReturnValueOnRangeNullToKey
- shouldReturnValueOnRangeNullToNull
- shouldReturnValueOnReverseRangeKeyToNull
- shouldReturnValueOnReverseRangeNullToKey
- shouldReturnValueOnReverseRangeNullToNull
- shouldSetStatisticsInValueProvidersWhenUserProvidesNoStatistics
- shouldThrowNullPointerExceptionOnDelete
- shouldThrowNullPointerExceptionOnDeleteNullKey
- shouldThrowNullPointerExceptionOnGetNullKey
- shouldThrowNullPointerExceptionOnNullGet
- shouldThrowNullPointerExceptionOnNullPut
- shouldThrowNullPointerExceptionOnNullPutAll
- shouldThrowNullPointerExceptionOnPutAllNullKey
- shouldThrowNullPointerExceptionOnPutIfAbsentNullKey
- shouldThrowNullPointerExceptionOnPutNullKey
- shouldThrowProcessorStateExceptionOnOpeningReadOnlyDir
- shouldThrowProcessorStateExceptionOnPutDeletedDir
- shouldThrowWhenUserProvidesNewBlockBasedTableFormatConfig
- shouldVerifyThatMetricsRecordedFromPropertiesGetMeasurementsFromRocksDB
- shouldVerifyThatMetricsRecordedFromStatisticsGetMeasurementsFromRocksDB
- shouldVerifyThatPropertyBasedMetricsUseValidPropertyName
- testPutGetRange
- testPutGetReverseRange
- testPutGetWithDefaultSerdes
- testPutIfAbsent
- testRestore
- testRestoreWithDefaultSerdes
- testSize
org.apache.kafka.streams.state.internals.RocksDBTimeOrderedKeyValueBufferTest:
- shouldAddAndEvictRecord
- shouldAddAndEvictRecordTwice
- shouldAddAndEvictRecordTwiceWithNonZeroGrace
- shouldAddRecordsTwiceAndEvictRecordsOnce
- shouldDropLateRecords
- shouldDropLateRecordsWithNonZeroGrace
- shouldHandleCollidingKeys
- shouldPutInBufferAndUpdateFields
- shouldReturnIfRecordWasAdded
org.apache.kafka.streams.state.internals.RocksDBTimeOrderedKeyValueBytesStoreTest:
- shouldCreateEmptyWriteBatches
- shouldCreateWriteBatches
org.apache.kafka.streams.state.internals.RocksDBTimeOrderedSessionSchemaWithIndexSegmentedBytesStoreTest:
- shouldBeAbleToWriteToReInitializedStore
- shouldCreateWriteBatches
- shouldFetchAllSegments
- shouldFetchSessionForSingleKey
- shouldFetchSessionForTimeRange
- shouldFindValuesWithinRange
- shouldGetAllBackwards
- shouldGetAllSegments
- shouldHandleTombstoneRecords
- shouldLoadSegmentsWithOldStyleColonFormattedName
- shouldLoadSegmentsWithOldStyleDateFormattedName
- shouldMatchPositionAfterPut
- shouldMeasureExpiredRecords
- shouldNotThrowWhenRestoringOnMissingHeaders
- shouldPutAndBackwardFetch
- shouldPutAndBackwardFetchEdgeKeyRange
- shouldPutAndBackwardFetchEdgeSingleKey
- shouldPutAndBackwardFetchWithPrefix
- shouldPutAndFetch
- shouldPutAndFetchEdgeKeyRange
- shouldPutAndFetchEdgeSingleKey
- shouldPutAndFetchWithPrefixKey
- shouldRemove
- shouldRestoreRecordsAndConsistencyVectorMultipleTopics
- shouldRestoreRecordsAndConsistencyVectorSingleTopic
- shouldRestoreToByteStoreForActiveTask
- shouldRestoreToByteStoreForStandbyTask
- shouldRollSegments
- shouldSkipAndRemoveDanglingIndex
org.apache.kafka.streams.state.internals.RocksDBTimeOrderedSessionSchemaWithoutIndexSegmentedBytesStoreTest:
- shouldBeAbleToWriteToReInitializedStore
- shouldCreateWriteBatches
- shouldFetchAllSegments
- shouldFetchSessionForSingleKey
- shouldFetchSessionForTimeRange
- shouldFindValuesWithinRange
- shouldGetAllBackwards
- shouldGetAllSegments
- shouldHandleTombstoneRecords
- shouldLoadSegmentsWithOldStyleColonFormattedName
- shouldLoadSegmentsWithOldStyleDateFormattedName
- shouldMatchPositionAfterPut
- shouldMeasureExpiredRecords
- shouldNotThrowWhenRestoringOnMissingHeaders
- shouldPutAndBackwardFetch
- shouldPutAndBackwardFetchEdgeKeyRange
- shouldPutAndBackwardFetchEdgeSingleKey
- shouldPutAndBackwardFetchWithPrefix
- shouldPutAndFetch
- shouldPutAndFetchEdgeKeyRange
- shouldPutAndFetchEdgeSingleKey
- shouldPutAndFetchWithPrefixKey
- shouldRemove
- shouldRestoreRecordsAndConsistencyVectorMultipleTopics
- shouldRestoreRecordsAndConsistencyVectorSingleTopic
- shouldRestoreToByteStoreForActiveTask
- shouldRestoreToByteStoreForStandbyTask
- shouldRollSegments
- shouldSkipAndRemoveDanglingIndex
org.apache.kafka.streams.state.internals.RocksDBTimeOrderedSessionStoreWithIndexTest:
- shouldBackwardFetchAllSessionsWithSameRecordKey
- shouldBackwardFetchAllSessionsWithinKeyRange
- shouldBackwardFetchAndIterateOverExactBinaryKeys
- shouldBackwardFetchExactKeys
- shouldBackwardFindSessionsToMerge
- shouldBackwardFindValuesWithinMergingSessionWindowRange
- shouldCloseOpenIteratorsWhenStoreIsClosedAndNotThrowInvalidStateStoreExceptionOnHasNext
- shouldFetchAllSessionsWithSameRecordKey
- shouldFetchAllSessionsWithinKeyRange
- shouldFetchAndIterateOverExactBinaryKeys
- shouldFetchExactKeys
- shouldFetchExactSession
- shouldFindSessionsForTimeRange
- shouldFindSessionsToMerge
- shouldFindValuesWithinMergingSessionWindowRange
- shouldMatchPositionAfterPut
- shouldMeasureExpiredRecords
- shouldNotFetchExpiredSessions
- shouldNotThrowExceptionRemovingNonexistentKey
- shouldNotThrowInvalidRangeExceptionWithNegativeFromKey
- shouldPutAndBackwardFindSessionsInRange
- shouldPutAndFindSessionsInRange
- shouldRemove
- shouldRemoveExpired
- shouldRemoveOnNullAggValue
- shouldRestore
- shouldReturnNullOnSessionNotFound
- shouldReturnSameResultsForSingleKeyFindSessionsAndEqualKeyRangeFindSessions
- shouldThrowNullPointerExceptionOnFetchNullKey
- shouldThrowNullPointerExceptionOnFindSessionsNullKey
- shouldThrowNullPointerExceptionOnPutNullKey
- shouldThrowNullPointerExceptionOnRemoveNullKey
- testIteratorPeek
- testIteratorPeekBackward
org.apache.kafka.streams.state.internals.RocksDBTimeOrderedSessionStoreWithoutIndexTest:
- shouldBackwardFetchAllSessionsWithSameRecordKey
- shouldBackwardFetchAllSessionsWithinKeyRange
- shouldBackwardFetchAndIterateOverExactBinaryKeys
- shouldBackwardFetchExactKeys
- shouldBackwardFindSessionsToMerge
- shouldBackwardFindValuesWithinMergingSessionWindowRange
- shouldCloseOpenIteratorsWhenStoreIsClosedAndNotThrowInvalidStateStoreExceptionOnHasNext
- shouldFetchAllSessionsWithSameRecordKey
- shouldFetchAllSessionsWithinKeyRange
- shouldFetchAndIterateOverExactBinaryKeys
- shouldFetchExactKeys
- shouldFetchExactSession
- shouldFindSessionsForTimeRange
- shouldFindSessionsToMerge
- shouldFindValuesWithinMergingSessionWindowRange
- shouldMatchPositionAfterPut
- shouldMeasureExpiredRecords
- shouldNotFetchExpiredSessions
- shouldNotThrowExceptionRemovingNonexistentKey
- shouldNotThrowInvalidRangeExceptionWithNegativeFromKey
- shouldPutAndBackwardFindSessionsInRange
- shouldPutAndFindSessionsInRange
- shouldRemove
- shouldRemoveExpired
- shouldRemoveOnNullAggValue
- shouldRestore
- shouldReturnNullOnSessionNotFound
- shouldReturnSameResultsForSingleKeyFindSessionsAndEqualKeyRangeFindSessions
- shouldThrowNullPointerExceptionOnFetchNullKey
- shouldThrowNullPointerExceptionOnFindSessionsNullKey
- shouldThrowNullPointerExceptionOnPutNullKey
- shouldThrowNullPointerExceptionOnRemoveNullKey
- testIteratorPeek
- testIteratorPeekBackward
org.apache.kafka.streams.state.internals.RocksDBTimeOrderedWindowSchemaWithIndexSegmentedBytesStoreTest:
- shouldBeAbleToWriteToReInitializedStore
- shouldCreateWriteBatches
- shouldFetchAllSegments
- shouldFetchSessionForSingleKey
- shouldFetchSessionForTimeRange
- shouldFindValuesWithinRange
- shouldGetAllBackwards
- shouldGetAllSegments
- shouldHandleTombstoneRecords
- shouldLoadSegmentsWithOldStyleColonFormattedName
- shouldLoadSegmentsWithOldStyleDateFormattedName
- shouldMatchPositionAfterPut
- shouldMeasureExpiredRecords
- shouldNotThrowWhenRestoringOnMissingHeaders
- shouldPutAndBackwardFetch
- shouldPutAndBackwardFetchEdgeKeyRange
- shouldPutAndBackwardFetchEdgeSingleKey
- shouldPutAndBackwardFetchWithPrefix
- shouldPutAndFetch
- shouldPutAndFetchEdgeKeyRange
- shouldPutAndFetchEdgeSingleKey
- shouldPutAndFetchWithPrefixKey
- shouldRemove
- shouldRestoreRecordsAndConsistencyVectorMultipleTopics
- shouldRestoreRecordsAndConsistencyVectorSingleTopic
- shouldRestoreToByteStoreForActiveTask
- shouldRestoreToByteStoreForStandbyTask
- shouldRollSegments
- shouldSkipAndRemoveDanglingIndex
org.apache.kafka.streams.state.internals.RocksDBTimeOrderedWindowSchemaWithoutIndexSegmentedBytesStoreTest:
- shouldBeAbleToWriteToReInitializedStore
- shouldCreateWriteBatches
- shouldFetchAllSegments
- shouldFetchSessionForSingleKey
- shouldFetchSessionForTimeRange
- shouldFindValuesWithinRange
- shouldGetAllBackwards
- shouldGetAllSegments
- shouldHandleTombstoneRecords
- shouldLoadSegmentsWithOldStyleColonFormattedName
- shouldLoadSegmentsWithOldStyleDateFormattedName
- shouldMatchPositionAfterPut
- shouldMeasureExpiredRecords
- shouldNotThrowWhenRestoringOnMissingHeaders
- shouldPutAndBackwardFetch
- shouldPutAndBackwardFetchEdgeKeyRange
- shouldPutAndBackwardFetchEdgeSingleKey
- shouldPutAndBackwardFetchWithPrefix
- shouldPutAndFetch
- shouldPutAndFetchEdgeKeyRange
- shouldPutAndFetchEdgeSingleKey
- shouldPutAndFetchWithPrefixKey
- shouldRemove
- shouldRestoreRecordsAndConsistencyVectorMultipleTopics
- shouldRestoreRecordsAndConsistencyVectorSingleTopic
- shouldRestoreToByteStoreForActiveTask
- shouldRestoreToByteStoreForStandbyTask
- shouldRollSegments
- shouldSkipAndRemoveDanglingIndex
org.apache.kafka.streams.state.internals.RocksDBTimeOrderedWindowStoreWithIndexTest:
- shouldBackwardFetchAllInTimeRange
- shouldCloseOpenIteratorsWhenStoreIsClosedAndNotThrowInvalidStateStoreExceptionOnHasNext
- shouldEarlyClosedIteratorStillGetAllRecords
- shouldFetchAllInTimeRange
- shouldFetchAndIterateOverExactBinaryKeys
- shouldFetchAndIterateOverExactKeys
- shouldGetAll
- shouldGetAllNonDeletedRecords
- shouldGetAllReturnTimestampOrderedRecords
- shouldGetBackwardAll
- shouldMatchPositionAfterPut
- shouldMeasureExpiredRecords
- shouldNotThrowConcurrentModificationException
- shouldNotThrowExceptionWhenFetchRangeIsExpired
- shouldNotThrowInvalidRangeExceptionWithNegativeFromKey
- shouldOnlyIterateOpenSegments
- shouldReturnNullOnWindowNotFound
- shouldReturnSameResultsForSingleKeyFetchAndEqualKeyRangeFetch
- shouldThrowNullPointerExceptionOnGetNullKey
- shouldThrowNullPointerExceptionOnPutNullKey
- testBackwardFetchRange
- testDeleteAndUpdate
- testFetchDuplicates
- testFetchRange
- testInitialLoading
- testPutAndFetchAfter
- testPutAndFetchBefore
- testPutSameKeyTimestamp
- testRangeAndSinglePointFetch
- testRestore
- testRolling
- testSegmentMaintenance
- testValueIteratorPeek
- testWindowIteratorPeek
org.apache.kafka.streams.state.internals.RocksDBTimeOrderedWindowStoreWithoutIndexTest:
- shouldBackwardFetchAllInTimeRange
- shouldCloseOpenIteratorsWhenStoreIsClosedAndNotThrowInvalidStateStoreExceptionOnHasNext
- shouldEarlyClosedIteratorStillGetAllRecords
- shouldFetchAllInTimeRange
- shouldFetchAndIterateOverExactBinaryKeys
- shouldFetchAndIterateOverExactKeys
- shouldGetAll
- shouldGetAllNonDeletedRecords
- shouldGetAllReturnTimestampOrderedRecords
- shouldGetBackwardAll
- shouldMatchPositionAfterPut
- shouldMeasureExpiredRecords
- shouldNotThrowConcurrentModificationException
- shouldNotThrowExceptionWhenFetchRangeIsExpired
- shouldNotThrowInvalidRangeExceptionWithNegativeFromKey
- shouldOnlyIterateOpenSegments
- shouldReturnNullOnWindowNotFound
- shouldReturnSameResultsForSingleKeyFetchAndEqualKeyRangeFetch
- shouldThrowNullPointerExceptionOnGetNullKey
- shouldThrowNullPointerExceptionOnPutNullKey
- testBackwardFetchRange
- testDeleteAndUpdate
- testFetchDuplicates
- testFetchRange
- testInitialLoading
- testPutAndFetchAfter
- testPutAndFetchBefore
- testPutSameKeyTimestamp
- testRangeAndSinglePointFetch
- testRestore
- testRolling
- testSegmentMaintenance
- testValueIteratorPeek
- testWindowIteratorPeek
org.apache.kafka.streams.state.internals.RocksDBTimestampedSegmentedBytesStoreTest:
- shouldBeAbleToWriteToReInitializedStore
- shouldCreateWriteBatches
- shouldFetchAllSegments
- shouldFindValuesWithinRange
- shouldGetAllSegments
- shouldHandleTombstoneRecords
- shouldLoadSegmentsWithOldStyleColonFormattedName
- shouldLoadSegmentsWithOldStyleDateFormattedName
- shouldMatchPositionAfterPut
- shouldMeasureExpiredRecords
- shouldNotThrowWhenRestoringOnMissingHeaders
- shouldPutAndBackwardFetch
- shouldPutAndFetch
- shouldRemove
- shouldRestoreRecordsAndConsistencyVectorMultipleTopics
- shouldRestoreRecordsAndConsistencyVectorSingleTopic
- shouldRestoreToByteStoreForActiveTask
- shouldRestoreToByteStoreForStandbyTask
- shouldRollSegments
org.apache.kafka.streams.state.internals.RocksDBTimestampedStoreTest:
- prefixScanShouldNotThrowConcurrentModificationException
- shouldAddValueProvidersWithStatisticsToInjectedMetricsRecorderWhenRecordingLevelDebug
- shouldAddValueProvidersWithoutStatisticsToInjectedMetricsRecorderWhenRecordingLevelInfo
- shouldAllowCustomManagedIterators
- shouldCallRocksDbConfigSetter
- shouldCloseOpenRangeIteratorsWhenStoreClosedAndThrowInvalidStateStoreOnHasNextAndNext
- shouldCloseStatisticsWhenUserProvidesNoStatistics
- shouldCloseStatisticsWhenUserProvidesStatistics
- shouldDeleteFromStore
- shouldDeleteIfSerializedValueIsNull
- shouldHandleDeletesAndPutBackOnRestoreAll
- shouldHandleDeletesOnRestoreAll
- shouldHandleToggleOfEnablingBloomFilters
- shouldHandleTombstoneRecords
- shouldMatchPositionAfterPut
- shouldMigrateDataFromDefaultToTimestampColumnFamily
- shouldNotAllowOpenIteratorsWhenUsingAutoManagedIterators
- shouldNotIncludeDeletedFromRangeResult
- shouldNotSetCacheInValueProvidersWhenUserProvidesPlainTableFormatConfig
- shouldNotSetStatisticsInValueProvidersWhenUserProvidesStatistics
- shouldNotThrowConcurrentModificationException
- shouldNotThrowExceptionOnRestoreWhenThereIsPreExistingRocksDbFiles
- shouldNotThrowInvalidRangeExceptionWithFromLargerThanTo
- shouldNotThrowInvalidRangeExceptionWithNegativeFromKey
- shouldNotThrowInvalidReverseRangeExceptionWithFromLargerThanTo
- shouldNotThrowInvalidReverseRangeExceptionWithNegativeFromKey
- shouldNotThrowNullPointerExceptionOnPutAllNullKey
- shouldNotThrowNullPointerExceptionOnPutIfAbsentNullValue
- shouldNotThrowNullPointerExceptionOnPutNullValue
- shouldNotThrowWhenRestoringOnMissingHeaders
- shouldOpenExistingStoreInRegularMode
- shouldOpenNewStoreInRegularMode
- shouldPerformAllQueriesWithCachingDisabled
- shouldPerformRangeQueriesWithCachingDisabled
- shouldPutAll
- shouldPutOnlyIfAbsentValue
- shouldPutReverseAll
- shouldRemoveValueProvidersFromInjectedMetricsRecorderOnClose
- shouldRequireOpenIteratorsWhenUsingCustomManagedIterators
- shouldRestoreAll
- shouldRestoreRecordsAndConsistencyVectorMultipleTopics
- shouldRestoreRecordsAndConsistencyVectorSingleTopic
- shouldRestoreThenDeleteOnRestoreAll
- shouldReturnKeysWithGivenPrefix
- shouldReturnKeysWithGivenPrefixExcludingNextKeyLargestKey
- shouldReturnNoKeys
- shouldReturnSameResultsForGetAndRangeWithEqualKeys
- shouldReturnSameResultsForGetAndReverseRangeWithEqualKeys
- shouldReturnUUIDsWithStringPrefix
- shouldReturnValueOnRange
- shouldReturnValueOnRangeKeyToNull
- shouldReturnValueOnRangeNullToKey
- shouldReturnValueOnRangeNullToNull
- shouldReturnValueOnReverseRangeKeyToNull
- shouldReturnValueOnReverseRangeNullToKey
- shouldReturnValueOnReverseRangeNullToNull
- shouldSetStatisticsInValueProvidersWhenUserProvidesNoStatistics
- shouldThrowNullPointerExceptionOnDelete
- shouldThrowNullPointerExceptionOnDeleteNullKey
- shouldThrowNullPointerExceptionOnGetNullKey
- shouldThrowNullPointerExceptionOnNullGet
- shouldThrowNullPointerExceptionOnNullPut
- shouldThrowNullPointerExceptionOnNullPutAll
- shouldThrowNullPointerExceptionOnPutAllNullKey
- shouldThrowNullPointerExceptionOnPutIfAbsentNullKey
- shouldThrowNullPointerExceptionOnPutNullKey
- shouldThrowProcessorStateExceptionOnOpeningReadOnlyDir
- shouldThrowProcessorStateExceptionOnPutDeletedDir
- shouldThrowWhenUserProvidesNewBlockBasedTableFormatConfig
- shouldVerifyThatMetricsRecordedFromPropertiesGetMeasurementsFromRocksDB
- shouldVerifyThatMetricsRecordedFromStatisticsGetMeasurementsFromRocksDB
- shouldVerifyThatPropertyBasedMetricsUseValidPropertyName
- testPutGetRange
- testPutGetReverseRange
- testPutGetWithDefaultSerdes
- testPutIfAbsent
- testRestore
- testRestoreWithDefaultSerdes
- testSize
org.apache.kafka.streams.state.internals.RocksDBVersionedStoreSegmentValueFormatterTest:
- shouldBuildWithInsertEarliest
- shouldBuildWithInsertLatest
- shouldCreateNewWithRecord
- shouldFindAll
- shouldFindByTimestamp
- shouldGetTimestamps
- shouldInsertAtIndex
- shouldRecoverFromStoreInconsistencyOnInsertLatest
- shouldSerializeAndDeserialize
- shouldUpdateAtIndex
org.apache.kafka.streams.state.internals.RocksDBVersionedStoreTest:
- shouldAllowZeroHistoryRetention
- shouldDelete
- shouldDistinguishEmptyAndNull
- shouldFallThroughToExistingOlderSegmentAsLatestDuringPut
- shouldGetExpiredIfLatestValue
- shouldGetExpiredIfLatestVersionValue
- shouldGetFromOlderSegments
- shouldGetRecordVersionsFromMultipleOldSegmentsInAscendingOrder
- shouldGetRecordVersionsFromOlderSegments
- shouldGetRecordVersionsInAscendingOrder
- shouldMoveRecordToOlderSegmentDuringPut
- shouldMoveRecordToOlderSegmentWithNullsDuringPut
- shouldNotDeleteExpired
- shouldNotGetExpired
- shouldNotGetExpiredRecordVersions
- shouldNotPutExpired
- shouldNotRestoreExpired
- shouldPutIntoMultipleSegments
- shouldPutLatest
- shouldPutNonLatestTombstoneIntoNewSegmentWithValidTo
- shouldPutNullAsLatest
- shouldPutOlderNullWithNonNullLatest
- shouldPutOlderNullWithNullLatest
- shouldPutOlderWithNonNullLatest
- shouldPutOlderWithNullLatest
- shouldPutRepeatTimestampAsLatest
- shouldPutRepeatTimestamps
- shouldRestore
- shouldRestoreEvenIfRecordWouldBeExpiredByEndOfBatch
- shouldRestoreMultipleBatches
- shouldRestoreWithNulls
- shouldRestoreWithNullsAndRepeatTimestamps
org.apache.kafka.streams.state.internals.RocksDBWindowStoreTest:
- shouldBackwardFetchAllInTimeRange
- shouldCloseOpenIteratorsWhenStoreIsClosedAndNotThrowInvalidStateStoreExceptionOnHasNext
- shouldEarlyClosedIteratorStillGetAllRecords
- shouldFetchAllInTimeRange
- shouldFetchAndIterateOverExactBinaryKeys
- shouldFetchAndIterateOverExactKeys
- shouldGetAll
- shouldGetAllNonDeletedRecords
- shouldGetAllReturnTimestampOrderedRecords
- shouldGetBackwardAll
- shouldMatchPositionAfterPut
- shouldMeasureExpiredRecords
- shouldNotThrowConcurrentModificationException
- shouldNotThrowExceptionWhenFetchRangeIsExpired
- shouldNotThrowInvalidRangeExceptionWithNegativeFromKey
- shouldOnlyIterateOpenSegments
- shouldReturnNullOnWindowNotFound
- shouldReturnSameResultsForSingleKeyFetchAndEqualKeyRangeFetch
- shouldThrowNullPointerExceptionOnGetNullKey
- shouldThrowNullPointerExceptionOnPutNullKey
- testBackwardFetchRange
- testDeleteAndUpdate
- testFetchDuplicates
- testFetchRange
- testInitialLoading
- testPutAndFetchAfter
- testPutAndFetchBefore
- testPutSameKeyTimestamp
- testRangeAndSinglePointFetch
- testRestore
- testRolling
- testSegmentMaintenance
- testValueIteratorPeek
- testWindowIteratorPeek
org.apache.kafka.streams.state.internals.RocksDbIndexedTimeOrderedWindowBytesStoreSupplierTest:
- shouldCreateRocksDbTimeOrderedWindowStoreWithIndex
- shouldCreateRocksDbTimeOrderedWindowStoreWithoutIndex
- shouldThrowIfRetentionPeriodIsNegative
- shouldThrowIfStoreNameIsNull
- shouldThrowIfWindowSizeIsLargerThanRetention
- shouldThrowIfWindowSizeIsNegative
org.apache.kafka.streams.state.internals.RocksDbVersionedKeyValueBytesStoreSupplierTest:
- shouldUseDefaultSegmentInterval
org.apache.kafka.streams.state.internals.SegmentIteratorTest:
- shouldIterateBackwardOverAllSegments
- shouldIterateBackwardOverAllSegmentsWhenNullKeyFromKeyTo
- shouldIterateOverAllSegments
- shouldIterateOverAllSegmentsWhenNullKeyFromKeyTo
- shouldNotThrowExceptionOnHasNextWhenStoreClosed
- shouldOnlyIterateOverSegmentsInBackwardRange
- shouldOnlyIterateOverSegmentsInBackwardRangeWhenNullKeyFrom
- shouldOnlyIterateOverSegmentsInBackwardRangeWhenNullKeyTo
- shouldOnlyIterateOverSegmentsInRange
- shouldOnlyIterateOverSegmentsInRangeWhenNullKeyFrom
- shouldOnlyIterateOverSegmentsInRangeWhenNullKeyTo
- shouldThrowNoSuchElementOnNextIfNoNext
- shouldThrowNoSuchElementOnPeekNextKeyIfNoNext
org.apache.kafka.streams.state.internals.SegmentedCacheFunctionTest:
- cacheKey
- compareSegmentedKeys
- testKey
- testRoundTripping
org.apache.kafka.streams.state.internals.SessionKeySchemaTest:
- shouldConvertToBinaryAndBack
- shouldDeSerializeEmptyByteArrayToNull
- shouldDeSerializeNullToNull
- shouldExtractBytesKeyFromBinary
- shouldExtractEndTimeFromBinary
- shouldExtractKeyBytesFromBinary
- shouldExtractKeyFromBinary
- shouldExtractStartTimeFromBinary
- shouldExtractWindowFromBindary
- shouldFetchAllKeysUsingNullKeys
- shouldFetchExactKeySkippingShorterKeys
- shouldFetchExactKeysSkippingLongerKeys
- shouldSerializeDeserialize
- shouldSerializeNullToNull
- testLowerBoundMatchesTrailingZeros
- testLowerBoundWithZeroTimestamp
- testUpperBoundWithKeyBytesLargerThanFirstTimestampByte
- testUpperBoundWithLargeTimestamps
- testUpperBoundWithZeroTimestamp
org.apache.kafka.streams.state.internals.SessionStoreBuilderTest:
- shouldHaveCachingAndChangeLoggingWhenBothEnabled
- shouldHaveCachingStoreWhenEnabled
- shouldHaveChangeLoggingStoreByDefault
- shouldHaveChangeLoggingStoreWhenLoggingEnabled
- shouldHaveMeteredStoreAsOuterStore
- shouldNotHaveChangeLoggingStoreWhenDisabled
- shouldThrowNullPointerIfMetricsScopeIsNull
- shouldThrowNullPointerIfNameIsNull
- shouldThrowNullPointerIfStoreSupplierIsNull
- shouldThrowNullPointerIfTimeIsNull
org.apache.kafka.streams.state.internals.SessionStoreFetchTest:
- testStoreConfig
org.apache.kafka.streams.state.internals.StoreQueryUtilsTest:
- shouldReturnErrorOnBoundViolation
- shouldReturnErrorOnNullContext
org.apache.kafka.streams.state.internals.StoreSerdeInitializerTest:
- shouldPrepareStoreSerdeForProcessorContext
- shouldThrowStreamsExceptionOnUndefinedKeySerdeForProcessorContext
- shouldThrowStreamsExceptionOnUndefinedKeySerdeForStateStoreContext
- shouldThrowStreamsExceptionOnUndefinedValueSerdeForProcessorContext
- shouldThrowStreamsExceptionOnUndefinedValueSerdeForStateStoreContext
- shouldThrowStreamsExceptionWithExplicitErrorMessageForProcessorContext
- shouldThrowStreamsExceptionWithExplicitErrorMessageForStateStoreContext
org.apache.kafka.streams.state.internals.StreamThreadStateStoreProviderTest:
- shouldFindKeyValueStores
- shouldFindSessionStores
- shouldFindTimestampedKeyValueStores
- shouldFindTimestampedKeyValueStoresAsKeyValueStores
- shouldFindTimestampedWindowStores
- shouldFindTimestampedWindowStoresAsWindowStore
- shouldFindWindowStores
- shouldNotFindKeyValueStoresAsTimestampedStore
- shouldNotFindWindowStoresAsTimestampedStore
- shouldReturnEmptyListForInvalidPartitions
- shouldReturnEmptyListIfNoStoresFoundWithName
- shouldReturnSingleStoreForPartition
- shouldThrowInvalidStoreExceptionIfKVStoreClosed
- shouldThrowInvalidStoreExceptionIfNotAllStoresAvailable
- shouldThrowInvalidStoreExceptionIfSessionStoreClosed
- shouldThrowInvalidStoreExceptionIfTsKVStoreClosed
- shouldThrowInvalidStoreExceptionIfTsWindowStoreClosed
- shouldThrowInvalidStoreExceptionIfWindowStoreClosed
org.apache.kafka.streams.state.internals.ThreadCacheTest:
- basicPutGet
- cacheOverheadsLargeValues
- cacheOverheadsSmallValues
- evict
- shouldCalculateSizeInBytes
- shouldCleanupNamedCacheOnClose
- shouldDelete
- shouldEvictAfterPutAll
- shouldEvictAfterPutIfAbsent
- shouldEvictImmediatelyIfCacheSizeIsVerySmall
- shouldEvictImmediatelyIfCacheSizeIsZero
- shouldFetchAllEntriesInCache
- shouldFetchAllEntriesInCacheInReverseOrder
- shouldFlushDirtyEntriesForNamespace
- shouldGetSameKeyAsPeekNext
- shouldGetSameKeyAsPeekNextReverseRange
- shouldNotBlowUpOnNonExistentKeyWhenDeleting
- shouldNotBlowUpOnNonExistentNamespaceWhenDeleting
- shouldNotClashWithOverlappingNames
- shouldNotFlushAfterDelete
- shouldNotFlushCleanEntriesForNamespace
- shouldNotForwardCleanEntryOnEviction
- shouldNotLoopForEverWhenEvictingAndCurrentCacheIsEmpty
- shouldPeekAndIterateOverRange
- shouldPeekAndIterateOverReverseRange
- shouldPeekNextKey
- shouldPeekNextKeyReverseRange
- shouldPutAll
- shouldPutIfAbsent
- shouldResizeAndShrink
- shouldReturnAllUnevictedValuesFromCache
- shouldReturnAllUnevictedValuesFromCacheInReverseOrder
- shouldReturnFalseIfNoNextKey
- shouldReturnFalseIfNoNextKeyReverseRange
- shouldReturnNullIfKeyIsNull
- shouldSkipEntriesWhereValueHasBeenEvictedFromCache
- shouldSkipEntriesWhereValueHasBeenEvictedFromCacheReverseRange
- shouldSkipToEntryWhenToInclusiveIsFalseInRange
- shouldThrowIfNoPeekNextKeyRange
- shouldThrowIfNoPeekNextKeyReverseRange
org.apache.kafka.streams.state.internals.TimeOrderedCachingPersistentWindowStoreTest:
- shouldBackwardFetchAndIterateOverExactKeys
- shouldClearNamespaceCacheOnClose
- shouldCloseCacheAfterErrorDuringStateStoreClose
- shouldCloseCacheAndWrappedStoreAfterErrorDuringCacheFlush
- shouldCloseWrappedStoreAfterErrorDuringCacheClose
- shouldDelegateInit
- shouldFetchAllBackwardWithinTimestampRange
- shouldFetchAllWithinTimestampRange
- shouldFetchAndIterateOverExactKeys
- shouldFetchAndIterateOverKeyBackwardRange
- shouldFetchAndIterateOverKeyRange
- shouldFlushEvictedItemsIntoUnderlyingStore
- shouldForwardDirtyItemToListenerWhenEvicted
- shouldForwardDirtyItemsWhenFlushCalled
- shouldForwardOldValuesWhenEnabled
- shouldGetAllBackwardFromCache
- shouldGetAllFromCache
- shouldIterateAcrossWindows
- shouldIterateBackwardAcrossWindows
- shouldIterateBackwardCacheAndStore
- shouldIterateBackwardCacheAndStoreKeyRange
- shouldIterateCacheAndStore
- shouldIterateCacheAndStoreKeyRange
- shouldMatchPositionAfterPutWithFlushListener
- shouldMatchPositionAfterPutWithoutFlushListener
- shouldNotForwardOldValuesWhenDisabled
- shouldNotReturnDuplicatesInRanges
- shouldNotThrowInvalidBackwardRangeExceptionWithNegativeFromKey
- shouldNotThrowInvalidRangeExceptionWithNegativeFromKey
- shouldNotThrowNullPointerExceptionOnPutNullValue
- shouldPutBackwardFetchRangeFromCacheForNullKeyFrom
- shouldPutBackwardFetchRangeFromCacheForNullKeyFromKeyTo
- shouldPutBackwardFetchRangeFromCacheForNullKeyTo
- shouldPutFetchFromCache
- shouldPutFetchRangeFromCache
- shouldPutFetchRangeFromCacheForNullKeyFrom
- shouldPutFetchRangeFromCacheForNullKeyFromKeyTo
- shouldPutFetchRangeFromCacheForNullKeyTo
- shouldReturnSameResultsForSingleKeyFetchAndEqualKeyRangeBackwardFetch
- shouldReturnSameResultsForSingleKeyFetchAndEqualKeyRangeFetch
- shouldSetFlushListener
- shouldSkipNonExistBaseKeyInCache
- shouldTakeValueFromCacheIfSameTimestampFlushedToRocks
- shouldThrowIfTryingToFetchFromClosedCachingStore
- shouldThrowIfTryingToFetchRangeFromClosedCachingStore
- shouldThrowIfTryingToWriteToClosedCachingStore
- shouldThrowIfWrongStore
- shouldThrowNullPointerExceptionOnFetchNullKey
- shouldThrowNullPointerExceptionOnPutNullKey
org.apache.kafka.streams.state.internals.TimeOrderedKeyValueBufferTest:
- shouldAcceptData
- shouldEvictOldestAndUpdateSizeAndCountAndMinTimestamp
- shouldFlush
- shouldInit
- shouldNotRestoreUnrecognizedVersionRecord
- shouldRejectNullValues
- shouldRemoveData
- shouldRespectEvictionPredicate
- shouldRestoreOldUnversionedFormat
- shouldRestoreV1Format
- shouldRestoreV2Format
- shouldRestoreV3Format
- shouldRestoreV3FormatWithV2Header
- shouldReturnPriorValueForBufferedKey
- shouldReturnUndefinedOnPriorValueForNotBufferedKey
- shouldTrackCount
- shouldTrackMinTimestamp
- shouldTrackSize
org.apache.kafka.streams.state.internals.TimeOrderedWindowStoreTest:
- shouldBackwardFetchAndIterateOverExactKeys
- shouldClearNamespaceCacheOnClose
- shouldCloseCacheAfterErrorDuringStateStoreClose
- shouldCloseCacheAndWrappedStoreAfterErrorDuringCacheFlush
- shouldCloseWrappedStoreAfterErrorDuringCacheClose
- shouldDelegateInit
- shouldFetchAllBackwardWithinTimestampRange
- shouldFetchAllWithinTimestampRange
- shouldFetchAndIterateOverExactKeys
- shouldFetchAndIterateOverKeyBackwardRange
- shouldFetchAndIterateOverKeyRange
- shouldFlushEvictedItemsIntoUnderlyingStore
- shouldForwardDirtyItemToListenerWhenEvicted
- shouldForwardDirtyItemsWhenFlushCalled
- shouldForwardOldValuesWhenDisabled
- shouldForwardOldValuesWhenEnabled
- shouldGetAllBackwardFromCache
- shouldGetAllFromCache
- shouldIterateAcrossWindows
- shouldIterateBackwardAcrossWindows
- shouldIterateBackwardCacheAndStore
- shouldIterateBackwardCacheAndStoreKeyRange
- shouldIterateCacheAndStore
- shouldIterateCacheAndStoreKeyRange
- shouldMatchPositionAfterPutWithFlushListener
- shouldMatchPositionAfterPutWithoutFlushListener
- shouldNotReturnDuplicatesInRanges
- shouldNotThrowInvalidBackwardRangeExceptionWithNegativeFromKey
- shouldNotThrowInvalidRangeExceptionWithNegativeFromKey
- shouldNotThrowNullPointerExceptionOnPutNullValue
- shouldPutBackwardFetchRangeFromCacheForNullKeyFrom
- shouldPutBackwardFetchRangeFromCacheForNullKeyFromKeyTo
- shouldPutBackwardFetchRangeFromCacheForNullKeyTo
- shouldPutFetchFromCache
- shouldPutFetchRangeFromCache
- shouldPutFetchRangeFromCacheForNullKeyFrom
- shouldPutFetchRangeFromCacheForNullKeyFromKeyTo
- shouldPutFetchRangeFromCacheForNullKeyTo
- shouldReturnSameResultsForSingleKeyFetchAndEqualKeyRangeBackwardFetch
- shouldReturnSameResultsForSingleKeyFetchAndEqualKeyRangeFetch
- shouldSetFlushListener
- shouldSkipNonExistBaseKeyInCache
- shouldTakeValueFromCacheIfSameTimestampFlushedToRocks
- shouldThrowIfTryingToFetchFromClosedCachingStore
- shouldThrowIfTryingToFetchRangeFromClosedCachingStore
- shouldThrowIfTryingToWriteToClosedCachingStore
- shouldThrowIfWrongStore
- shouldThrowNullPointerExceptionOnFetchNullKey
- shouldThrowNullPointerExceptionOnPutNullKey
org.apache.kafka.streams.state.internals.TimestampedKeyAndJoinSideSerializerTest:
- shouldSerializeKeyWithJoinSideAsFalse
- shouldSerializeKeyWithJoinSideAsTrue
- shouldThrowIfSerializeNullData
org.apache.kafka.streams.state.internals.TimestampedKeyValueStoreBuilderTest:
- shouldHaveCachingAndChangeLoggingWhenBothEnabled
- shouldHaveCachingStoreWhenEnabled
- shouldHaveChangeLoggingStoreByDefault
- shouldHaveChangeLoggingStoreWhenLoggingEnabled
- shouldHaveMeteredStoreAsOuterStore
- shouldNotHaveChangeLoggingStoreWhenDisabled
- shouldNotThrowNullPointerIfKeySerdeIsNull
- shouldNotThrowNullPointerIfValueSerdeIsNull
- shouldNotWrapTimestampedByteStore
- shouldThrowNullPointerIfInnerIsNull
- shouldThrowNullPointerIfMetricsScopeIsNull
- shouldThrowNullPointerIfTimeIsNull
- shouldWrapPlainKeyValueStoreAsTimestampStore
org.apache.kafka.streams.state.internals.TimestampedSegmentTest:
- shouldBeEqualIfIdIsEqual
- shouldCompareSegmentIdOnly
- shouldDeleteStateDirectoryOnDestroy
- shouldHashOnSegmentIdOnly
org.apache.kafka.streams.state.internals.TimestampedSegmentsTest:
- futureEventsShouldNotCauseSegmentRoll
- shouldBaseSegmentIntervalOnRetentionAndNumSegments
- shouldCleanupSegmentsThatHaveExpired
- shouldClearSegmentsOnClose
- shouldCloseAllOpenSegments
- shouldCreateSegments
- shouldGetCorrectSegmentString
- shouldGetSegmentForTimestamp
- shouldGetSegmentIdsFromTimestamp
- shouldGetSegmentNameFromId
- shouldGetSegmentsWithinBackwardTimeRange
- shouldGetSegmentsWithinBackwardTimeRangeOutOfOrder
- shouldGetSegmentsWithinTimeRange
- shouldGetSegmentsWithinTimeRangeOutOfOrder
- shouldNotCreateSegmentThatIsAlreadyExpired
- shouldOpenExistingSegments
- shouldRollSegments
- shouldUpdateSegmentFileNameFromOldColonFormatToNewFormat
- shouldUpdateSegmentFileNameFromOldDateFormatToNewFormat
org.apache.kafka.streams.state.internals.TimestampedWindowStoreBuilderTest:
- shouldDisableCachingWithRetainDuplicates
- shouldHaveCachingAndChangeLoggingWhenBothEnabled
- shouldHaveCachingStoreWhenEnabled
- shouldHaveChangeLoggingStoreByDefault
- shouldHaveChangeLoggingStoreWhenLoggingEnabled
- shouldHaveMeteredStoreAsOuterStore
- shouldNotHaveChangeLoggingStoreWhenDisabled
- shouldNotWrapTimestampedByteStore
- shouldThrowNullPointerIfInnerIsNull
- shouldThrowNullPointerIfMetricsScopeIsNull
- shouldThrowNullPointerIfTimeIsNull
- shouldWrapPlainKeyValueStoreAsTimestampStore
org.apache.kafka.streams.state.internals.ValueAndTimestampSerializerTest:
- shouldDropSerializedValueIfEqualWithGreaterTimestamp
- shouldKeepSerializedValueIfOutOfOrder
- shouldReturnNullWhenTheInternalSerializerReturnsNull
- shouldSerializeNonNullDataUsingTheInternalSerializer
- shouldSerializeNullDataAsNull
org.apache.kafka.streams.state.internals.VersionedKeyValueStoreBuilderTest:
- shouldHaveChangeLoggingStoreByDefault
- shouldHaveChangeLoggingStoreWhenLoggingEnabled
- shouldHaveMeteredStoreAsOuterStore
- shouldNotHaveChangeLoggingStoreWhenDisabled
- shouldNotThrowNullPointerIfKeySerdeIsNull
- shouldNotThrowNullPointerIfValueSerdeIsNull
- shouldThrowNullPointerIfInnerIsNull
- shouldThrowNullPointerIfMetricsScopeIsNull
- shouldThrowNullPointerIfNameIsNull
- shouldThrowNullPointerIfTimeIsNull
- shouldThrowWhenCachingEnabled
org.apache.kafka.streams.state.internals.WindowKeySchemaTest:
- shouldConvertFromNonPrefixWindowKey
- shouldConvertToBinaryAndBack
- shouldDeserializeEmptyByteArrayToNull
- shouldDeserializeNullToNull
- shouldExtractBytesKeyFromBinary
- shouldExtractKeyBytesFromBinary
- shouldExtractSequenceFromBinary
- shouldExtractStartTimeFromBinary
- shouldExtractWindowFromBinary
- shouldSerializeDeserialize
- shouldSerializeDeserializeExpectedChangelogWindowSize
- shouldSerializeDeserializeExpectedWindowSize
- shouldSerializeNullToNull
- testHasNextConditionUsingNullKeys
- testLowerBoundMatchesTrailingZeros
- testLowerBoundWithNonZeroTimestamp
- testLowerBoundWithZeroTimestamp
- testSerializeDeserializeOverflowWindowSize
- testUpperBoundWithKeyBytesLargerAndSmallerThanFirstTimestampByte
- testUpperBoundWithKeyBytesLargerThanFirstTimestampByte
- testUpperBoundWithLargeTimestamps
- testUpperBoundWithZeroTimestamp
org.apache.kafka.streams.state.internals.WindowStoreBuilderTest:
- shouldDisableCachingWithRetainDuplicates
- shouldDisableLogCompactionWithRetainDuplicates
- shouldHaveCachingAndChangeLoggingWhenBothEnabled
- shouldHaveCachingStoreWhenEnabled
- shouldHaveChangeLoggingStoreByDefault
- shouldHaveChangeLoggingStoreWhenLoggingEnabled
- shouldHaveMeteredStoreAsOuterStore
- shouldNotHaveChangeLoggingStoreWhenDisabled
- shouldThrowNullPointerIfInnerIsNull
- shouldThrowNullPointerIfMetricsScopeIsNull
- shouldThrowNullPointerIfTimeIsNull
org.apache.kafka.streams.state.internals.WindowStoreFetchTest:
- testStoreConfig
org.apache.kafka.streams.state.internals.WrappingStoreProviderTest:
- shouldFindKeyValueStores
- shouldFindWindowStores
- shouldReturnAllStoreWhenQueryWithoutPartition
- shouldReturnSingleStoreWhenQueryWithPartition
- shouldThrowInvalidStoreExceptionIfNoPartitionFound
- shouldThrowInvalidStoreExceptionIfNoStoreOfTypeFound
org.apache.kafka.streams.state.internals.metrics.NamedCacheMetricsTest:
- shouldGetHitRatioSensorWithBuiltInMetricsVersionCurrent
org.apache.kafka.streams.state.internals.metrics.RocksDBBlockCacheMetricsTest:
- shouldRecordCorrectBlockCacheCapacity
- shouldRecordCorrectBlockCachePinnedUsage
- shouldRecordCorrectBlockCacheUsage
org.apache.kafka.streams.state.internals.metrics.RocksDBMetricsRecorderGaugesTest:
- shouldGetCapacityOfBlockCacheWithMultipleCaches
- shouldGetCapacityOfBlockCacheWithSingleCache
- shouldGetCompactionPending
- shouldGetCurrentSizeofActiveMemTable
- shouldGetCurrentSizeofAllMemTables
- shouldGetEstimatedBytesOfPendingCompactions
- shouldGetEstimatedMemoryOfTableReaders
- shouldGetEstimatedNumberOfKeys
- shouldGetLiveSstFilesSize
- shouldGetMemTableFlushPending
- shouldGetNumberOfBackgroundErrors
- shouldGetNumberOfDeletesActiveMemTable
- shouldGetNumberOfDeletesImmutableMemTables
- shouldGetNumberOfEntriesActiveMemTable
- shouldGetNumberOfEntriesImmutableMemTables
- shouldGetNumberOfImmutableMemTables
- shouldGetNumberOfRunningCompactions
- shouldGetNumberOfRunningFlushes
- shouldGetPinnedUsageOfBlockCacheWithMultipleCaches
- shouldGetPinnedUsageOfBlockCacheWithSingleCache
- shouldGetSizeofAllMemTables
- shouldGetTotalSstFilesSize
- shouldGetUsageOfBlockCacheWithMultipleCaches
- shouldGetUsageOfBlockCacheWithSingleCache
org.apache.kafka.streams.state.internals.metrics.RocksDBMetricsRecorderTest:
- shouldAddItselfToRecordingTriggerWhenFirstValueProvidersAreAddedAfterLastValueProvidersWereRemoved
- shouldAddItselfToRecordingTriggerWhenFirstValueProvidersAreAddedToNewlyCreatedRecorder
- shouldCorrectlyHandleAvgRecordingsWithZeroSumAndCount
- shouldCorrectlyHandleHitRatioRecordingsWithZeroHitsAndMisses
- shouldInitMetricsRecorder
- shouldNotAddItselfToRecordingTriggerWhenNotEmpty
- shouldNotRecordStatisticsBasedMetricsIfStatisticsIsNull
- shouldNotRemoveItselfFromRecordingTriggerWhenAtLeastOneValueProviderIsPresent
- shouldNotSetStatsLevelToExceptDetailedTimersWhenValueProvidersWithoutStatisticsAreAdded
- shouldRecordStatisticsBasedMetrics
- shouldRemoveItselfFromRecordingTriggerWhenAllValueProvidersAreRemoved
- shouldSetStatsLevelToExceptDetailedTimersWhenValueProvidersWithStatisticsAreAdded
- shouldThrowIfCacheToAddIsNotNullButExistingCacheIsNull
- shouldThrowIfCacheToAddIsNotSameAsAllExistingCaches
- shouldThrowIfCacheToAddIsNullButExistingCacheIsNotNull
- shouldThrowIfCacheToAddIsSameAsOnlyOneOfMultipleCaches
- shouldThrowIfDbToAddWasAlreadyAddedForOtherSegment
- shouldThrowIfMetricRecorderIsInitialisedWithNullMetrics
- shouldThrowIfMetricRecorderIsInitialisedWithNullTaskId
- shouldThrowIfMetricRecorderIsReInitialisedWithDifferentStreamsMetrics
- shouldThrowIfMetricRecorderIsReInitialisedWithDifferentTask
- shouldThrowIfStatisticsToAddIsNotNullButExistingStatisticsAreNull
- shouldThrowIfStatisticsToAddIsNullButExistingStatisticsAreNotNull
- shouldThrowIfValueProvidersForASegmentHasBeenAlreadyAdded
- shouldThrowIfValueProvidersToRemoveNotFound
org.apache.kafka.streams.state.internals.metrics.RocksDBMetricsRecordingTriggerTest:
- shouldThrowIfRecorderToAddHasBeenAlreadyAdded
- shouldThrowIfRecorderToRemoveCouldNotBeFound
- shouldTriggerAddedMetricsRecorders
org.apache.kafka.streams.state.internals.metrics.RocksDBMetricsTest:
- shouldAddBackgroundErrorsMetric
- shouldAddBlockCacheCapacityMetric
- shouldAddBlockCachePinnedUsageMetric
- shouldAddBlockCacheUsageMetric
- shouldAddCompactionPendingMetric
- shouldAddCurSizeActiveMemTableMetric
- shouldAddCurSizeAllMemTablesMetric
- shouldAddEstimateNumKeysMetric
- shouldAddEstimatePendingCompactionBytesMetric
- shouldAddEstimateTableReadersMemMetric
- shouldAddLiveSstFilesSizeMetric
- shouldAddMemTableFlushPendingMetric
- shouldAddNumDeletesImmutableMemTablesMetric
- shouldAddNumEntriesActiveMemTableMetric
- shouldAddNumEntriesImmutableMemTablesMetric
- shouldAddNumImmutableMemTablesMetric
- shouldAddNumLiveVersionMetric
- shouldAddNumRunningCompactionsMetric
- shouldAddNumRunningFlushesMetric
- shouldAddNumberDeletesActiveTableMetric
- shouldAddSizeAllMemTablesMetric
- shouldAddTotalSstFilesSizeMetric
- shouldGetBlockCacheDataHitRatioSensor
- shouldGetBlockCacheFilterHitRatioSensor
- shouldGetBlockCacheIndexHitRatioSensor
- shouldGetBytesReadDuringCompactionSensor
- shouldGetBytesReadSensor
- shouldGetBytesWrittenDuringCompactionSensor
- shouldGetBytesWrittenSensor
- shouldGetCompactionTimeAvgSensor
- shouldGetCompactionTimeMaxSensor
- shouldGetCompactionTimeMinSensor
- shouldGetMemtableAvgFlushTimeSensor
- shouldGetMemtableBytesFlushedSensor
- shouldGetMemtableHitRatioSensor
- shouldGetMemtableMaxFlushTimeSensor
- shouldGetMemtableMinFlushTimeSensor
- shouldGetNumberOfFilesErrors
- shouldGetNumberOfOpenFilesSensor
- shouldGetWriteStallDurationSensor
org.apache.kafka.streams.state.internals.metrics.StateStoreMetricsTest:
- shouldGetAllSensor
- shouldGetDeleteSensor
- shouldGetFetchSensor
- shouldGetFlushSensor
- shouldGetGetSensor
- shouldGetPrefixScanSensor
- shouldGetPutAllSensor
- shouldGetPutIfAbsentSensor
- shouldGetPutSensor
- shouldGetRangeSensor
- shouldGetRecordE2ELatencySensor
- shouldGetRemoveSensor
- shouldGetRestoreSensor
- shouldGetSuppressionBufferCountSensor
- shouldGetSuppressionBufferSizeSensor
org.apache.kafka.streams.tests.RelationalSmokeTestTest:
- verifySmokeTestLogic
org.apache.kafka.streams.tests.SystemTestUtilTest:
- shouldParseCorrectMap
- shouldParseSingleKeyValuePairString
- shouldThrowExceptionIfNotCorrectKeyValuePairSeparator
- shouldThrowExceptionIfNotCorrectKeyValueSeparator
- shouldThrowExceptionOnNull
